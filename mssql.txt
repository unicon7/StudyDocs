1강 Connecting to SQL Server using SSMS
SSMS(SQL Server Management Studio)는 서버에 접속하는 클라이언트 툴이지 서버자체가 아니다. SSMS를 사용하여 SQL서버에 접속한다.

서버 접속 화면에서
Server name : ip를 적어준다. 127.0.0.1, (local) 혹은 .으로 localserver를 표시
Authentication : SQL Server를 인스톨시 옵션으로 선택해 준것을 따른다. 
옵션은 mixed-mode Authentication, sql server Authentication이다.
mixed-mode Authentication을 선택해서 인스톨했을경우 windows Authentication과 SQL server Authentication을 사용할수 있다.
window Authentication을 사용할경우 아이디와 암호가 필요가 없다. 기본적으로 윈도우 로그인을 통해 이미 자신이 누구인지 알수있으며 윈도우 사용자 정보를
사용하여 검증가능하기때문이다.

sa라는 아이디는 system admin의 약자로 일반적으로 많이 사용된다.
New Query라는 버튼을 누르면 Query editor 윈도우가 나타난다.


2강 Creating altering and dropping a database
database는 생성, 수정, 삭제 하는 방법이 2가지이다.
1.SSMS의 GUI메뉴를 통해
2.Query 사용

database, table, trigger, stored procedure등 모든것이 object이다.
대부분의 명령은 명령 object의 형태이다.

Query를 사용하여 Database생성
Create Database Sample2

database를 생성하면 2개의 화일이 생성된다.
.MDF 화일 - Data 화일(실제 data)
.LDF 화일 - 트랜젝션 로그화일(database를 복구하는데 사용된다.)

database를 수정할때 Query혹은 stored procedure를 사용하여 수정한다.
Alter database DatabaseName Modify Name = NewDatabaseName
Alter Database Sample2 Modify Name=Sample3
sp_renameDB 'OldDatabaseName','NewDatabaseName' 를 실행한다.
sp_renameDB 'Sample2','Sample3'

stored procedure는 같이 실행될 커맨드들의 그룹이다.
system sp(ms가 만들어준거)와 custom sp(개발자가 만드는거)가 있다.


database drop하면 mdf, ldf화일이 지워진다.
Drop database sample1
사용중일때 database drop을 할수 없다. 그래서 만약 다른 유저가 연결되어 있을때 database drop을 하려면 single user mode로 database를 수정하고 drop해야한다.
Alter Database DatabaseName Set SINGLE_USER With Rollback Immediate

Rollback Immediate => 만약 사용중인 다른 유저의 완료되지 않은 transaction이 있다면 롤백뒤 다른 사용자의 database 연결을 끊는다.

System database들은 drop안댐.

3강 Creating and working with tables
1. table들을 생성한다.
2. PK와 FK제약을 건다.

Primay Key : 그 테이블에 있는 각각의 record들을 유니크하게 구별하기 위해 쓰인다.
예) tblPerson에서 ID는 name 컬럼이 Mary로 같은 레코드를 구별한다. 아마도 이름이 Mary로 같은 다른 사람일 것이다.

GUI로 생성하는법 => tblPerson에서 context menu>Design선택 GenderId에서 Relationship을 선택, table and colume spec 선택뒤 ...클릭
Primary key table : tblGender Id
Foreign key table : tblPerson GenderId 선택
오른쪽 explorer에 tblPerson>Key>PK_tblPerson_tblGender화일 생성되어 있음


Query로 생성하는법
Use [Sample]    <= 현재 context가 Sample이 아닌경우 Smaple database로 현재 Database를 바꾼뒤 다음을 실행하라는 스크립트.
Go

Create Table tblGender
(
  ID int NOT NULL Primary Key,
  Gender nvarchar(50) NOT NULL
)

Primary Key Constraint가 걸려있다라고 이야기 한다.

tblPerson의 GenderID를 tblGender의 FK로 만들자
FK의 장점
FK Relationship이 없을때 tblPerson의 GenderID에 아무거나 넣을수 있다. 99같은 tblGenderID에 없는 아이디를 넣는다던지..
이런 상황을 database integrity가 깨졌다라고한다. 만약 FK Relationship을 갖는다면 이러한 상황을 허락하지 않는다.
tblPerson : FK table
tblGender : PK table

Foreign Key Constraint
GUI로 생성하는 방법 => tblPerson 에서 오른쪽 키, Design선택, Tables And Columns Specification옆의 ...선택 UI사용하여 테이블들과 컬럼 선택하면 된다.

Query
Alter table ForeignKeyTable add constraint ForeignKeyTable_ForiegnKeyColum_FK Foreign Key (ForiegnKeyColumn) references PrimaryKeyTable (PrimaryKeyColumn)
Alter table tblPerson add constraint tblPerson_GenderID_FK Foreign Key (GenderId) references tblGender (ID)

object explorer에서 tblPerson의 Keys 항목을 열면 tblPerson_GenderID_FK이라는 이름으로 key가 생긴것을 볼수있다.

Query의 문법은 그닥 중요하지 않다. 검색을통해 찾을수 있으며 아무도 물어보지 않을것이다. 중요한건 FK Constraint의 개념이 무엇인지? FK Constraint를 왜 쓰는지?에대한
것을 알고 있어야 한다.

tblPerson의 GenderID에 FK Constraint를 걸었기때문에 GenderID의 값은 tblGender의 ID 값에 있는 것만이 입력될수있다. 이제 GenderID의 값은 확인(Verify)되어진다.
FK Constraint 잘못된 값을 넣을수 없게 database가 확인하고 방지한다.

verification: Are we building the product right?
프로덕트를 제대로 만들고 있는거 맞지?
즉, 제품을 만들 때 각 단계(프로세스)의 요구사항을 잘 지켜가며 만들었는지를 확인하는 것이다. 쉽게 말하자면 무언가를 만드는 '과정'을 잘 지켰는지를 말한다.

validation: Are we building the right product?
제대로 된 프로덕트를 만들고 있는거 맞지?
제품을 최종적으로 만들고 난 후 최종 산출물이 유저가 원하는게 맞는지 물어보는 단계이다. 쉽게 말하자면 무언가를 최종적으로 만든 결과물이 잘 나왔는지를 말한다.

4강 Adding a default constraint
tblPerson GnderId가 Not null이 아니기때문에 NULL이 들어갈수 있다.

Insert into tblPerson (ID, Name, Email) Values(7, 'Rich', 'r@.r.com') => GenderID를 주지 않았기때문에 GenderID가 NULL이된다.
NULL을 insert하는 대신에 3 Unknown을 넣게 하고 싶다. 즉 default를 원한다.

Default Constraint
Altering an existing column to add a default constraint:
ALTER TABLE { TABLE_NAME }
ADD CONSTRAINT { CONSTRAINT_NAME }
DEFAULT { DEFAULT_VALUE } FOR { EXISTING_COLUMN_NAME }

Adding a new column, with default value, to an existing table:
ALTER TABLE { TABLE_NAME } 
ADD { COLUMN_NAME } { DATA_TYPE } { NULL | NOT NULL } 
CONSTRAINT { CONSTRAINT_NAME } DEFAULT { DEFAULT_VALUE }

ALTER TABLE tblPerson 
ADD CONSTRAINT DF_tblPerson_GenderId 
DEFAULT 3 FOR GenderID

Insert into tblPerson (ID, Name, Email, GenderId) VALUES (10, 'johny', 'j@r.com', NULL)
=>NULL을 명시적으로 주었기때문에 Defualt Constraint가 작동되지 않고 NULL이 들어간다. 

To drop a constraint
ALTER TABLE { TABLE_NAME } 
DROP CONSTRAINT { CONSTRAINT_NAME }

5강 Cascading referential integrity constraint
Cascading referential integrity constraint
=> FK에 의해 참조되고있는 PK를 Delete, Update할때 SQL Server는 어떤 액션을 할지 정의할수 있다.

Foreign Key를 더블클릭하여 Foreign Key RelationShip창을 열고 INSERT And UPDATE Specification을 선택하면 Delete, Update시의 옵션을 정의해줄수 있다.

Cascading referential integrity constraint options
1.No Action: 디폴트동작이다. 다른테이블에 있는 FK에의해 참조되는 행을 delete 또는 update하려할때 에러가 발생하며
delete, update는 롤백된다.
2.Cascade: 다른테이블에 있는 FK에의해 참조되는 행을 Delete, Update하려는 경우 다른테이블에있는 FK를 가진 모든 행또한 delete되거나 update된다.
3.Set NULL: 다른테이블에 있는 FK에의해 참조되는 행을 Delete, Update하려는 경우 다른테이블에있는 FK를 가진 모든 행의 FK가 전부 NULL이된다.
4.Set Default: 다른테이블에 있는 FK에의해 참조되는 행을 Delete, Update하려는 경우 FK로 참조하고 있는 모든 행의 FK가 전부 default값이 된다.
컬럼에 default constraint가 걸려 있어야 한다.

[CONSTRAINT symbol] FOREIGN KEY [id] (index_col_name, ...)
    REFERENCES tbl_name (index_col_name, ...)
    [ON DELETE {RESTRICT | CASCADE | SET NULL | NO ACTION}]
    [ON UPDATE {RESTRICT | CASCADE | SET NULL | NO ACTION}]


6강 Adding a check constraint
check constraint => 컬럼에 값으로 들어올수 있는 값들의 범위를 제한하는데 쓰인다.
ALTER TABLE {TABLE_NAME}
ADD CONSTRAINT {CONSTRAINT_NAME} CHECK (BOOLEAN_EXPRESSION)

ALTER TABLE tblPerson
ADD CONSTRAINT CK_tblPerson_Age CHECK (Age > 0 AND Age < 150)

만약 BOOLEAN_EXPRESSION이 true를 리턴하면 CHECK Constraint는 값을 통과시키며 그렇지 않은경우 값을 통과 시키지 못한다.
Age가 NULLABLE 컬럼이기때문에 null을 이 컬럼에 전달할 수 있으며 Age 컬럼에 NULL이 전달되었을때 BOOLEAN_EXPRESSION은 false가 아닌
UNKNOWN으로 평가되고 값이 허락된다. BOOLEAN_EXPRESSION은 false만 통과를 안시킨다.


Check constraint drop하기
ALTER TABLE tblPerson
DROP CONSTRAINT CK_tblPerson_Age


7강 Identity Column in SQL Server
만약 컬럼이 Identity Column으로 지정된다면 테이블에 새로운 행을 insert할때마다 그 컬럼의 값이 자동적으로 생성된다.(넣어줄 필요 없다.)
Create Table tblPerson
(
  PersonId int Identity(1,1) Primary Key,  => seed와 increment값은 Optional하다. 명시하지 않으면 둘다 1값을 가진다.
  Name nvarchar(20)
)

만약 행의 delete로 Identity 컬럼의 중간 숫자가 비었다고 하자. 1.2.3.4.7.8.9
5,6에 다시 행을 insert 하고 싶을때
=> Identity 컬럼에 명시적으로 값을 제공하려면
1. identity insert를 켠다.
SET Identity_Insert tblPerson ON
2. insert query에 컬럼리스트를 명시한다.
INSERT INTO tblPerson(PersonId, Name) VALUES(2, 'John')

만약 테이블의 모든 행을 지웠고, identity 컬럼을 리셋하고 싶다면 DBCC CHECKIDENT 명령을 써라. (DBCC: Database Consistency Check Command)
DBCC CHECKIDENT('tblPerson', RESEED, 0)

tblPerson테이블의 ID는 PK이지만 identity 컬럼은 아니다. 확인 방법은 key의 property를 열어 identity 항목을 보면된다.(한글판에는 ID사양)

PersonId Name
1 jay
2 tom
3 sara
4 Todd
일때
Delete from tblPerson Where PersonId = 1을 실행하면 1 jay가 지워진다.
identity컬럼이기때문에 다음 Insert에서 5가 추가된다.
PersonId Name
2 tom
3 sara
4 Todd
5 Jane

Insert into dbo.tblPerson1 values(1, 'Jane') => identity colume에 1이라는 값을 주려고 했다.
만약 1이 비었으니 1에 넣으려고 하면 에러 난다. 이럴때는 IDENTITY_INSERT ON을 해줘야 한다.
SET IDENTITY_INSERT tblPerson ON
또한 Insert query에 컬럼리스트를 꼭 써야한다.
Insert into dbo.tblPerson1 (PersonId, Name) values(1, 'Jane')
Insert into dbo.tblPerson1 values(1, 'Jane') 컬럼리스트를 빼먹으면 에러, 다시 IDENTITY_INSERT OFF를 해야한다.

8강 How to get the last generated identity column value
A scope is a module: a stored procedure, trigger, function, or batch(Go로 batch를 나눈다). Therefore, two statements are in the same scope 
if they are in the same stored procedure, function, or batch.

어떻게 마지막으로 생성된 Identity 컬럼의 값을 가져올수 있나?
 SCOPE_IDENTITY() - 같은 세션과 같은 스코프에서 생성된 마지막 identity값
 @@IDENTITY - 같은 세션내 스코프에 상관없이 생성된 마지막 identity값
 IDENT_CURRENT('TableName') - 어떠한 세션 과 스코프에 상관없이 명시된 테이블으 마지막 identity값

 Select SCOPE_IDENTITY()
 Select @@IDENTITY 형식으로 호출한다.

SCOPE_IDENTITY()을 대부분 사용하여 자신이 행한 query문에 의해 생성된 마지막 identity컬럼 값을 가져온다.

세션은 query를 날리는 연결을 뜻한다. 여러 db 사용자의 연결을 생각하면 될듯.Query window를 여러개 띄우면 된다.
Insert into Test1 Values('X') 를 실행할때 현재의 Scope는 위의 우리가 입력한 query이다.


SCOPE_IDENTITY(), @@IDENTITY 차이
trigger를 사용해서 test1에 Insert될때 test2도 자동으로 Insert되도록 해본다.
Create Trigger trForInsert on Test1 for Insert
as
Begin
  Insert into Test2 Values ('Y')
End

위의 trigger가 test1테이블에 걸려 있을때

Insert into Test1 Values('X')를 query 하면?
우리가 생각하는 Scope는 Insert into Test1 Values('X')이며
SCOPE_IDENTITY()함수를 통해 위의 query로 변경된 Test1 테이블의 마지막 Identity 컬럼 값을 가져 올수있다.
하지만 Insert시 Trigger를 걸었기 때문에 한번의 Insert가 더 된다. 이는 Insert into Test1 Values('X')의 스코프와 
트리거 안의 Insert into Test1 Values('Y'), 스코프가 다른 identity컬럼이 실행된다.
SCOPE_IDENTITY()는  Insert into Test1 Values('X')에 관련된 테이블의 마지막 identity값을 가져오고,
@@IDENTITY는 다른 스코프인 Insert into Test1 Values('Y')에의한 identity값을 가져온다.

유저 여러명이 TableName에 접근한다고 할때(세션이 1개 이상일때)
IDENT_CURRENT('TableName')을 호출하는 순간 다른 유저들의 변경 사항을 포함한 현재 마지막 identity값을 가져온다.

SCOPE_IDENTITY()가 실전에서는 상당히 많이 쓰인다.
예를 들면 어떤 상품을 Insert했다고 했을때 그 상품의 Identity값을 SCOPE_IDENTITY()를 통해 바로 알수 있다.

9강 Unique key constraint - Part 9
컬럼의 uniqueness를 강제 하기 위해 UNIQUE constraint를 쓸수있다.

Alter Table Table_Name Add Constraint Constraint_Name Unique(Column_Name)

PK와 Unique key constraint의 차이점은?
1.테이블은 1개의 PK만 가질수 있지만, unique key는 1개 이상 가질수 있다.
2.PK는 NULL을 허용하지 않는다. 반면 Unique key는 1개의 NULL을 허용한다.

Design선택 => 컬럼위에서 context menu ->Indexes/Keys선택/ -> IsUnique:True와 Type:Unique Key선택
Query로 하면..
Alter Table tblPerson
Add Constraint UQ_tblPerson_Email Unique(Email)

10강 Select statement in sql server
Select specific or all Columns
Select * from tblPerson 또는
Select  (모든 컬럼 리스트) from tblPerson
모든 컬럼 리스트를 타이핑하기 힘들다면 테이블 context menu => Script Table as => SELECT to => New Query editor window 선택
새로운 스크립트화일이 나타난다.
SELECT [ID]
      ,[Name]
      ,[Email]
      ,[GenderId]
      ,[Age]
      ,[City]
    FROM [Sample].[dbo].[tblPerson]
GO

[Sample].[dbo].[tblPerson] => database.schema.테이블이름=>테이블의 Fully qualified name이다.
Fully qualified name을 쓰면 현재 어떤 database를 선택해 있던지 상관없이 잘 동작한다.(절대경로 같은 것으로 이해하자)

모든 컬럼을 쓸때 *보다는 모든 컬럼을 쓰는게 퍼포먼스가 좋다.


Distinct Row
Select DISTINCT City from tblPerson
=>중복이 제거된 도시만 나타난다.

Select DISTINCT Name, City from tblPerson => 이건 Distinct City를 출력하지 않는다. NAME과 City가 모두 같아야 같은 것으로 취급...
Josh, London
Tom, London 은 Distinct하다. column의 pair가 같아야 한다.

Filtering with where clause
Select * from tblPerson Where City = 'London' => equal to
Select * from tblPerson Where City <> 'London' => not equal to
Select * from tblPerson Where City != 'London' => not equal to
Select * from tblPerson Where Age IN (20, 23 29)
Select * from tblPerson Where Age BETWEEN 20 AND 25 => 20, 25 포함

LIKE는 WildCard들과 같이 쓰인다.
Select * from tblPerson Where City LIKE 'L%' =>L로 시작하는 City 
Select * from tblPerson Where Email LIKE '%@% =>Eamil형태의 패턴
Select * from tblPerson Where Email NOT LIKE '%@% =>Eamil형태가 아닌 패턴

WildCard
% : 0개 이상의 캐릭터들
_ : 정확히 1개의 캐릭터
[] : 안에있는 어떠한 캐릭터
[~] : 안에있는 캐릭터를 제외한 캐릭터

Select * from tblPerson Where Email LIKE '_@_.com' =>A@A.com B@B.com등
Select * from tblPerson Where Name LIKE '[MST]%' =>M, S, T로 시작하는 이름  Mary, Sam, Tom등
Select * from tblPerson Where Name LIKE '[^MST]%' =>M, S, T로 시작하지 않는 이름

여러 조건들은 합치기
Select * from tblPerson Where (City='London' or City ='Mumabi') AND Age > 25

Order by를 사용하여 행들을 정렬하기
Select * from tblPerson order by Name => 디폴트 ASC
Select * from tblPerson order by Name DESC, Age ASC => 처음은 Name으로 정렬뒤 같은 이름은 Age로 ASC로 정렬

행들중 top n 또는 top n percentage 선택하기
Select top 2 * from tblPerson =>위에서부터 2개
Select top 2 Name, Age from tblPerson
Select top 20 Percent * from tblPerson =>위에서부터 20%

가장 나이 많은 사람 찾기
Select top 1 * from tblPerson Order by DESC

11강 Group by in sql server
GROUP BY 절은 선택된 행들을 한개 이상의 컬럼이나 expression을 사용하여 summary set으로 그룹을 만드는데 쓰인다.
GROUP BY는 항상 1개 이상의 aggregate function(집계함수)와 함께 쓰인다.
SELECT City, SUM(Salary) AS TotalSalary FROM tblEmployee GROUP BY City

Select SUM(Salary) from tblEmployee
Select MIN(Salary) from tblEmployee
Select MAX(Salary) from tblEmployee

SELECT City, SUM(Salary) AS TotalSalary FROM tblEmployee GROUP BY City  <= AS로 컬럼 이름을 준다.
SELECT City, SUM(Salary) AS TotalSalary FROM tblEmployee <= GROUP BY를 없애면 에러~ GROUP BY로 그룹핑하지 않고 SUM을 호출하기때문에 논리적으로 에러
Select 리스트에 포함 되는 컬럼들은 2가지중 한가지를 만족해야 한다.
GROUP BY에 나타 나거나 집계함수에 나타나야 한다.

Select City, Gender, SUM(Salary) AS TotalSalary FROM tblEmployee GROUP BY CITY, Gender Order by City
Select Gender, City, SUM(Salary) AS TotalSalary FROM tblEmployee GROUP BY Gender, City <= 출력 순서를 바꾸려면 다 바꿔라(select의 컬럼 리스트와 GroupBy의 컬럼리스트)

Multiple 집계함수
Select Gender, City, SUM(Salary) AS TotalSalary, COUNT(ID) as [Total Employees] FROM tblEmployee GROUP BY Gender, City

Group을 필터링 하는법
Select Gender, City, SUM(Salary) AS TotalSalary, COUNT(ID) as [Total Employees] 
FROM tblEmployee 
WHERE Gender = 'Male' <= 여기 where 를 쓰는법
GROUP BY Gender, City

Select Gender, City, SUM(Salary) AS TotalSalary, COUNT(ID) as [Total Employees] 
FROM tblEmployee 
GROUP BY Gender, City
Having Gender = 'Male' <= 여기 Having을 쓰는법

2개의 출력은 똑같다.
WHERE를 쓸때
Gender = 'Male'행만 가져와서 GROUP BY에 의해 aggregation된다.

Having을 쓸때
모든 행을 가져와서 aggregation된뒤 Gender = 'Male'된 그룹만 남는다.

퍼포먼스의 관점에서 봤을때 둘의 차이는 거의 없다. db의 최적화기가 알아서 최적화해서 가장 빠른 방법으로 실행한다.
하지만 query를 만들때 원하는 결과를 가장 클리어하게 표현하는 문장을 작성하라. 될수 있으면 필요없는 행들을 최대한 빠르게 제거하는 WHERE 문장을 써라.(가독성이 좋다는뜻)

WHERE와 HAVING의 차이점
1.WHERE는 Select, Insert, Update문장과 사용될수 있지만 Having은 Select와만 쓸수있다.
2.WHERE는 aggregation(GROUPING)이전에 행들을 필터링 하지만 HAVING은 aggregation이후 group을 필터링 한다.
3.Having절을 가진 sub query에 있지 않는 한 집계함수는 WHERE절에서 쓰일수없다.반면 Having절에서는 집계함수가 쓰일수 있다.

Select * From tblEmployee Where SUM(Salary) > 5000 <= 이거 안댐.

Select Gender, City, SUM(Salary) AS TotalSalary, COUNT(ID) as [Total Employees] 
FROM tblEmployee 
GROUP BY Gender, City
Having SUM(Salary) > 5000 <= 이건 댄다.

12강 Joins in sql server - Part 12
Join은 2개이상의 관계된 테이블들에서 data를 retrieve할때 쓰여진다. 일반적으로 테이블들은 FK constraint로 관계되어져 있다.
3가지의 Join type이 있다.
1.Inner Join
2.Outer Join
3.Cross Join
Outer Join은 다시 3가지로 나뉘어진다.
Left Join 또는 Left Outer Join
Right Join 또는 Right Outer Join
Full Join 또는 Full Outer Join


Inner Join
양쪽 테이블사이에 매칭되는 행들만 리턴! 매칭되지 않는 행들은 제거된다. (조건에 맞는 교집합들만 출력된다.)
Select Name, Gender, Salary, DepartmentName
From tblEmployee
INNER JOIN tblDepartment
On tblEmployee.DepartmentId = tblDepartment.Id

Select Name, Gender, Salary, DepartmentName
From tblEmployee
JOIN tblDepartment
On tblEmployee.DepartmentId = tblDepartment.Id

DepartmentId가 NULL인경우 Join된 테이블에는 나타나지 않는다.

Left Outer Join or Left Join
Left Join은 모든 매칭된 행들 + 왼쪽테이블의 매칭되지 않은 행들 (왼쪽 테이블에 있는 모든 행들이 출력된다.)
Select Name, Gender, Salary, DepartmentName
From tblEmployee
LEFT (OUTER) JOIN tblDepartment
On tblEmployee.DepartmentId = tblDepartment.Id

Right Outer Join or Right Join
Right Join은 모든 매칭된 행들 + 오른쪽 테이블의 매칭되지 않은 행들
Select Name, Gender, Salary, DepartmentName
From tblEmployee
RIGHT (OUTER) JOIN tblDepartment
On tblEmployee.DepartmentId = tblDepartment.Id

Full Outer Join or Full Join
Full Join은 모든 매칭된 행들 + 왼쪽, 오른쪽 테이블의 매칭되지 않은 행들 출력
Select Name, Gender, Salary, DepartmentName
From tblEmployee
FULL (OUTER) JOIN tblDepartment
On tblEmployee.DepartmentId = tblDepartment.Id

Cross Join
2테이블의 곱집합을 생성한다. Employees 10열, Department 4열이면 40열짜리 테이블 생성
On절이 없어야 한다.


Join문의 일반적 형태
Select ColumnList
From LeftTable
JoinType RightTable
On JoinCondition

Select Name, Gender, Salary, DepartmentName
From tblEmployee
FULL (OUTER) JOIN tblDepartment
On tblEmployee.DepartmentId = tblDepartment.Id

13강 Advanced or intelligent joins in sql server - Part 13
매칭되지 않은 행들만 뽑아내는 방법
12강의 basic join들은 전부 matching part + none matching part였다.

only none matching to left table
SELECT ColumnList
FROM tblEmployee E
LEFT JOIN tblDepartment D
ON E.DeptId = D.Id
WHERE D.Id is NULL <= left join시 ON에의해 걸리는행은 D.Id가 있고 없는 행은 D.Id가 전부 NULL일 것이다!

Select Name, Gender, Salary, DepartmentName
From tblEmployee
LEFT JOIN tblDepartment
On tblEmployee.DepartmentId = tblDepartment.Id
Where tblEmployee.DepartmentId IS NULL

only none matching to right table
SELECT ColumnList
FROM tblEmployee E
RIGHT JOIN tblDepartment D
ON E.DeptId = D.Id
WHERE E.DeptId is NULL

Select Name, Gender, Salary, DepartmentName
From tblEmployee
RIGHT JOIN tblDepartment
On tblEmployee.DepartmentId = tblDepartment.Id
Where tblEmployee.DepartmentId IS NULL

only none matching to both table
SELECT ColumnList
FROM tblEmployee E
FULL JOIN tblDepartment D
ON E.DeptId = D.Id
WHERE E.DeptId IS NULL OR D.Id IS NULL

NULL 을 비교할때 = 를 절대로 쓰지 말것! NULL은 = 로 비교할수 없다.

14강 Self join in sql server - Part 14
자기 자신과의 Join이 필요한 경우가 있다.

EmployeesID Name ManagerID
1 Mike  3
2 Rob   1
3 Todd  NULL
4 Ben   1
5 Sam   1

위과 같은 테이블이 있을때
Employee Manager
Mike    Todd
Rob     Mike
Todd    NULL
Ben     Mike
Sam     Mike

와 같은 테이블을 뽑아내려 할때이다.

SELECT E.Name AS Employee, M.Name AS Manager
FROM tblEmployee E
LEFT JOIN tblEmployee M
On E.ManagerId = M.EmployeesId

자기 자신의 테이블과 Join하는 것을 Self Join이라한다.
Self Join은 Join의 새로운 타입이 아니다.

15강 Different ways to replace NULL in sql server - Part 15
NULL을 대체하는 3가지 방법
1. ISNULL() Function
2. CASE Statement
3. COALESCE() Function


SELECT E.Name AS Employee, M.Name AS Manager
FROM tblEmployee E
LEFT JOIN tblEmployee M
On E.ManagerId = M.EmployeesId

Employee Manager
Mike    Todd
Rob     Mike
Todd    NULL
Ben     Mike
Sam     Mike

Todd NULL을 No Manager로 바꾸어 출력하는 방법
ISNULL(expression, replacement_value)  => expression이 NULL을 리턴하면 replacement_value를 대신 쓴다.

Seclec ISNULL(NULL, 'No Manager') as Manager
  Manager
1 No Manager

Seclec ISNULL('PRAGIM', 'No Manager') as Manager
  Manager
1 PRAGIM

SELECT E.Name AS Employee, ISNULL(M.Name, 'No Manager') AS Manager
FROM tblEmployee E
LEFT JOIN tblEmployee M
On E.ManagerId = M.EmployeesId

COALESCE() Function을 쓸수도 있다.
COALESCE() Function => 다음에 자세히 설명, 대충 설명하면 첫 non Null value를 리턴한다. ISNULL() 보다 강력하다.
ISNULL()과 사용법이 비슷하다는 것으로 일단 이해하자
Select COALESCE(NULL, 'No Manager') as Manager

CASE문
CASE WHEN expression THEN '' ELSE '' END
SELECT E.Name AS Employee, CASE WHEN M.Name IS NULL THEN 'No Manager' ELSE M.Name END AS Manager


16강 COALESCE function in sql server Part 16
COALESCE() Function - Returns the first NON NULL Value

id  FirstName MiddleName  LastName
1 Sam NULL NULL
2 NULL Todd Tanzan

SELECT Id, COALESCE(FirstName, MiddleName, LastName) as Name
FROM tblEmployee

id Name
1 Sam
2 Todd


17강 Union and union all in sql server Part 17
UNION과 UNION ALL 오퍼레이터는 2개 이상의 Select query의 결과 셋을 합치는데 쓰인다.

SELECT Id, Name, Email FROM tblIndiaCustomers
UNION ALL
SELECT Id, Name, Email FROM tblUKCustomers

UNION이 동작하기 위해서는 컬럼의 갯수와 타입, 순서들이 일치해야한다.

UNION과 UNION ALL의 차이
1.UNION은 중복을 레코드를 제거하며 소트된 형태로 나타난다. UNION ALL은 그냥 갖다 붙인 것처럼 결과가 나타난다.
2.UNION은 중복 제거를 위해 distinct sort를 수행해야만하고 이는 UNION ALL 보다 느리게 만드는 원인이 된다. <= 자주 묻는 인터뷰 질문

UNION query를 입력한뒤 Estimated query execution plan(CTRL + L, 혹은 아이콘 클릭)하면 distinct sort가 나타남을 볼수있으며 대부분의 시간을 여기서
소비한다.

UNION, UNION ALL의 결과 sort
ORDER BY 절은 반드시 마지막 SELECT문에만 쓰일수 있다.
SELECT * FROM tblIndiaCustomers
UNION ALL
SELECT * FROM tblUKCustomers
Order By Name

UNION과 JOIN의 차이
UNION은 2개이상의 select문의 결과셋의 모든 행들을 포함하는 한개의 결과셋으로 합친다.
반면 JOIN은 2개 이상의 테이블로부터 테이블들 간의 논리적 관계에 기초하여 data를 뽑아낸다.
요약하면 UNION은 2개이상의 테이블로 부터 행들을 합치며, JOIN은 2개이상의 테이블로부터 컬럼을 합친다.

18강 Stored procedures in sql server Part 18
Stored procedure는 T-SQL(Transact SQL)문의 그룹이다. 만약 같은 query를 계속 써야 하는 상황이라면 특정query를 stored procedure로 저장해놓고
호출하여 사용할수 있다.

생성 문법
CREATE PROCEDURE spGetEmployee <= 이름에 sp를 붙인다. sp_는 쓰지 말것! 모든 system stored procedure가 sp_를 사용한다!
AS
BEGIN
  Select Name, Gender From tblEmployee
END
위 문장을 실행 시키면 Programmability > Stored Procedures 밑에 주어진 이름으로 저장된다.

실행하는 방법
spGetEmployee
EXEC spGetEmployee
Execute spGetEmployee
GUI상에서는 sp화일 context menu에서 execute stored procedure를 선택.

파라메터를 갖는 Stored procedure
파라메터들과 변수들은 @을 접두어로 갖는다.

CREATE PROC spGetEmployeesByGenderAndDepartment
@Gender nvarchar(20),  <= 파라메터 선언들
@DepartmentId int
AS
BEGIN
  Select Name, Gender From tblEmployee Where Gender = @Gender and DepartmentId = @DepartmentId
END

Execute spGetEmployee 'Male', 1 
Execute spGetEmployee 1,'Male' <= 이름을 주지 않으면 순서대로 묵시적 변환한다. 'Male'을 @DepartmentId int로 변환 불가능해서 에러난다.
Execute spGetEmployee @DepartmentId=1, @Gender='Male' <=이름을 주면 파라메터 순서에 상관이 없다.

stored procedure의 소스를 보고 싶으면
1. stored procedure화일 context menu > Script Stored Procedure as > CREATE To > New Query Editor Window 선택하면 소스를 볼 수 있다.
2. sp_helptext라는 system stored procedure를 사용
sp_helptext spGetEmployee 하면 텍스트가 나온다.


이미 spGetEmployee sp가 있을때 수정하는 방법
ALTER PROCEDURE spGetEmployee
AS
BEGIN
  Select Name, Gender From tblEmployee
  Order by Name
END

sp지우기
DROP PROCEDURE spGetEmpolyee

sp를 Encryption하게 되면 sp의 소스를 볼수 없게 한다.
ALTER PROCEDURE spGetEmployee
WITH Encryption
AS
BEGIN
  Select Name, Gender From tblEmployee
  Order by Name
END

19강 Stored procedures with output parameters Part 19
OUTPUT 파라메터를 가진 SP 를 생성하려면 OUTPUT(OUT)키워드를 사용한다.
CREATE PROC spGetEmployeeCountByGender
  @Gender nvarchar(20),
  @EmployeeCount int OUTPUT <= 여기!
AS
BEGIN
  --Select COUNT(*) from tblEmployee where Gender = @Gender
  Select @EmployeeCount = COUNT(Id)
  From tblEmployee
  Where Gender = @Gender
END

OUTPUT을 가진 sp를 실행시키기
Output을 어딘가에 저장해놔야 한다! 변수를 선언하자

DECLARE @EmployeeTotal int
Execute spGetEmployeeCountByGender 'Male', @EmployeeTotal OUTPUT  <= 순서대로 파라메터 패스하는경우
PRINT @EmployeeTotal

DECLARE @EmployeeTotal int
Execute spGetEmployeeCountByGender @EmployeeCount = @EmployeeTotal OUT, @Gender = 'Male'  <= 파라메터 이름을 줘서 호출하는 경우
PRINT @EmployeeTotal

실행시킬때 OUTPUT을 빼먹으면 결과는 NULL이 된다. NULL은 PRINT하면 아무것도 안찍힌다.
if(@TotalCount is null)
  Print '@TotalCount is null'
else
  Print '@TotalCount is not null'


몇가지 쓸만한 System SP
sp_help procedure_name : sp의 정보를 본다. 파라메터 이름, 타입등. sp뿐만 아니라 모든 database object에 적용할수 있다. table, sp, trigger등
정보를 보고 싶은 객체이름을 마우스로 하이라이트 하고 ALT+F1으로도 똑같은 명령을 할수있다.
sp_helptext procedure_name : sp의 text를 보여준다. 소스보기
sp_depends procedure_name : sp의 디펜던시들을 보여준다. sp뿐만이 아니라 다른 database object에도 적용 할수 있다.

만약 tblEmployee를 drop 하고 싶을때 sp들이 이 테이블에 의존하는지 확인 가능하다.
sp_depends tblEmployee <= 이 테이블에 디펜던시가 있는 sp들을 보여준다.


20강 Stored procedure output parameters or return values Part 20
sp를 실행할때마다 int를 status로 리턴한다. 0이외의 다른 값은 실패이다.

--output
Create Proc spGetTotalCount1
@TotalCount int Out
AS
Begin
  Select @TotalCount = COUNT(Id) from tblEmployee
End

Declare @Total int
Execute spGetTotalCount1 @Total Output
Select @Total

--return
Create Proc spGetTotalCount2
AS
Begin
  return (Select COUNT(Id) from tblEmployee)
End

Declare @Total int
Execute @Total = spGetTotalCount2
Select @Total

위의 2가지 예제를 보면 두 방법 모두 우리가 원하는 것을 할수 있다.
하지만 return이 할수 없는 예를 살펴보자

--output을 썼을 경우
Create Proc spGetNameById1
@Id int
@Name nvarchar(20) output
as
Begin
  Select @Name = Name from tblEmployee Where Id = @Id
End

Declare @Name nvarchar(20)
Execute spGetNameById1 1, @Name Out
Print 'Name = ' + @Name


--return을 썼을 경우
Create Proc spGetNameById2
@Id int
as
Begin
  Return (Select Name from tblEmployee Where Id = @Id)
End

Declare @Name nvarchar(20)
Execute @Name = spGetNameById1 1
Print 'Name = ' + @Name

실행하면 return을 썼을 경우는 에러가 난다. 왜냐하면 리턴값이 int가 아니기때문이다. 'Sam'을 int로 변환하다가 에러 발생.

Return Status Value
1. int만 된다.
2. 1개의 값만 리턴한다.
3. 성공 혹은 실패를 검사하기 위해 쓰인다.

Output parameters
1. any datatype
2. 몇개든 가능
3. 값을 return 하는 데 쓰인다.


21강 Advantages of stored procedures
1. Execution plan retention and reusability
sql query를 받으면 db는 3가지를 한다. query의 syntax 검사, query의 compile, query의 Execution plan 생성
Execution plan : query에 대응 하는 data를 뽑아주기 위해 가장 좋은 방법이 무엇인가?에대한 계획. 사용 가능한 index들과 같은 요소들에 기초하여
Execution plan을 생성해낸다.
sp를 쓰면 Execution Plan을 재활용 할 수 있다.

요사이에는 adhoc sql(inline query)들도 Execution plan을 캐시하고 저장하지만 조그마한 query의 수정이 Execution plan의 재활용을 방해한다.

Select Name from tblEmployee Where Id = 1 => 이 query를 계속 쓴다면 재활용을 한다.
Select Name from tblEmployee Where Id = 2 => 하지만 2로만 바꿔도 재활용이 불가능하다.
Select Name from tblEmployee Where   Id = 1 => 공백만 들어가도 재활용 불가

sp에서는 Execution plan을 계속 재활용한다.

2. 네트워크 트래픽을 줄인다.
sql문이 3천라인일 경우 sp로 만들어 놓으면? 당근 네트워크 트래픽이 준다. execute sp이름 parameter만 트래픽을 쓰므로.

3. 코드 재사용성과 나은 유지보수성
다른 application들도 같은 sp를 쓸수있다. 여러 application에서 sql을 따로 쓴다면 수정이 있을때 모든 application을 수정해야한다.

4. 더 나은 보안
만약 Employee Table에서 HR, IT등 부서별로 섞여있을때 보안의 측면에서 다른 부서의 것들을 못보게 하고 싶다.
query형태로 table에 접근한다면 이러한 것들을 제한 할수 없다. 위의 기능은 sp가 아닌 view로도 할수 있지만 sp도 할수있다.

5. SQL Injection Attack을 피할수 있다. <= asp.net의 주요한 인터뷰 질문!
https://www.youtube.com/watch?v=uSw0IoSr3Hk
매우 일반적인 web application 해킹 방법이다.
무엇이 SQL Injection을 일으키는가?
문자열들을 concat하여 SQL문을 만들때 SQL Injection을 발생시킬수 있다.
회피책 2가지
1. Parameterized Query사용
2. Stored Procedure사용

예제
GetAllProduct()라는 버튼
GetProductByName()이라는 버튼과 상품명을 넣는 textbox가 UI에 있다고 하자.

asp server에서 AllProduct 버튼을 눌렀을대 다음과 같이 처리한다
void btnGetAllProducts_Click(object sender, EventArgs e)
{
  string CS =...
  SqlConnection con = new SqlConnection(CS);
  SqlCommand cmd = new sqlCommand("Select * from tblProduct", com);
  con.Open();
  GridView1.DataSource= cmd.ExecuteReader();
  ...
  con.Close();
}


asp server에서 ProductByName 버튼을 눌렀을때 다음과 같이 처리한다
void btnGetProductByName_Click(object sender, EventArgs e)
{
  string CS =...
  SqlConnection con = new SqlConnection(CS);
  SqlCommand cmd = new sqlCommand("Select * from tblProduct where Name='" + TextBox1.Text + "'", com); <= 문자열들을 concat하여 SQL문을 만들고 있다.
  con.Open();
  GridView1.DataSource= cmd.ExecuteReader();
  ...
  con.Close();
}

"Select * from tblProduct where Name='" + TextBox1.Text + "'" 이곳이 문제 발생의 원인이다. TextBox2.Text는 유저가 입력한 텍스트 이다.
만약 값이 Book, Apple등 정상적인 입력이라면 동작하는데 문제가 없지만 sql문이라면? 상황이 심각해진다.

TextBox1.Text 이 "Book'; Delete from tblProduct --"라면?
Select * from tblProduct where Name='Book'; Delete from tblProduct --' => 2개의 sql문이 실행되며 tblProduct테이블의 내용은 지워진다.
위의 코드는 그나마 관대했다. 만약 drop database였다면? ;;

위의 해킹이 발생하는 이유는? 유저가 입력한 스트링을 concat하는데 사용하여 동적으로 sql문을 만들었기때문이다.

1.Parameterized Query 사용
SqlCommand cmd = new sqlCommand("Select * from tblProduct where Name=@Name", com);
cmd.Parameters.Add(new SqlParameter("@Name", TextBox1.Text)); <= TextBox1.Text에 그 무엇을 유저가 넣더라도 완전히 Name의 값으로만 취급되어진다.
con.Open();

2.Stored Procedure사용


22강 Built in string functions in sql server 2008 Part 22
함수는 system function과 user-defined function으로 나뉜다.
모든 system function들을 보려면
Programmability > system functions 안에 카테고리 별로 나뉘어져 있다.

ASCII(Character_Expression) => 아스키 코드 리턴
CHAR(Ineger_Expression) => 아스키 코드의 문자 리턴
LTRIM(Character_Expression), RTRIM(Character_Expression) => 좌, 우 공백 문자 삭제
LOWER(Character_Expression), UPPER(Character_Expression) => 대, 소문자 변환
REVERSE('Any_String_Expression') => 순서 바꾸기
LEN(String_Expression) => 문자열의 문자수, 마지막에 있는 공백문자들은 제외(앞의 공백문자들은 포함)

Select ASCII('A') => 65
Select ASCII('ABC') => 65

--A-Z 출력
Declare @Start int 
Set @Start = 65
While(@Start <= 90)
Begin
  --Select CHAR(@Start)
  Print CHAR(@Start)
  Set @Start = @Start + 1
End

Select FristName as FirstName, MiddleName, LastName, RTRIM(LTRIM(FirstName)) + ' ' + MiddleName + ' ' + LastName as FullName From tblEmployee

Select FirstName, LEN(FIRSTNAME) as [Total Characters] from tblEmployee

23강 LEFT, RIGHT, CHARINDEX and SUBSTRING functions in sql server Part 23
LEFT(Character_Expression, Integer_Expression), RIGHT(Character_Expression, Ineger_Expression) => 왼쪽으로부터 int만큼의 문자를 가져온다.
CHARINDEX('Expression_To_Find', 'Expression_To_Search', 'Start_Location') Start_Location:optional
SUBSTRING('Expression', 'Start', 'Length')


'ABCDEF'
Select LEFT('ABCDEF', 3) => ABC
Select RIGHT('ABCDEF', 3) => DEF
Select CHARINDEX('@', 'sara@aaa.com', 1) => 5
Select SUBSTRING('sara@aaa.com', 6, 7) => aaa.com


Select SUBSTRING('sara@aaa.com', CHARINDEX('@', 'sara@aaa.com') + 1, 
LEN('sara@aaa.com') - CHARINDEX('@', 'sara@aaa.com')) => aaa.com

Select SUBSTRING(Email, CHARINDEX('@', Email) + 1, 
LEN(Email) - CHARINDEX('@', Email)) as EmailDomain,
COUNT(Email) as Total
From tblEmployee
Group by
SUBSTRING(Email, CHARINDEX('@', Email) + 1, 
LEN(Email) - CHARINDEX('@', Email))

EmailDomain Total
aaa.com     4
bbb.com     2
ccc.com     6


24강 Replicate, Space, Patindex, Replace and Stuff string functions in sql server 2008 Part 24
REPLICATE(String_To_Be_Replicated, Number_Of_Times_To_Replicate) => 주어진 횟수만큼 스트링 반복
SPACE(Number_Of_Spaces)
PATINDEX('%Pattern%', Expression) => Expression에서 Pattern이 처음 있는 시작 인덱스 리턴. CHARINDEX()와 비슷하지만 와일드카드를 쓸수있다.
패턴이 밸견되지 않으면 0 리턴.
REPLACE(String_Expression, Pattern, Replacement_Value) => 발견된 모든 Pattern의 문자열을 치환한다.
STUFF(Orignal_Expression, Start, Length, Replacement_Value) => Start 인덱스 위치에 Replacement_Value를 insert하고 Length만큼 문자를 지운다.

REPLICATE('Pragim ', 3) => Pragim Pragim Pragim 
email을 5개의 *로 마스킹 하는 query
Select FirstName, LastName
       SUBSTRING(Email, 1, 2) + REPLICATE('*', 5) +
       SUBSTRING(Email, CHARINDEX('@', Email), LEN(Email) - CHARINDEX('@', Email) + 1) as Email
From tblEmployee


Select '    ' 보다 Select SPACE(5)가 가독성이 좋다.

Select Email, PATINDEX('%@aaa.com', Email) as FirstOccurence
From tblEmployee
Where PATINDEX('%@aaa.com', Email) > 0


.com을 .net으로 바꾸기
Select Email, REPLACE(Email, '.com', '.net') as ConvertedEmail
From tblEmployee

STUFF('Sam@aaa.com', 2, 3, '*****') => S*****aaa.com
STUFF('Sara@ccc.com', 2, 3, '*****') => S*****@ccc.com


25강 DateTime functions in SQL Server Part 25
time  hh:mm:ss[.nnnnnnn]
date  YYYY-MM-DD
smalldatetime YYYY-MM-DD hh:mm:ss
dateTime  YYYY-MM-DD hh:mm:ss[.nnn]
datetime2 YYYY-MM-DD hh:mm:ss[.nnnnnnn]
datetimeoffset  YYYY-MM-DD hh:mm:ss[.nnnnnnn][+|-]hh:mm =>[+|-]hh:mm 이부분을 timezone offset이라 부른다. (in UTC)
윈도우 시계등의 timezone 설정을 보면  UTC+02:00 이런식으로 쓰여있다. UTC가 12시일때 독일은 +1시간 하면 된다.

UTC : Coordinated Universal Time(정치적인 이유로 CUT가 아니라 UTC가 되었음..)
UTC는 세계가 시간을 조절하는 기준 시간이다. GMT와 UTC 사이에는 약간의 차이점이 있지만 대부분의 일반적인경우 동의어로 쓰인다.
GETDATE() 2012-08-31 20:15:04.543                           일반적으로 쓰인다.
CURRENT_TIMESTAMP 2012-08-31 20:15:04.543                   ANSI SQL equivalent to GETDATE
SYSDATETIME() 2012-08-31 20:15:04.5380028                   좀더 많은 초의 precision(정밀도) datetime2
SYSDATETIMEOFFSET() 2012-08-31 20:15:04.5380028 + 01:00     좀더 많은 초의 precision + time zone offset
GEUTCDATE() 2012-08-31 19:15:04.543                         UTC Date and Time (GETDATE()보다 1시간 적다!)
SYSUTCDATETIME() 2012-08-31 19:15:04.5380028                좀더 많은 초의 해상도를 포함한 UTC Date and Time


26강 IsDate, Day, Month, Year and DateName DateTime functions in SQL Server Part 26
ISDATE() 주어진 값이 정확한 date, time, date인지 체크한다. 1:성공, 0:실패. datetime2에대해 ISDATE()는 0리턴.
DAY(), MONTH(), YEAR()
DATENAME()


Select ISDATE(Getdate()) => 1
Select ISDATE('2012-08-31 20:15:04.543') => 1
Select ISDATE('2012-08-31 20:15:04.5380028 ') => 0 datetime2타입은 0이다! 위의 SYS붙은 함수들의 DATE는 전부 0

Select YEAR('01/31/2012') => 2012

Select DATENAME(WEEKDAY, '2012-09-30 20:15:04.543') => Sunday
Select DATENAME(MONTH, '2012-09-30 20:15:04.543') => September
datepart에 들어 갈수 있는 값들이 많다.
year, quarter, month, dayofyear, day, week, weekday, hour, minute, second, millisecond, microsecond, nanosecond, TZoffset

27강 DatePart, DateAdd and DateDiff functions in SQL Server Part 27
DATEPART(datepart, Date) => DATENAME()과 같지만 문자열대신 int리턴 (이름 그대로 DATE의 부분을 가져온다)
DATEADD(datepart, NumberToAdd, date) => DateTime을 리턴
DATEDIFF(datepart, startdate, enddate)

Select DATENAME(WEEKDAY, '2012-08-30 20:15:04.543') => Thursday
Select DATEPART(WEEKDAY, '2012-08-30 20:15:04.543') => 5

Select DATEADD(DAY, 20, '2012-08-30 20:15:04.543') => 주어진 datetime에 20일을 더해라
Select DATEADD(DAY, -20, '2012-08-30 20:15:04.543') => 주어진 datetime에 20일을 빼라

Select DATEDIFF(MONTH, '11/30/2005', '01/31/2006') => 2
Select DATEDIFF(DAY, '11/30/2005', '01/31/2006') => 62


조건에 따라서 값을 지정해 주는 CASE문에 대해서 알아보겠습니다~ 
CASE 문의 형식은  

CASE 컬럼
WHEN 조건1 THEN 값1 
WHEN 조건2 THEN 값2 
ELSE 값3 
END 

입니다. 컬럼이 조건1 일때는 값1 을 조건2일때는 값2를 반환하고 조건에 맞지 않는 경우에는 값3 을 반환하는것입니다. 
SELECT *,
   (CASE WHEN SCORE>= '90' THEN 'A학점'
        WHEN (SCORE>= '80' AND SCORE < '90') THEN 'B학점'
        WHEN (SCORE>= '70' AND SCORE < '80') THEN 'C학점' 
        WHEN (SCORE>= '60' AND SCORE < '70') THEN 'D학점'
        ELSE 'F학점'
    END) AS '학점'
FROM MY_TABLE


DECLARE @DOB datetime, @tempdate datetime, @years int, @months int, @days int
SET @DOB = '10/08/1982'
SELECT @tempdate = @DOB
SELECT @years = DATEDIFF(YEAR, @tempdate, GetDATE()) -
                CASE
                  WHEN (MONTH(@DOB) > MONTH(GETDATE())) OR (MONTH(@DOB) = MONTH(GETDATE()) AND DAY(@DOB) > DAY(GETDATE()))
                  THEN 1 ELSE 0
                END

SELECT @tempdate = DATEADD(YEAR, @years, @tempdate)
SELECT @Months = DATEDIFF(MONTH, @tempdate, GETDATE()) -
                 CASE
                  WHEN DAY(@DOB) > DAY(GETDATE())
                  THEN 1 ELSE 0
                 END
SELECT @tempdate = DATEADD(MONTH, @months, @tempdate)
SELECT @days = DATEDIFF(DAY, @tempdate, GETDATE())
SELECT @years as Years, @months as Months, @days as [Days]

함수로 바꾸어 보자(나중에 함수에대해 디테일하게 다루자)
CREATE FUNCTION fnComputeAge(@DOB DateTime)
returns nvarchar(50)
AS
BEGIN
DECLARE @DOB datetime, @tempdate datetime, @years int, @months int, @days int
SELECT @tempdate = @DOB
SELECT @years = DATEDIFF(YEAR, @tempdate, GetDATE()) -
                CASE
                  WHEN (MONTH(@DOB) > MONTH(GETDATE())) OR (MONTH(@DOB) = MONTH(GETDATE()) AND DAY(@DOB) > DAY(GETDATE()))
                  THEN 1 ELSE 0
                END

SELECT @tempdate = DATEADD(YEAR, @years, @tempdate)
SELECT @Months = DATEDIFF(MONTH, @tempdate, GETDATE()) -
                 CASE
                  WHEN DAY(@DOB) > DAY(GETDATE())
                  THEN 1 ELSE 0
                 END
SELECT @tempdate = DATEADD(MONTH, @months, @tempdate)
SELECT @days = DATEDIFF(DAY, @tempdate, GETDATE())\

DECLARE @Age nvarchar(50)
SET @Age = Cast(@years as nvarchar(4)) + ' Years ' + Cast(@monthsas as nvarchar(2)) + ' Months ' + Cast(@days as as nvarchar(4)) + ' Days Old'
return @Age
END

호출
Select dbo.fnComputeAge('11/30/2005')

28강 Cast and Convert functions in SQL Server Part 28
어떤 데이타 타입에서 다른 데이타 타입으로 변환할때 CAST()와 CONVERT() 함수가 쓰여진다.
차이점 CONVERT()는 style파라메터를 가지고 있다. 
CAST(expression AS data_type[(length)]) => []안의 내용은 optional
CONVERT(data_type [(length)], expression [, style])

--같은 문장
Select Id, Name, DateOfBirth, CAST(DateOfBirth as nvarchar) as ConvertedDOB from tblEmployees
Select Id, Name, DateOfBirth, CAST(DateOfBirth as nvarchar(20)) as ConvertedDOB from tblEmployees <= optional

Select Id, Name, DateOfBirth, CONVERT(nvarchar, DateOfBirth) as ConvertedDOB from tblEmployees
Select Id, Name, DateOfBirth, CONVERT(nvarchar, DateOfBirth, 103) as ConvertedDOB from tblEmployees <= style
style
101 mm/dd/yyyy
102 yy.mm.dd
103 dd/mm/uuuu
104 dd.mm.yy
105 dd-mm.yy

DateTime으로부터 date부분만 가져오기
SELECT CONVERT(VARCHAR(10), GETDATE(), 101) -> 09/02/2012
SQL Server 2008부터 Date data type이 만들어졌다. 따라서 다음과 같이 쓸수 있다.
SELECT CAST(GETDATE() as DATE) -- 2012-09-02
SECECT CONVERT(DATE, GETDATE()) -- 2012-09-02
주의: 날짜파트의 포매팅을 컨트롤 하려면 datetime은 스타일이 있는 상태로 nvarchar형으로 변환되어져야한다.
하지만 DATE 데이타타입으로 변환할때는 CONVERT()함수는 style파라메터를 무시한다.

Id(int)와 Name(nvarchar)를 concat할때
Select Name + ' - ' + CASE(Id AS NVARCHAR) AS [Name-Id] From tblEmployees

RegistrationDate별 몇명이나 가입했나?
Select    RegistredDate, COUNT(Id) as Total
From      tblRegistrations
Group By  RegistredDate

datetime은 시간이 있기때문에 제대로 Group By 가 안된다.

Select    CAST(RegistredDate as DATE) as Registration, COUNT(Id) as Total
From      tblRegistrations
Group By  CAST(RegistredDate as DATE)

CAST-CONVERT 차이점
1. CAST는 표준이며 CONVERT는 SQL Server 전용이다. 이식성이 중요하다면 CAST를 사용하라
2. CONVERT는 CAST보다 유연하다. DateTime 데이타타입을 스타일을 사용해서 변환 할수 있다.
style을 이용하고 싶지 않다면 일반적으로 CAST()를 쓸것.
 

29강 Mathematical functions in sql server Part 29
Programmability > system functions > Mathematical Functions안에 모든 함수 정의가 있다.
ABS()
CEILING(), FLOOR()
POWER(), SQUARE(), SQRT()

CEILING(15.2) -- 16
CEILING(-15.2) -- -15 (-15.2보다 높은 값을 리턴하기때문에 -15임)

FLOOR(15.2) -- 15
FLOOR(-15.2) -- -16 (-15.2보다 낮은 값을 리턴하기때문에 -16임)


RAND([Seed_Value]) 0-1사이의 float 반환

Declare @Counter INT
Set @Counter = 1
While(@Counter <= 10)
Begin
  Print FLOOR(RAND() * 100)
  Set @Counter = @Counter + 1
End

ROUND(numberic-expression, length[,function]) => function이 0이면 ROUND로 동작(default), 0이 아니면 truncate로 동작
length: 출력할 자리수, 양수이면 소수점 자리 음수이면 정수자리
ROUND(850.556, 2) --850.560 소수점 2째자리까지 출력이므로 3째자리에서 반올림.
ROUND(850.556, 2, 1) --850.550 소수점 2째자리까지 출력이고 function이 0이 아니므로 3자리부터 truncate
ROUND(850.556, -2) --900.000 소수점을 기준으로 왼쪽으로 2번째 자리부터 남겨라! 왼쪽 2번째 자리 5를 반올림해서 왼쪽 3번째 자리가 9가 된다.


30강 Scalar user defined functions
user defined functions : UDF
SQL 서버에는 3가지 타입의 user defined functions이 있다.
1. Scalar function
2. inline table-valued function
3. Multi-statement table-valued function

Scalar function은 파라메터가 0개 이상이고, 항상 (scalar)값 하나를 리턴해야한다.
text, ntext, image, cursor, timestamp를 제외한 어떠한 데이타 타입도 리턴 가능하다.

문법
CREATE FUNCTION Function_Name(@Paramemter1 DataType, @Paramemter2 DataType, ... @ParamemterN DataType,)
RETURNS Return_Datatype
AS
BEGIN
  --Function Body
  Return Return_Datatype
END

위의 문법으로 함수를 생성하면 
Programmability > Function > Scalar-valued functions안에 dbo.Function_Name으로 함수가 생긴다.

함수의 fully qualified name은 Database_Name.dbo.Function_Name이다.
scalar UDF를 호출하려면 최소한 2-part name을 써야한다. OwnerName.FunctionName(dbo: database owner의 약자)
Select dbo.Function_Name() <= 최소한 dbo를 붙여줘야 된다.

//scalar UDF 은 Select절에 쓰일수있다.
Select Name, DateOfBirth, dbo.Age(DateOfBirth) as Age from tblEmployees
//scalar UDF 은 Select Where절에 쓰일수있다.
Select Name, DateOfBirth, dbo.Age(DateOfBirth) as Age from tblEmployees
Where dob.Age(DateOfBirth) > 30

SP 또한 DateOfBirth를 받아 Age를 리턴할수 있다. 그러나 SP는 Select또는 Where절에서 쓰여질수 없다. 함수와 SP의 한가지 다른점이다.

수정 및 Drop
ALTER FUNCTION
DROP FUNCTION 



31강 Inline table valued functions
Scalar Function : returns A single Scalar value
Inline table valued function : returns A table

CREATE FUNCTION fnEmployeesByGender(@Gender nvarchar(10))
RETURNS TABLE
AS
RETURN (
  SELECT Id, Name DateOfBirth, Gender, DepartmentId
  FROM tblEmployees
  WHERE Gender = @Gender
)

1.return type으로 TABLE을 쓴다.
2.함수 바디를 BEGIN END 블록으로 감싸지 않는다.
3.리턴되는 테이블의 구조는 함수안에있는 SELECT문으로 결정된다.

Programmability > Function > Table-valued Functions 안에 함수가 저장된다.

Inline table valued functions을 어디에 쓰는가?
1. parameterized views의 기능을 달성하기 위해 쓰여질수있다.(나중에 논의))
2. table valued function에의해 리턴된 테이블은 다른 테이블들과 조인하는데 쓰여질수도 있다.

함수 호출하기
Select * from fnEmployeesByGender('Male') <= 테이블로서 취급된다.

Select Name, Gender, DepartmentName
From fnEmployeesByGender('Male') E
Join tblDepartment D ON D.Id = E.DepartmentId


32강 Multi statement table valued functions
 Multi statement table valued function은 inline table valued function과 거의 비슷하다.

inline table valued function
Create Function fn_ILTVF_GetEmployees()
Returns Table <= Table 키워드만 있다. 테이블의 구조는 적혀 있지 않다.
as <= Begin End절이 없다.
Return (Select Id, Name, Cast(DateOfBirth as Date) as DOB From tblEmployees) 

Multi statement table valued function
Create Function fn_MSTVF_GetEmployees()
Returns @Table Table (Id int, Name nvarchar(20), DOB Date) <= @Table이라는 변수를 리턴한다. @Table 변수의 타입은 Table이며 
이러한 Table변수선언에는 컬럼의 구조와 타입이 나와야한다.
as
Begin <= Begin End 블럭에 함수 바디를 넣는다.
  Insert into @Table
  Select Id, Name, Cast(DateOfBirth as Date) From tblEmployees

  Return
End


차이점
1.inline table valued function은 Returns에 테이블 구조를 명시하지 않고 테이블은 Return에 있는 Select문에의해 결정된다.
반면에 Multi statement table valued function은 Returns에 테이블 구조를 명시한다.
2.inline table valued function은 Begin End블럭을 가질수 없으며 Multi statement table valued function은 Begin End 블럭을 가질수있다.
3.inline table valued function이 퍼포먼스적으로 낫다. 같은 결과를 inline, Multi로 만들수 있다면 항상 inline table valued function을 선호해야한다.
=> 이유: 내부적으로 SQL Server는 inline table valued function을 View처럼 다루지만 Multi statement table valued function은 Stored procedure와 비슷하게 다룬다.
4.inline table valued function으로 반환된 테이블을 통해 기저테이블을 Update할수 있지만 Multi statement table valued function으로 반환된 테이블을 통해
기저테이블을 Upate하는 것이 불가능하다.

Select * from dbo.fn_ILTVF_GetEmployees();
Update fn_ILTVF_GetEmployees() set Name = 'Sam' Where Id = 1
원본 tblEmployees의 Id=1의 Name이 Sam으로 Update된다.

Update fn_MSTVF_GetEmployees() set Name = 'Sam' Where Id = 1
고칠수 없다고 에러메세지 출력 Can not modified

Multi statement table valued function은 tblEmployees로 부터 오지만 새로운 table에 insert되고 있다. 이는 중간 처리 과정이 필요하는 것이며
Multi statement table valued function를 통해 원본 tblEmployees를 수정 불가능한것은 이해된다.


33강 Important concepts related to functions
Deterministic functions : 명시된 input의 집합과 주어진 데이타베이스의 상태가 같을경우 언제든지 호출되었을때 같은 결과를 리턴하는 함수.
Ex) SQUARE(), Power(), Sum(), Avg(), Count()
모든 Aggregate 함수는 Deterministic function이다.

Select Power(3) <= 인풋이 같으므로 항상 같은 값을 리턴한다.
Select Count(*) from tblEmployees <= Count(*)는 모든 레코드의 숫자를 리턴, tblEmployees에 insert, delete하지 않는한(데이타베이스의 상태가 바뀌지 않는한) 같은 값을 리턴

Nondeterministic function
명시된 input의 집합과 주어진 데이타베이스의 상태가 같지 않더라도 호출될때마다 리턴값이 달리질수 있는 함수.
Ex) GetDate(), CURRENT_TIMESTAMP


Rand()함수는 Seed가 주어지지 않았을때 Nondeterministic function, Seed가 주어지면 Deterministic function이다.
Rand() : 호출시 마다 다르다.
Rand(1) : 호출시 마다 같다.

WITH ENCRYPTION 옵션
Alter Function fn_ILTVF_GetEmployees()
Returns Table
WITH ENCRYPTION  <= SP와 같다. sp_helptext로 함수 내용을 볼수 없다.
as
Return (Select Id, Name, Cast(DateOfBirth as Date) as DOB From tblEmployees)

WITH SCHEMABINDING 옵션
Alter Function fn_GetEmployees(Id int)
Returns nvarchar(30)
as
Begin
  Return (Select Name From tblEmployees Where Id=@Id)
End

fn_GetEmployees()함수는 tblEmployees테이블의 Name, Id컬럼을 사용한다.
다른 누군가 이를 모르고 drop table tblEmployees를 해버린다면 위의 함수 실행시 에러를 일으킨다.

Alter Function fn_GetEmployees(Id int)
Returns nvarchar(30)
WITH SCHEMABINDING <= 추가...
as
Begin
  Return (Select Name From tblEmployees Where Id=@Id)
End

역시 에러를 일으킨다. 에러내용은 SCHEMABINDING 옵션을 쓰려면 two-part Name을 써야 한다고 에러 메세지
Alter Function fn_GetEmployees(Id int)
Returns nvarchar(30)
WITH SCHEMABINDING
as
Begin
  Return (Select Name From dbo.tblEmployees Where Id=@Id) <= dbo.추가 하여 two-part이름을 쓰자.
End

Drop table tblEmployees를 시도하면 fn_GetEmployees()에의해 사용되므로 삭제할수 없다고 에러메세지가 나온다.
누군가가 tblEmployees를 drop혹은 Name, Id컬럼을 수정또는 Drop하려 하면 에러가 발생된다.

SCHEMABINDING옵션은 함수가 참조하고 있는 database object에 연결되어져 있음을 나타낸다. 
함수 정의에 영향을 주는 어떠한 수정도 base object에 적용되지 않는다.
base object를 수정하려면 먼저 함수를 수정, drop뒤 수정해야한다.

34강 Temporary tables
Temporary table은 Permanent table과 아주 비슷하다. Permanent table은 drop table하기 전까지는 영구적으로 database에 존재한다.
반면 Temporary table은 TempDB에 생성되고 더이상 사용되지 않으면 자동으로 삭제된다.

Temporary table은 2종류가 있다.
1.Local Temporary table
2.Global Temporary table


1.Local Temporary table
Create Table #PersonDetails(Id int, Name nvarchar(20))  <= 테이블명에 #한개가 붙는다.
#를 붙여 table을 생성하면 System Databases > tempdb > Temporary Tables안에 테이블이 생긴다.
dbo.#PersonDetails____________14352134 이런식으로 이름이 붙는다.

Temporary table은 TEMPDB안에 생성된다.
TEMPDB안의 sysobjects system table에 query해야 한다.
테이블명뒤에 많은 ___와 난수가 붙기 때문에 아래와 같이 like 오퍼레이터를 써서 query 해야 한다.

Select name from tempdb..sysobjects where name like '#PersonDetails%'
dbo.#PersonDetails____________14352134 <= 실제 local table 이름 출력

Local Temporary table은 테이블을 생성한 connection에게만 사용가능하다. 생성한 connection이 close되게 되면 자동으로 drop된다.
명시적으로 Drop Table #PersionDetails 할수도 있다.

만약 Temporary table이 SP안에서 생성되어지면 SP의 실행이 완료되는 순간 자동으로 drop된다.
Create Procedure spCreateLocalTempTable
as
Begin
  Create Table #PersonDetails(Id int, Name nvarchar(20))
  Insert into #PersonDetails Values(1, 'Mike')
  Select * from #PersonDetails
End

User1, User2가 같은 이름으로 #table을 만들어도 각자의 Temporary table을 갖는다.

2.Global Temporary table
Create Table ##EmployeeDetails(Id int, Name nvarchar(20)) <= ##을 붙인다.
server의 모든 connection에서 보이며 table을 참조하고 있는 마지막 connection이 닫힐때 drop된다.
global은 모든 유저, 연결에 있어 unique해야하며 global temp table의 실제 이름을 살펴보면 어떠한 random number suffix가 붙지 않는다.



Local Temporary table과 Global Temporary table의 차이점
1.local # global ##
2.local에는 random 숫자가 붙으며 global에는 붙지 않는다.
3.local은 local을 생성한 SQL Server의 세션에게만 보이며 global은 모든 세션에서 보인다.
4.local은 생성한 세션이 닫히면 자동으로 drop, global은 참조하고 있는 모든 세션이 닫히면 파괴된다.


35강 Indexes
왜 인덱스인가?
index들은 table로부터 data를 빠르게 찾기위해 query에 의해 쓰여진다. 인덱스는 table과 view에대해 생성된다. 인덱스는 책에있는 인덱스와 아주 비슷하다.
정확한 인텍스들의 존재는 query의 퍼포먼스를 극적으로 향상시킨다.
인덱스가 없다면 query engine은 테이블에 있는 모든 행을 처음부터 끝까지 검색하며 이를 table scan이라 부른다.
table scan은 퍼포먼스에 아주 나쁘다.

Id Name Salary Gender
1 Sam 2500 Male
2 Pam 6500 Female
3 John 4500 Male
4 Sara 5500 Female
5 Todd 3100 Male


Select * From tblEmployees
Where Salary > 5000 and Salary < 7000
위와 같은 query는 Salary에 index가 없다면 table scan을 하게된다.

CREATE Index IX_tblEmployee_Salary ON tblEmployee (SALARY ASC)
위의 문장은 index를 생성한다. 인덱스는 아래와 같이 오름차순으로 각 Employee의 Salary정보를 저장한다. 실제 인덱스는 아래와는 살짝 다르다.
Salary RowAddress
2500 RowAddress
3100 RowAddress
4500 RowAddress
5500 RowAddress
6500 RowAddress
Design을 통해서 생성 가능 indexes에서 오른쪽클릭 new index

SQL server는 index에서 row address를 찾아 바로 row에 접근한다. 이것을 Index Seek이라 한다.
tblEmployee > Indexes > IX_tblEmployee_Salary(Non-Unique, Non-Clustered) 화일이 생성된다.
sp_HelpIndex tblEmployee <= 테이블에서 생성되어진 index출력

drop index tblEmployee.IX_tblEmployee_Salary <= index 삭제

36강 Clustered and nonclustered indexes
Index Types
1. Clustered
2. NonClustered
3. Unique
4. Filtered
5. XML
6. Full Text
7. Spatial
8. Columnstore
9. Index with included columns
10. Index on computed columns

Clustered와 nonclustered에 대해
비유를 하자면 전화번호부, 사전에 해당한다. 실제 순서와 인덱스가 동일하다. 전화번호 순 혹은 알파벳 순서로 나온다.
clustered index는 테이블의 데이타의 물리적 순서를 결정한다. 이 이유때문에 테이블은 한개의 clustered index만 가질수 있다.

Create Table tblEmployee
{
  Id int Primary Key,
  name nvarchar(50),
  ...
}

위의 테이블 Id 컬럼에 Primary key constraint가 걸려있다. PK는 테이블에 기존의 clustered index가 없다면 clustered index를 자동으로 생성한다.
Execute sp_helpindex tblEmployee 를 해서 확인할수 있다.

Insert into tblEmployee values(3, 'John'...)
Insert into tblEmployee values(1, 'Sam'...)
Insert into tblEmployee values(4, 'Sara'...)

위와 같이 id순서를 비순차적으로 insert해도 

Select * from tblEmployee 
id Name ...
1 Sam
2 Pam
3 John
...
Id가 순차적으로 나온다. 물리적으로 정렬이 되어 있기때문이다.

Clustered index가 여러 컬럼(a composite index)을 포함할수있다.

Gender와 Salary 컬럼으로 composite clustered index 생성 (기존의 Id컬럼의 Clustered index를 drop한뒤 생성해야한다. 현재 query문으로는 지워지지 않을것이다. GUI로 지워라)
Create Clustered Index IX_tblEmployee_Gender_Salary ON tblEmployee (Gender DESC, Salary ASC)

Select * from tblEmployee <= Id순서가 아닌 (Gender, Salary)의 순서로 바뀌었다.
Id Name Salary Gender City
1 Sam 2500 Male London
5 Todd 3100 Male Toronto
3 John 4500 Male New York
4 Sara 5500 Female Tokyo
2 Pam 6500 Female Sydney

Clustered index는 1개밖에 존재할수 없지만 Clustered index의 컬럼은 여러개(a composite index)가될수있다.


NonClustered index에대해
일반책의 index와 비슷하다. 실제 데이타와 인덱스가 따로 저장되어 있다.(사전과는 다르다.)

Create NonClustered Index IX_tblEmployee_Name ON tblEmployee (Name)

Id Name Salary Gender City
1 Sam 2500 Male London
5 Todd 3100 Male Toronto
3 John 4500 Male New York
4 Sara 5500 Female Tokyo
2 Pam 6500 Female Sydney

Name RowAddress
John RowAddress
Pam RowAddress
Sam RowAddress
Sara RowAddress
Todd RowAddress

데이타와 인덱스가 별개로 저장된다. 데이타와 인덱스가 별개이므로 1개 이상의 nonclustered index를 가질수있다.
책을 예로 들면 시작부분에 챕터들의 인덱스 끝부분에 용어 인덱스를 따로 두는 것과 같다.
인덱스 자체에서 오름, 내림 차순으로 인덱스키들이 정렬되며 이는 데이타 테이블에 전혀 영향을 미치지 않는다.

Clustered Index, NonClustered Index 차이점 <= 인터뷰 질문
1. Clustered 테이블당 1개, NonClustered 1개이상
2. Clustered가 NonClustered보다 빠르다. NonClustered에서는 실제 테이블을 참조하는 과정이 1번더 발생하기때문이다.
Select Id, Name From tblEmployee Where Name='Sara' 일 경우 Sara를 NonClustered에서 찾은뒤 실제 테이블로 가서 Id 컬럼을 가져와야 한다.
Cluster는 이러한 과정이 필요없다.
3. Clustered는 테이블에 있는 행들의 storage order를 결정하고 다른 추가적 디스크 공간이 필요없다. 하지만 NonClustered는 테이블에서 분리되어 저장되고
추가적 공간이 필요하다.

37강 Unique and Non Unique Indexes
Unique index 는 인덱스 안의 키값들의 Uniqueness를 강제하는데 쓰인다.
PK 제약은 unique clusted index를 디폴트로 생성한다.
Uniqueness는 Clusterd, NonClustered 양꼭에 쓰일수있는 인덱스의 속성이다.

Create Unique NonClustered Index UIX_tblEmployee_FirstName_LastName On tblEmployee(FirstName, LastName)

Unique Constraint와 Unique index의 차이점
둘사이의 중요한 차이점은 없다. 사실 Unique constraint를 생성하면 내부적으로 Unique index가 생성된다.
이를 증명하려면 drop index tblEmployee.PK__tblEmplo__12345134를 지우려고 하면 에러가 난다.
An explicit DropIndex is not allowed on index 'tblEmployee.PK__tblEmplo__12345134'   It is being used for PRIMARY KEY constraint enforcement.
즉 PRIMARY KEY constraint가 Unique index를 사용중이다!
UI를 사용하여 Index를 지우면 Keys안의 PK화일도 사라진다.

Alter Table tblEmployee
Add Constraint UQ_tblEmployee_City
UNIQUE (City)

Constrants폴더안에 UQ_tblEmployee_City가 생겼지만 동시에 Indexes폴더안에 UQ_tblEmployee_City(Unique, Non-Clustered)인덱스도 생긴다.

Alter Table tblEmployee
Add Constraint UQ_tblEmployee_City
UNIQUE Clustered (City)
UQ_tblEmployee_City(Unique, Clustered)

unique index보다 unique constraint를 생성해야만 할때는 언제인가?
데이타 무결성이 목적일때 의도를 명확히 하기 위해 unique constraint를 생성한다. 이는 index의 목적을 아주 명확하게 한다.
unique constraint던 수동으로 만든 unique index이던 data validation을 같은 방식으로 하므로 query optimizer는 이를 구분하지 않는다.

기억해 두면 좋은 기법
1. PK constraint는 디폴트로 unique cludsted index를 생성한다. 반면에 Unique Contraint는 unique NonClustered index를 생성한다. 원한다면
default 동작을 위의 UNIQUE Clustered (City)처럼 바꿀수 있다.
2. Unique constraint 혹은 Unique idnex는 테이블에 중복키가 있으면 생성할수없다. 중복키를 제거, 업데이트 한뒤 생성해야한다.


38강 Advantages and disadvantages of indexes

장점
query에의해 data를 빠르게 찾는데 쓰인다.
Salary가 Where, Order by, Group By등에 쓰일대 검색이 빨라진다.

단점
추가적인 디스크 공간 필요 : 모든 NonClustered index는 추가적 공간이 필요하다.

Insert Update and Delete 문이 느려질수 있다: DML(Data Manipulation Language)문(Insert, Update Delete)이 테이블의 데이타를 수정할때 모든 인덱스에 있는
데이타들도 Update되어야한다. 인덱스가 지우려고 하는 행을 찾는데 도움을 줄수 있지만 너무 많은 인덱스들의 업데이트(인덱스 화일이 많거나 테이블의 크기가 너무 큰경우)는 
실제로 수정 연산에대한 퍼포먼스를 저하시킨다. 예로서 salary=2500인 행을 지울때 테이블 뿐만 아니라 인덱스도 업데이트 해야한다. 인덱스 튜닝은 그래서 중요하다.

covering query란?: 만약 Select문에서 요청한 컬럼들이 모두 인덱스에 있다면 테이블을 다시 룩업할 필요가 없다. 요쳥된 컬럼데이타들이 단순히 인덱스로부터 리턴될수 있다.

Clustered index는 테이블에 모든 데이타를 포함하기 때문에 항상 query를 cover한다. 
composite index는 2개 이상의 컬럼의 인덱스이며 clustered, nonclustered index들은 composite index가 될수있다. 어느정도는 composite index가 query를 cover할수있다.


39강 Views in sql server
View는 저장된 SQL query일 뿐이다. 또한 가상테이블로서 간주되어진다.

Create View vWEmployeesByDepartment
as
Select Id, Name, Salary, Gender, DeptName
From tblEmployee
join tblDepartment
on tblEmployee.DepartmentId = tblDepartment.DeptId

Select * from vWEmployeesByDepartment <= 테이블처럼 쓴다.

sp_helptext vWEmployeesByDepartment

view의 장점
database schema의 복잡성을 줄인다. sql에 익숙하지 않은 사람에게 5-6개의 join문을 view로 만들어준다. 받은 사람은 그냥 단순한 테이블로서 취급하게된다.

행, 열레벨의 보안에 쓰일수도 있다. 아주 낮은 레벨의 보안

aggregated data(집계데이타)를 보여주는데 쓰일수도 있다.

Alter View
Drop View vWName


40강 Updatable views in sql server
View에 Insert, Update, Delete 가능한가? 가능하다. basetable에 적용된다.

View가 여러 테이블로부터 생성되는 것이라면 문제가 있다.
Id Name DepartmentId
1 John  3
2 Ben  3

DeptId DeptName
1 IT
2 Payroll 
3 HR
4 Admin

위의 2테이블을 통해 생성되는 View

Create View vwEmployeeeDetailsByDepartment
as
Select Id, Name, DeptName
from tblEmployee
join tblDepartment
on tblEmployee.DepartmentId = tblDepartment.DeptId


Id Name DeptName
1 John HR
2 Ben HR


만약 John의 DeptName을 HR => IT로 변경하면 어떻게 되는가?
Update vwEmployeeeDetailsByDepartment Set DeptName='IT' where Name = 'John'  <= 컬럼 1개만 update했기때문에 update되는듯..여러개면 안될듯..
Select * from vwEmployeeeDetailsByDepartment

Id Name DeptName
1 John IT
2 Ben IT

Ben의 DeptName까지 바뀌며 이는 원하던 바가 아니다.
이렇게 되는 이유는 Base Table의 값이 바뀌어 버린다.
DeptId DeptName
1 IT
2 Payroll 
3 IT <= 이게 바뀌어 버림
4 Admin

결론 = 만약 뷰가 여러 테이블에 기초하는경우 view를 update했을때 base table들을 정확하게 Update하지 못할수 있다.
여러테이블에 기초하는 뷰를 정확하게 Update하기 위해 INSTEAD OF trigger를 사용한다. trigger는 나중에 살펴본다.


41강 Indexed views
indexed view란? 혹은 view에 index를 생성할때 무슨일이 일어나는가?
non-indexed view는 저장된 SQL query일뿐이다. view로 부터 data를 뽑을때 실제 basetable들로부터 data를 뽑아낸다.
default로 view는 단지 가상의 테이블이지 실제 data를 저장하지 않는다.

하지만 view에 index를 생성할때 view는 materialized된다. 이말의 뜻은 view가 data를 저장할수 있게 되었다는 뜻이다.
SQL server에서 이런것을 indexed view라 하고, 오라클에서는 Materialized view라 부른다.

ProductId Name UnitPrice
1 Books 20
2 Pens 14
3 Pencils 11
4 Clips 10

ProductId QuantitySold
1 10
3 23
4 21
2 12
1 13
3 12

위의 2테이블에서 다음과 같은 view를 만들고 싶다.
Name TotalSales TotalTransactions
Books 960 4
Clips 340 2
Pencils 385 2

Create view vWTotalSalesByProduct
with SchemaBinding
as
Select Name, 
SUM(ISNULL((QuantitySold * UnitPrice), 0)) as TotalSales, 
COUNT_BIG(*) as TotalTransactions  <= COUNT()함수와 같다. 단지 리턴값이 bigint이다.
from dbo.tblProductSales
join dbo.tblProduct
on dbo.tblProduct.ProductId = dbo.tblProductSales.ProductId
group by Name


만약 view에 index를 만들고 싶으면 다음과 같은 규칙을 반드시 따라야 한다.
1. with SchemaBinding 옵션으로 view를 생성한다.
2. Select리스트에 있는 aggregate function이 expression을 참조한며 NULL일 가능성이 있으면 replacement value를 반드시 제공해야한다.
위에서는 ISNULL()함수를 사용하여 NULL일경우 0으로 교체한다.
3. Group by가 있으면 Select list는 COUNT_BIG(*)을 포함하여야 한다.
4. view에 있는 base-table들은 2part name을 가져야한다.
위의 규칙외에도 많으니 msdn참조.

이제 view에 index를 생성해보자
view에 생성하는 첫번째 index는 반드시 unique clustered index이어야 한다. unique clustered index생성뒤 추가적인 nonclustered index들이 생성가능하다.

Create Unique Clustered Index UIX_vWTotalSalesByProduct_Name on vWTotalSalesByProduct(Name)

view에 index를 생성하였기때문에 view는 materialized되었다. data는 이제 view에 저장된다. 
execute Select * from vWTotalSalesByProduct를 실행시킬때 base-table들이 아닌 view 자체에서 data를 가져온다.

indexed view은 join과 aggregation을 포함하는 query들의 퍼포먼스를 극적으로 향상시킬수있다.
하지만 indexed view를 유지 하는것은 table의 index를 유지하는것보다 코스트가 훨씬 높다.

indexed view는 기저 데이타들이 자주 변하지 않을때 이상적이다.
Indexed view는 data가 주로 리포트 또는 분석 목적의 OLAP system(?)에서 많이 쓰여진다.
아마도 매주 혹은 매일 밤 batch를 돌려 reprocess할지도 모른다. 하지만 기본적으로 가장좋은 indexed view의 데이타 로드 방법은 drop뒤 indexed view를 재생성하는것이다.
data가 자주 추가 변경되는 OLTP sytem(?)에서는 적당하지 않다.


42강 View limitations
1. view는 parameter를 가질수 없다. 만약 필요하다면 table valued function을 써라.
Create View vWEmployeeDetails
@Gender nvarchar(20)  <= view에서는 불가능하다!
as
Select Id, Name, Gender, DepartmentId
from  tblEmployee
where Gender = @Gender

table valued function을 사용할것!
Create function fnEmployeeDetails(@Gender nvarchar(20))
Returns Table
as
Return 
(Select Id, Name, Gender, DepartmentId
from tblEmployee where Gender = @Gender)

Select * from dbo.fnEmployeeDetails('Male')

2. Rules와 Defaults는 view에서 쓸수없다.(?)
3. Order by절은 TOP또는 FOR XML이 같이 없으면 view에서 쓸수없다.
create View vWEmployeeDetailsSorted
as
Select Id, Name, Gender, DepartmentId
from tblEmployee
order by Id

If you use ORDER BY, you will get an error stating - 'The ORDER BY clause is invalid in views, inline functions, derived tables, subqueries, 
and common table expressions, unless TOP or FOR XML is also specified.'

4. Temporary table로부터 view를 만들수 없다.
Create View vwOnTempTable
as
Select Id, Name, Gender
from ##TestTempTable


43강 DML triggers in sql server Part 43
SQL server에는 3종류의 trigger가 있다.
1.DML trigger
2.DDL trigger
3.Logon trigger

DDL과 Logon은 다음에 설명한다.

db에 어떤 이벤트가 발생했을때 자동으로 execute되는 stored procedure를 trigger라고 한다.

DML은 Data Manipulation Language를 의미한다. INSERT, UPDATE, DELETE문을 DML문이라고 한다.
INSERT, UPDATE, DELETE event에의해 data가 수정될때 DML trigger가 호출된다.

DML trigger는 다시 2가지 타입으로 나뉜다.
1.After trigger (FOR trigger라고도 불림)
2.Instead of trigger

After trigger는 이름그대로 각각의 문이 실행이 완료된뒤 불려지는 trigger이다.
Instead of trigger는 각각의 문의 실행대신 불려지는 trigger이다.

새로운 employee가 추가될때마다 Id와 date를 기록해놓는다고 할때 가장 쉬운 방법은 Insert event의 after trigger를 사용하는것이다.

CREATE TRIGGER tr_tblEMployee_ForInsert
ON tblEmployee
FOR INSERT
AS
BEGIN
 Declare @Id int
 Select @Id = Id from inserted <= trigger안에서만 의미있는 테이블
 
 insert into tblEmployeeAudit 
 values('New employee with Id  = ' + Cast(@Id as nvarchar(5)) + ' is added at ' + cast(Getdate() as nvarchar(20)))
END

inserted라는 특수한 테이블이 있다. trigger만이 접근 가능한 테이블이며 tblEmployee와 구조가 완벽히 같은 행을 가지고 있다.

delete시에도 똑같이 deleted이 있다.
CREATE TRIGGER tr_tblEMployee_ForDelete
ON tblEmployee
FOR DELETE
AS
BEGIN
 Declare @Id int
 Select @Id = Id from deleted
 
 insert into tblEmployeeAudit 
 values('An existing employee with Id  = ' + Cast(@Id as nvarchar(5)) + ' is deleted at ' + Cast(Getdate() as nvarchar(20)))
END


44강 After update trigger Part 44
Create trigger tr_tblEmployee_ForUpdate
on tblEmployee
for Update
as
Begin
 Select * from deleted
 Select * from inserted 
End
update trigger는 deleted, inserted 2개의 특수 테이블을 갖는다.

Update tblEmployee set Name = 'Tods', Salary = 2000, Gender = 'Female' where Id = 4  <= update예제

Alter trigger tr_tblEmployee_ForUpdate
on tblEmployee
for Update
as
Begin
      -- Declare variables to hold old and updated data
      Declare @Id int
      Declare @OldName nvarchar(20), @NewName nvarchar(20)
      Declare @OldSalary int, @NewSalary int
      Declare @OldGender nvarchar(20), @NewGender nvarchar(20)
      Declare @OldDeptId int, @NewDeptId int
     
      -- Variable to build the audit string
      Declare @AuditString nvarchar(1000)
      
      -- Load the updated records into temporary table
      Select *
      into #TempTable   <= into 절! table을 복사할때 많이 쓴다.
      from inserted
     
      -- Loop thru the records in temp table
      -- 루프를 도는 이유
      -- Update tblEmployee set Name = 'Tods', Salary = 2000, Gender = 'Female' where Id IN (1,4,6,7)
      -- 일경우 여러개가 한번에 Update된다.
      While(Exists(Select Id from #TempTable)) -- Exists()는 subquery에 record가 있는지 체크하는 함수!
      Begin
            --Initialize the audit string to empty string
            Set @AuditString = ''
           
            -- Select first row data from temp table
            Select Top 1 @Id = Id, @NewName = Name, 
            @NewGender = Gender, @NewSalary = Salary,
            @NewDeptId = DepartmentId
            from #TempTable
           
            -- Select the corresponding row from deleted table
            Select @OldName = Name, @OldGender = Gender, 
            @OldSalary = Salary, @OldDeptId = DepartmentId
            from deleted where Id = @Id
   
            -- Build the audit string dynamically           
            Set @AuditString = 'Employee with Id = ' + Cast(@Id as nvarchar(4)) + ' changed'
            if(@OldName <> @NewName)
                  Set @AuditString = @AuditString + ' NAME from ' + @OldName + ' to ' + @NewName
                 
            if(@OldGender <> @NewGender)
                  Set @AuditString = @AuditString + ' GENDER from ' + @OldGender + ' to ' + @NewGender
                 
            if(@OldSalary <> @NewSalary)
                  Set @AuditString = @AuditString + ' SALARY from ' + Cast(@OldSalary as nvarchar(10))+ ' to ' + Cast(@NewSalary as nvarchar(10))
                  
            if(@OldDeptId <> @NewDeptId)
                  Set @AuditString = @AuditString + ' DepartmentId from ' + Cast(@OldDeptId as nvarchar(10))+ ' to ' + Cast(@NewDeptId as nvarchar(10))
           
            insert into tblEmployeeAudit values(@AuditString)
            
            -- Delete the row from temp table, so we can move to the next row
            Delete from #TempTable where Id = @Id
      End
End


45강 Instead of insert trigger
Instead of trigger는 triggering event(INSERT, UPDATE, DELETE)대신 호출된다.(실제 데이타를 INSERT, UPDATE, DELETE하는 대신 trigger가 호출된다.)
일반적으로 Instead of trigger는 여러 테이블에 기반을 둔 view를 정확히 update할때 주로 쓰인다.

Create view vWEmployeeDetails
as
Select Id, Name, Gender, DeptName
from tblEmployee 
join tblDepartment
on tblEmployee.DepartmentId = tblDepartment.DeptId


Insert into vWEmployeeDetails values(7, 'Valarie', 'Female', 'IT') <= 에러를 발생시킨다.
'View or function vWEmployeeDetails is not updatable because the modification affects multiple base tables.'

디폴트로 여러 테이블에 기반을 한 view에 insert하는것은 에러이다. =>Update에서도 마찬가지.
중요한것은 기반하고 있는 여러테이블에 수정이 가해지면 에러이다. 여러 테이블중 1개의 테이블에만 영향을 끼치면 에러는 나지 않지만
예상하지 않은 결과가 발생할때도 있다.

Create trigger tr_vWEmployeeDetails_InsteadOfInsert
on vWEmployeeDetails
Instead Of Insert
as
Begin
 Declare @DeptId int
 
 --Check if there is a valid DepartmentId
 --for the given DepartmentName
 Select @DeptId = DeptId 
 from tblDepartment 
 join inserted
 on inserted.DeptName = tblDepartment.DeptName
 
 --If DepartmentId is null throw an error
 --and stop processing
 if(@DeptId is null)
 Begin
  Raiserror('Invalid Department Name. Statement terminated', 16, 1) -- error msg, severity level:16(유저에의해 고쳐질수 있는 일반적 에러), state:1
  return
 End
 
 --Finally insert into tblEmployee table
 Insert into tblEmployee(Id, Name, Gender, DepartmentId)
 Select Id, Name, Gender, @DeptId
 from inserted
End

Insert를 하고 있으므로 inserted는 추가되는 행을 포함 하고 있으며 deleted는 비어있다.



46강 Instead of update triggers
Instead of update trigger를 view 또는 table에 걸 수 있다.

40강 예제
Create view vWEmployeeDetails
as
Select Id, Name, Gender, DeptName
from tblEmployee 
join tblDepartment
on tblEmployee.DepartmentId = tblDepartment.DeptId

Update vWEmployeeDetails 
set Name = 'Johny', DeptName = 'IT'
where Id = 1

2개이상의 테이블을 Update하므로 error가 발생한다.
 'View or function vWEmployeeDetails is not updatable because the modification affects multiple base tables.'

 하지만 
Update vWEmployeeDetails 
set DeptName = 'IT'
where Id = 1

에러가 발생하지는 않지만 40강처럼 tblDepartment table의 내용이 IT로 바뀌어 버린다. 우리가 원하는건 tblEmployee.DepartmentId를 IT로 바꾸는것이다.
결론적으로 view가 여러테이블에 의존하거나 혹은 Update가 가능할때도 예상하는 대로 동작하지 않을때가 있다.
base table들을 정확하게 update하기 위해 Instead of Update trigger를 사용할수있다.

Create Trigger tr_vWEmployeeDetails_InsteadOfUpdate
on vWEmployeeDetails
instead of update
as
Begin
 -- if EmployeeId is updated
 if(Update(Id)) <= Update()함수는 Update vWEmployeeDetails set Name = 'Johny', DeptName = 'IT' where Id = 1 처럼 
 -- Set이후에 컬럼명이 있는지 확인한다. 컬럼값이 같은지 다른지 비교하는 함수가 아니다.
 Begin
  Raiserror('Id cannot be changed', 16, 1)
  Return
 End
 
 -- If DeptName is updated
 if(Update(DeptName)) 
 Begin
  Declare @DeptId int

  Select @DeptId = DeptId
  from tblDepartment
  join inserted
  on inserted.DeptName = tblDepartment.DeptName
  
  if(@DeptId is NULL )
  Begin
   Raiserror('Invalid Department Name', 16, 1)
   Return
  End
  
  Update tblEmployee set DepartmentId = @DeptId
  from inserted
  join tblEmployee
  on tblEmployee.Id = inserted.id
 End
 
 -- If gender is updated
 if(Update(Gender))
 Begin
  Update tblEmployee set Gender = inserted.Gender
  from inserted
  join tblEmployee
  on tblEmployee.Id = inserted.id
 End
 
 -- If Name is updated
 if(Update(Name))
 Begin
  Update tblEmployee set Name = inserted.Name
  from inserted
  join tblEmployee
  on tblEmployee.Id = inserted.id
 End
End


 Update()함수는 Update vWEmployeeDetails set Name = 'Johny', DeptName = 'IT' where Id = 1 처럼 
 Set이후에 컬럼명이 있는지 확인한다. 컬럼값이 같은지 다른지 비교하는 함수가 아니다. 또한 Update()함수는 모든 행에 대해 적용된다.
 그래서 inserted와 deleted 테이블 사이의 비교 하는것을 추천한다. 


47강 Instead of delete triggers
Create view vWEmployeeDetails
as
Select Id, Name, Gender, DeptName
from tblEmployee 
join tblDepartment
on tblEmployee.DepartmentId = tblDepartment.DeptId


Delete from vWEmployeeDetails where Id = 1

Create Trigger tr_vWEmployeeDetails_InsteadOfDelete
on vWEmployeeDetails
instead of delete
as
Begin
 Delete tblEmployee   <= join문을 통한 delete 처음 보는듯..뭔 문법인가? http://www.webmadang.net/database/database.do?action=read&boardid=4001&page=1&seq=21
 from tblEmployee
 join deleted
 on tblEmployee.Id = deleted.Id
 
 --Subquery
 --Delete from tblEmployee 
 --where Id in (Select Id from deleted)
End

일반적으로 join문을 통한 delete가 subquery 보다 빠르다.


48강 Derived tables and common table expressions (CTE) in sql server Part 48
각 부서의 인원이 2 이상인 부서만 다음과 같이 출력하고 싶다고 가정하자.

DeptName TotalEmployees
IT 2
HR 2

이렇게 할수 있는 몇가지 방법이 있다.

view를 사용하는 방법
Create view vWEmployeeCount
as
Select DeptName, DepartmentId, COUNT(*) as TotalEmployees
from tblEmployee
join tblDepartment
on tblEmployee.DepartmentId = tblDepartment.DeptId
group by DeptName, DepartmentId

위의 view를 사용해서 query한다.
Select DeptName, TotalEmployees 
from vWEmployeeCount
where  TotalEmployees >= 2

view는 database에 저장되고 다른 query나 sp에서 사용할수 있다. 하지만 view가 한곳에서만 사용된다면 다른 방법을통해
쉽게 view를 제거하는것이 가능하다. (CTE, Derived Tables, Temp Tables, Table Variable)

Temp table을 사용하는 방법
Select DeptName, DepartmentId, COUNT(*) as TotalEmployees
into #TempEmployeeCount
from tblEmployee
join tblDepartment
on tblEmployee.DepartmentId = tblDepartment.DeptId
group by DeptName, DepartmentId

Select DeptName, TotalEmployees
From #TempEmployeeCount
where TotalEmployees >= 2

Drop Table #TempEmployeeCount

Temp table은 TempDB에 저장된다. #은 현재 세션에서 보이며 nested stored procedure call에서 공유될수있다.


Table Variable을 사용하는 방법
Declare @tblEmployeeCount table
(DeptName nvarchar(20), DepartmentId int, TotalEmployees int)

Insert @tblEmployeeCount
Select DeptName, DepartmentId, COUNT(*) as TotalEmployees
from tblEmployee
join tblDepartment
on tblEmployee.DepartmentId = tblDepartment.DeptId
group by DeptName, DepartmentId

Select DeptName, TotalEmployees
From @tblEmployeeCount
where  TotalEmployees >= 2

Temptable과 마찬가지로 table variable 역시 TempDB에 생성된다.
table variable의 스코프는 batch, sp, 테이블이 선언된 statement block이다.
procedure들 사이에 파라메터로서 패스될수있다.


Derived Table을 사용하는 방법
Select DeptName, TotalEmployees
from 
 (
  Select DeptName, DepartmentId, COUNT(*) as TotalEmployees
  from tblEmployee
  join tblDepartment
  on tblEmployee.DepartmentId = tblDepartment.DeptId
  group by DeptName, DepartmentId
 ) 
as EmployeeCount  <= () as EmployeeCount () 안쪽의 결과 table에 EmployeeCount라는 이름을 주었으며 이를 derived table이라 부른다.
where TotalEmployees >= 2

derived table은 현재 query context안에서만 사용가능하다.


CTE (common table expressions)를 사용하는 방법
With EmployeeCount(DeptName, DepartmentId, TotalEmployees) <= ()안의 컬럼 명은 옵션
as
(
 Select DeptName, DepartmentId, COUNT(*) as TotalEmployees
 from tblEmployee
 join tblDepartment
 on tblEmployee.DepartmentId = tblDepartment.DeptId
 group by DeptName, DepartmentId
)

Select DeptName, TotalEmployees
from EmployeeCount
where TotalEmployees >= 2

핸개의 SELECT, INSERT, UPDATE, DELETE, CREATE VIEW문의 실행스코프안에 정의 되어 있는 임시 결과로 생각할수있다.
CTE는 object로서 저장되지 않으며 query동안만 유지되는 면에서 derived table과 닮았다.

49강 CTE in sql server Part 49
CTE(Common Table Expression)은 SQL server 2005에서 나왔다. CTE는 CTE바로뒤 나타나는 SELECT, INSERT, UPDATE, DELETE문안에서 참조 할 수 있는 임시 결과 셋이다.

--문법
WITH cte_name (Column1, Column2, ....) Column부분은 없어도 된다.
AS
( CTE_query )

With EmployeeCount(DepartmentId, TotalEmployees)
as
(
 Select DepartmentId, COUNT(*) as TotalEmployees
 from tblEmployee
 group by DepartmentId
)

Select DeptName, TotalEmployees
from tblDepartment
join EmployeeCount
on tblDepartment.DeptId = EmployeeCount.DepartmentId
order by TotalEmployees


바로 CTE뒤의 SELECT문에만 적용된다.
With EmployeeCount(DepartmentId, TotalEmployees)
as
(
 Select DepartmentId, COUNT(*) as TotalEmployees
 from tblEmployee
 group by DepartmentId
)

Select 'Hello' <= 여기서 CTE소모

Select DeptName, TotalEmployees <= 접근할수없다.
from tblDepartment
join EmployeeCount
on tblDepartment.DeptId = EmployeeCount.DepartmentId
order by TotalEmployees

한개의 With절로 여러개의 CTE를 만들수있다.
With EmployeesCountBy_Payroll_IT_Dept(DepartmentName, Total)
as
(
 Select DeptName, COUNT(Id) as TotalEmployees
 from tblEmployee
 join tblDepartment 
 on tblEmployee.DepartmentId = tblDepartment.DeptId
 where DeptName IN ('Payroll','IT')
 group by DeptName
),
EmployeesCountBy_HR_Admin_Dept(DepartmentName, Total)
as
(
 Select DeptName, COUNT(Id) as TotalEmployees
 from tblEmployee
 join tblDepartment 
 on tblEmployee.DepartmentId = tblDepartment.DeptId
 group by DeptName 
)

Select * from EmployeesCountBy_HR_Admin_Dept  <= UNION문으로 한개의 문이다.
UNION
Select * from EmployeesCountBy_Payroll_IT_Dept

50강 Updatable common table expressions
1. CTE가 한개의 base table에 기초를 한다면 Update는 예상대로 성공한다.
With Employees_Name_Gender
as
(
 Select Id, Name, Gender from tblEmployee
)
Update Employees_Name_Gender Set Gender = 'Female' where Id = 1

2. CTE가 한개 이상의 base table에 기초를 할때 Update가 여러 table에 영향을 준다면 에러를 내며 Update가 실패한다.
With EmployeesByDepartment
as
(
 Select Id, Name, Gender, DeptName 
 from tblEmployee
 join tblDepartment
 on tblDepartment.DeptId = tblEmployee.DepartmentId
)
Update EmployeesByDepartment set 
Gender = 'Female', DeptName = 'IT'
where Id = 1


3. CTE가 한개 이상의 base table에 기초를 할때 Update가 1개의 table에만 영향을 준다면 Update는 성공한다(하지만 언제나 그렇듯 예상한대로 동작하진 않는다.)
With EmployeesByDepartment
as
(
 Select Id, Name, Gender, DeptName 
 from tblEmployee
 join tblDepartment
 on tblDepartment.DeptId = tblEmployee.DepartmentId
)
Update EmployeesByDepartment set 
DeptName = 'IT' where Id = 1        <= view에서 봤던 문제가 생긴다. tblDepartment의 내용이 IT로 바뀐다. 이전 view에서는 트리거로 해결했었다.


51강 Recursive CTE
자기 자신을 참조하는 CTE를 Recursive CTE라 부른다. Recursive CTE는 계층적 데이타를 디스플레이하는데 큰 도움을 준다.

EmployeesId Name ManagerId
1 Tom 2
2 Josh NULL
3 Mike 2
4 John 3
5 Pam 1
6 Mary 3
7 James 1
8 Sam 5
9 Simon 1

Employee Name, Manager Name을 출력하고 싶다.
EmployeeName ManagerName
Tom Josh
Josh Super Boss
Mike Josh
John Mike
Pam Tom
Mary Mike
James Tom
Sam Pam
Simon Tom

위의 출력을 달성하기 위해선 14강의 Self join을 이용한다.
Select Employee.Name as [Employee Name],
IsNull(Manager.Name, 'Super Boss') as [Manager Name]
from tblEmployee Employee
left join tblEmployee Manager
on Employee.ManagerId = Manager.EmployeeId

위의 결과에 추가해서 조직도 상의 level을 표시하야만 한다면?
EmployeeName ManagerName
Josh Super Boss 1
Tom Josh 2
Mike Josh 2
John Mike 3
Mary Mike 3
Pam Tom 3
James Tom 3
Simon Tom 3
Sam Pam 4

With
  EmployeesCTE (EmployeeId, Name, ManagerId, [Level]) <= Level은 SQL의 키워드이며 이를 컬럼 이름으로 쓰려면 키워드를 []로 감싸준다.
  as
  (
    Select EmployeeId, Name, ManagerId, 1 <= level 을 1로 하드 코딩
    from tblEmployee
    where ManagerId is null
    
    union all
    
    Select tblEmployee.EmployeeId, tblEmployee.Name, 
    tblEmployee.ManagerId, EmployeesCTE.[Level] + 1  <= 위의 query때문에 1로 초기화 되어 있다 
    from tblEmployee
    join EmployeesCTE  <= Self referencing CTE
    on tblEmployee.ManagerID = EmployeesCTE.EmployeeId
  )
Select EmpCTE.Name as Employee, Isnull(MgrCTE.Name, 'Super Boss') as Manager, 
EmpCTE.[Level] 
from EmployeesCTE EmpCTE
left join EmployeesCTE MgrCTE
on EmpCTE.ManagerId = MgrCTE.EmployeeId


For those who didn't understand the beautiful logic behind this recursive function,
first try to understanding the logic of recursion by googling at a simple recursive program to calculate the factorial of a number and then after u have understood how recursion really works then here is how this example works-
1.we find the SuperBoss by ->Select ... where ManagerId is null i.e. first select in CTE
2.Now the previous select puts the SuperBoss in the CTE table!
We now use his EmpId to match who works under him  in the words
tblManagers
join EmployeeCTE
on tblManagers.ManagerId= EmployeeCTE.EmployeeId -->matching
i.e. those who are the second level which explains the [Level]+1 in the second select query but wait!!! We are not done yet!
3.After the first select we are summing up rows using union all and in the second select we are again calling the CTE itself! in the joins query.
So after we find the SuperBoss in the first select and then finding 2nd level Bosses
we again call the CTE which makes a recursive call to itself meanwhile
ADDING the second level Bosses to the CTE table from the Union all keyword!
4. So now after we have level 1 and 2 bossses in the CTE table, the recursive call tries to
find the 3rd level Bosses in the next call, add them to the CTE table and then again call itself to find if someone from the tblEmployees are working under any of the Bosses in the CTE table and add them to CTE.
This keeps repeating until no new records can be added or no more employees are left to be added.
NOTE: The is null select case adds the record of Super Boss in the very first CTE
after that it is the second select that is used recursively!
Hope this helps to those who didn't get the example! :)


52강 Database normalization Part 52
Database normalization : 데이타중복(data redundancy, duplication)을 최소하기위해 데이타를 조직화하는 프로세스이며 이는 data consistency(일관성)를 보장하게 한다.

EmployeeName Gender Salary DeptName DeptHead DeptLocation
Sam Male 4500 IT John London

Data Redundancy의 문제
1. Disk 낭비 => Employee가 5만명이라고 했을때...DeptName DeptHead DeptLocation이 너무 많이 중복된다.
2. Data Inconsistency => IT의 DeptHead가 바뀌었었때 해당 행을 전부 업데이트해야하는데 몇개의 행을 update하는 것을 깜빡했을경우를 생각해보라. data inconsistent가 발생한다.
3. DML(Insert, Update, Delete) query가 느려질수 있다.=> IT의 DeptHead가 바뀌었었때 해당 행을 전부 update해야 하며 이는 시간이 걸린다.

Normalized Table Design
테이블을 2개로 나누면 중복이 제거된다.
DeptId DeptName DeptHead DeptLocation
EmployeeId EmployeeName Gender Salary DeptId


Database normalization은 단계적인 프로세스이다. 6개의 normal from이 있으며(1NF~6NF) 대부분의 database들은 3NF이다.
각 normal form들은 따라야 하는 규칙이 존재한다.


First Noraml Form (1NF)
다음과 같은 조건을 만족하면 1NF라고 불려진다.
1. 각 컬럼의 데이타는 atomic해야한다. ','로 나뉘어진 여러값들같은 것은 안된다.
2. 테이블은 어떠한 반복컬럼 그룹을 갖지 않는다.
3. primary key를 사용하여 각 record를 식별한다.

Non Atomic Employee Column(Employee)
DeptName Employee
IT  Sam, Mike, Shan           

Problems of Non Atomic Columns
단 하나만의 Employee의 SELECT, INSERT, UPDATE가 불가능하다.

No Repeating column Groups
DeptName Employee1 Employee2 Employee3
IT Sam Mike Shan
HR Pam

Problems of Repeating Column Groups
3명 이상의 Employee : Alter table로 테이블 구조 변경이 필요하다.
3명 이하의 Employee : 디스크 낭비


예를 들면 
DeptId DeptName
1 IT
2 HR

DetpId Employee
1 Sam
1 Mike
1 Shan
2 Pam
위의 각각의 table은 1NF이다.


53강 Second normal form and third normal form Part 53
다음과 같은 조건을 만족하면 2NF라고 불려진다
1. 테이블이 1NF의 모든 조건을 만족한다.
2. redundant data를 분리된 테이블로 옮긴다.
3. foreign key들을 사용하여 이러한 테이블들 사이에 관계를 생성한다.

EmpId EmployeeName Gender Salary DeptName DeptHead DeptLocation
1 Sam Male 4500 IT John London
2 Pam Female 2300 HR Mike Sydney

Dept정보는 Employee와는 독립적이며 redundant하다.

Table Design in Second normal form
DeptId DeptName DeptHead DeptLocation
EmpId EmployeeId EmployeeName Gender Salary DeptId


다음과 같은 조건을 만족하면 3NF라고 불려진다.
1. 1NF와 2NF의 모든 조건을 만족한다.
2. primary key에 fully dependent하지 않은 컬럼(attributes)들을 포함하지 않는다.
fully dependent: 완벽하게 종속적이어야 한다. 다른 컬럼에 연관이 없다. 오직 한 컬럼에만 연관이 있다!

EmpId EmployeeName Gender Salary AnnualSalary DeptId

AnnualSalary(연봉)은 EmpId에 의존적이다. 하지만 fully dependent하진않다. Salary에도 연관이 있기때문.
위의 경우 AnnualSalary는 Salary로부터 계산되어질수 있으므로 삭제 가능하다.

EmpId EmployeeName Gender Salary DeptName DeptHead

EmployeeName Gender Salary DeptName은 EmpId에 fully dependent하다.
DeptHead의 경우 EmpId에 dependent하다. 하지만 DeptName에도 dependent하다.
이를 다른 테이블로 분리하여 FK로 관계를 설정한다.

Table Design in third normal form
EmpId EmployeeName Gender Salary DeptId
DeptId DeptName DeptHead


54강 Pivot
11강 - Group by
48강 - Derived table and CTE in sql server필요
Pivot은 한 컬럼으로부터의 유니크 값들을 출력의 여러 컬럼들로 바꾸는데 쓰인다. 그로인해 table을 효과적으로 회전시킨다.

SalesAgent SalesCountry SalesAmount
'Tom', 'UK', 200
'John', 'US', 180
'John', 'UK', 260
'David', 'India', 450
'Tom', 'India', 350
'David', 'US', 200
'Tom', 'US', 130
'John', 'India', 540
'John', 'UK', 120
'David', 'UK', 220
'John', 'UK', 420
'David', 'US', 320
'Tom', 'US', 340
'Tom', 'UK', 660
'John', 'India', 430
'David', 'India', 230
'David', 'India', 280
'Tom', 'UK', 480
'John', 'US', 360
'David', 'UK', 140

group by를 사용하여 Total Sales를 처리해본다.
Select SalesCountry, SalesAgent, SUM(SalesAmount) as Total
from tblProductSales
group by SalesCountry, SalesAgent
order by SalesCountry, SalesAgent

SalesCountry SalesAgent SalesAmount
India David 960
India John 970
India Tom 350
UK David 360
UK John 800
UK Tom 1340
US David 520
US John 540
US Tom 470

보기가 상당히 불편하다. cross tab format(?) 으로 바꾸어 출력하자

SalesAgent India US UK
David 860 520 360
John 970 540 800
Tom 350 470 1340


Select SalesAgent, India, US, UK  <= 맨앞이 nonPivoted 컬럼, 나머지가 Pivoted 컬럼
from tblProductSales
Pivot
(
  Sum(SalesAmount) for SalesCountry in ([India],[US],[UK])  <= [India],[US],[UK]에 해당하는 값을 가진 SalesCountry에대해 Sum(SalesAmount)구하고
  Select문이 각 컬럼 별로 Select한다.
) as PivotTable


Id가 추가된 새로운 tblProductsSale를 만들어보자.
Id SalesAgent SalesCountry SalesAmount
1 'Tom', 'UK', 200
2 'John', 'US', 180
3 'John', 'UK', 260
4 'David', 'India', 450
5 'Tom', 'India', 350
6 'David', 'US', 200
7 'Tom', 'US', 130
8 'John', 'India', 540
9 'John', 'UK', 120
10 'David', 'UK', 220
11 'John', 'UK', 420
12 'David', 'US', 320
13 'Tom', 'US', 340
14 'Tom', 'UK', 660
15 'John', 'India', 430
16 'David', 'India', 230
17 'David', 'India', 280
18 'Tom', 'UK', 480
19 'John', 'US', 360
20 'David', 'UK', 140

새로운 테이블에 query를 실행하면
Select SalesAgent, India, US, UK
from tblProductsSale
Pivot
(
   Sum(SalesAmount) for SalesCountry in ([India],[US],[UK])
)
as PivotTable


SalesAgent India US UK
Tom  NULL NULL 200
John NULL 180 NULL
John NULL NULL 260

원하지 않는 결과가 나온다. 이는 PIVOT시 쓰이지 않는 컬럼값이 있으면 이는 pivot출력에 영향을준다.
이를 해결하기 위히 쓰이는 컬럼만 뽑은 derived 컬럼을 사용한다.
Select SalesAgent, India, US, UK
from (
  Select SalesAgent, SalesCountry, SalesAmount
  From tblProductsSale
) as SourceTable
Pivot
(
   Sum(SalesAmount) for SalesCountry in ([India],[US],[UK])
)
as PivotTable


55강 Error handling in sql server 2000
sql server 2000: @@Error system function
sql server 2005 이후 : Try ... Catch

가끔 @@으로 시작하는 시스템함수를 global variable로 부르기도 한다. 하지만 이것들은 variable이 아니며 variable처럼 동작하지도 않는다. 함수와 매우 비슷하다.

product를 파는 기능을 지닌 sp를 만들기 위한 테이블들.

tblProduct
ProductId Name UnitPrice QtyAvailable
1 Laptops 2340 90
2 Desktops 3467 50

tblProductSales
ProductSalesId ProductId QuantitySold
1 1 10
2 1 10



Create Procedure spSellProduct
@ProductId int,
@QuantityToSell int
as
Begin
 -- Check the stock available, for the product we want to sell
 Declare @StockAvailable int
 Select @StockAvailable = QtyAvailable 
 from tblProduct where ProductId = @ProductId
 
 -- Throw an error to the calling application, if enough stock is not available
 if(@StockAvailable < @QuantityToSell)
   Begin
    Raiserror('Not enough stock available',16,1)
   End
 -- If enough stock available
 Else
   Begin
    Begin Tran
      -- First reduce the quantity available
      Update tblProduct set QtyAvailable = (QtyAvailable - @QuantityToSell)
      where ProductId = @ProductId
      
      Declare @MaxProductSalesId int
      -- Calculate MAX ProductSalesId  
      Select @MaxProductSalesId = Case When 
              MAX(ProductSalesId) IS NULL <= 테이블에 아무 데이터도 없을때
              Then 0 else MAX(ProductSalesId) end 
            from tblProductSales
      -- Increment @MaxProductSalesId by 1, so we don't get a primary key violation
      Set @MaxProductSalesId = @MaxProductSalesId + 1
      Insert into tblProductSales values(@MaxProductSalesId, @ProductId, @QuantityToSell)
    Commit Tran
   End
End


Raiserror('Error Message', ErrorSeverity, ErrorState)
throw와 같다.
Severity level = 16(유저에 의해 고쳐질수있는 일반적인 에러))
State = 1-255사이의 숫자. Raiseerror()함수는 1-127까지의 에러만 생성한다.

실행 방법
Execute spSellProduct 1, 10

MaxProductSalesId를 1증가 시키는 부분을 주석처리하여 일부러 에러를 일으켜 보자.
--Set @MaxProductSalesId = @MaxProductSalesId + 1 
PK가 있으므로 PK violation이 날것이다.

Execute spSellProduct 1, 10

tblProduct에서 1이 10개 떨어지지만 일부러 에러를 일으킨 tblProductSales에서는 에러가 난다.
Insert into tblProductSales values(@MaxProductSalesId, @ProductId, @QuantityToSell) 이 문장은 성공 못한다.
data가 inconsistent하게 된다.
tblProduct와 tblProductSales을 다루는 Update, Insert문은 하나의 transaction으로 다루어 져야한다. 두문장 성공하거나
아무것도 성공하지 말아야한다. 하나라도 실패하면 나머지는 롤백되어야 한다. transaction은 다음에 설명하고 @@Error를 사용하여 에러를 검출하자.

Begin Tran
  -- First reduce the quantity available
  Update tblProduct set QtyAvailable = (QtyAvailable - @QuantityToSell)
  where ProductId = @ProductId
  
  Declare @MaxProductSalesId int
  -- Calculate MAX ProductSalesId  
  Select @MaxProductSalesId = Case When 
          MAX(ProductSalesId) IS NULL <= 테이블에 아무 데이터도 없을때
          Then 0 else MAX(ProductSalesId) end 
        from tblProductSales  
  --Set @MaxProductSalesId = @MaxProductSalesId + 1
  Insert into tblProductSales values(@MaxProductSalesId, @ProductId, @QuantityToSell)
  if(@@Error <> 0)  
    rollback transaction
  else
    Commit tran
End

@@Error는 0이 아니면 에러, 0이면 성공이다.
@@Error는 각각의 문이 실행될때 마다 클리어 되고 리셋된다. 문의 실행후 바로 검사하던가 나중에 검사하기 위해 지역변수에 결과를 저장하라.


56강 Error handling in sql server
SQL server 2005 이후 버전
Begin Try
  Begin Tran
    -- First reduce the quantity available
    Update tblProduct set QtyAvailable = (QtyAvailable - @QuantityToSell)
    where ProductId = @ProductId
    
    Declare @MaxProductSalesId int
    -- Calculate MAX ProductSalesId  
    Select @MaxProductSalesId = Case When 
            MAX(ProductSalesId) IS NULL <= 테이블에 아무 데이터도 없을때
            Then 0 else MAX(ProductSalesId) end 
          from tblProductSales  
    --Set @MaxProductSalesId = @MaxProductSalesId + 1
    Insert into tblProductSales values(@MaxProductSalesId, @ProductId, @QuantityToSell)
    Commit Transaction
  End
End Try
Begin Catch
  Rollback Transaction
  Select
    ERROR_NUMBER() as ErrorNumber,  <= Error 정보들을 리턴하는 빌트인 함수들
    ERROR_MESSAGE() as ErrorMessage,
    ERROR_PROCEDURE() as ErrorProcedure,
    ERROR_STATE() as ErrorState,
    ERROR_SEVERITY() as ErrorSeverity,
    ERROR_LINE() as ErrorLine
  End Catch
End Catch

Catch에 잡힌 에러는 호출한 어플리케이션에 return 되지 않는다. 어떠한 에러정보가 어플리케이션에 전달되어야 한다면 Catch블럭안에서
Raiseerror()함수를 사용하라.

Catch 블럭 스코프에서는 에러 정보를 알려주는 시스템 함수들이 있다. 이들 함수는 Catch블럭 바깥에서는 항상 NULL을 리턴한다.
Try/catch는 user-defined function에서는 사용할수 없다.(지금 사용하고 있는곳은 sp임)


57강 Transactions
트랜젝션이란?
데이타베이스에 저장되어 있는 데이타를 바꾸는 명령들의 그룹이다.
트랜젝션은 한개의 유닛으로 다루어진다. 트랜젝션은 모든 명령이 성공하던가 어떠한 명령도 성공하지 않게 보장한다.
트래젝션에 있는 한개의 명령이라도 실패하면 모든 명령이 실패하며 수정된 데이타베이스의 어떠한 데이타도 롤백된다.
이런방식으로 트랜젝션은 데이타베이스에서 데이타의 무결성(integrity of data)을 유지한다.

다음을 입력뒤 실행
Begin Transaction
Update tblProduct set QtyAvailable = 300 where ProductId = 1

New Query를 눌러서 새로운 connection연결
Select * from tblProduct
를 실행하면 응답을 기다리는 상태가 지속되며 화면에 출력되는 것이 없다.
이유는 tranaction을 init한뒤 commit 또는 rollback하지 않았다. 디폴트로 다른 유저들은 uncommitted data를 볼수 없기때문이다.
데이타베이스의 isolation level 이 read committed이기 때문이다. 이는 committed data만 읽을수 있다는 의미이다.
SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED를 설정해 주면 읽을수 있게 된다.



Begin Transaction
Update tblProduct set QtyAvailable = 300 where ProductId = 1
Rollback Transaction 또는 Commit Transaction (Commit Transaction시에 실제 데이타베이스에 기록된다.)


transaction processing은 다음 과정을 따른다.
1. Begin a transaction
2. Process database command
3. Check for Errors
  if errors occurred
    rollback the transaction
  else
    commit the transaction

Create Procedure spUpdateAddress
as
Begin
 Begin Try
  Begin Transaction
   Update tblMailingAddress set City = 'LONDON' 
   where AddressId = 1 and EmployeeNumber = 101
   
   Update tblPhysicalAddress set City = 'LONDON' 
   where AddressId = 1 and EmployeeNumber = 101
  Commit Transaction
 End Try
 Begin Catch
  Rollback Transaction
 End Catch
End


58강 Transactions in sql server and ACID Tests
트랜젝션은 한개의 유닛으로 취급되어지는 데이타베이스 명령의 그룹이다.
성공적인 트랜젝션은 "ACID" test를 통과해야 하며 다음과 같아야 한다.

1.Atomic - 트랜젝션에 있는 모든 문은 전부 성공하거나 전부 롤백되어야한다. 조작의 집한인 일은 완료되거나 완료되지 않은것을 뜻한다.
어떠한 경우에도 반만 된것은 없다.

2.Consistency - 트랜젝션에의해 건드려진 모든 데이타는 논리적으로 consistent sate로 남는다.
예를 들어 tblProductTable에서 QtyAvailable 10개를 차감한뒤 tblProductSales에 10개를 넣을때 어떠한 이유(정전)때문에 tblProductSales에 10개를 넣지 못했을경우
QtyAvailable 10개가 다시 복구 되어야한다.

3.Isolated - 트랜젝션은 다른 동시 트랜잭션들을 방해하거나 다른 트랜잭션들에의해 방해받지 않으며 데이타에 영향을 주어야 한다. 이는 트랜잭션들이 예를 들면 나중에 롤백될 
레코드에 대한 변경같은 uncommitted infomation에 기초해 데이타를 바꾸는 것을 방지한다.
대부분의 database들은 transation isolation을 유지하기 위해 lock을 쓴다.

4.Durable: 변화가 생기면 영구적이다. 명령셋이 완료되기전에 시스템의 파워가 나가도 시스템이 다시 동작했을대 명령들이 취소되고 데이타가 원래의 상태로 복구되는것.


isolation
Select * From tblProduct

Begin Tran
Udpate tblProduct Set QtyAvailable = 350 Where ProductId = 1
실행

새로운 연결2에서
Begin Tran
Select * from tblProduct
Udpate tblProduct Set QtyAvailable = 350 Where ProductId = 1

다른 transaction에서 아직 작업중이기때문에 새로운연결에서 처리되지 않고 앞의 처리가 끝나길 기다린다.

새로운 연결2에서 다음을 실행시키면 실행된다.
Select * From tblProduct Where ProductId = 2 <= 이건 실행된다.
Select * From tblProduct Where ProductId = 1 <= 이건 락걸린다. 행단위로 locking이 걸리는걸 확인



59강 Subqueries
예1)
한개도 팔리지 않은 products를 얻는 query
=> tblProductSales안에 한번도 나타나지 않은 ProductId를 찾자.
Select Id, Name, [Desccription]
From tblProduct
Where Id NOT IN (Select distinct ProductId from tblProductSales) <= ()안에 있으며 단지 1개의 컬럼만 리턴하고 있다.

많은경우 subquery는 join으로 교체 가능하다.
Select tblProduct. Id, Name, [Desccription]

From tblProduct
left join tblProductSales <= left join이므로 tblProducts.Id = tblProductSales.ProductId를 만족하는 행과 만족하지 않는 tblProduct의 행이 모두 들어간다.
on tblProducts.Id = tblProductSales.ProductId

where tblProductSales.ProductId is null <= left join된 결과 테이블에서 tblProductSales.ProductI가 null인 넘이 한대도 안팔린넘.



예2)
Name과 팔린 TotalQuantity를 얻는 query
Select Name, 
(Select SUM(QuantitySold) from tblProductsSales where ProductId = tblProducts.Id) as QtySold <= where절에 주목 tblProducts로 table에 접근하고 있다.(?)
from tblProducts
order by Name

join으로

Select [Name], SUM(QuantitySold) as TotalQuantity
from tblProducts
left join tblProductSales
on tblProducts.Id = tblProductSales.ProductId
group by [Name]
order by Name


subquery는 단순히 1개의 값을 리턴하며(1개의 값이라기 보다는 데이타로 쓰일 값 혹은 값들) SELECT, UPDATE, INSERT, DELETE문안에 포함 될수 있다. 
subquery안에 subquery를 다시 포함할수도 있다. 32단계까지 포함가능.

subquery 는 항상 괄호로 감싸여지며 inner query라고 불리기도한다. subquery를 포함하는 query를 outer query라 부른다. subquery안에만 있는 테이블로부터의 컬럼은
outer query의 Select list에서 쓰여질수 없다.

퍼포먼스를 위해 어떤 방법을 선택해야하는가? subquery or join

60강 Correlated subquery

noncorrelated subquery
Select Id, Name, [Desccription]
From tblProduct
Where Id NOT IN (Select distinct ProductId from tblProductSales)

(Select distinct ProductId from tblProductSales)은 outer query에 의존하지 않기때문에 단독 실행 가능하다.
noncorrelated subquery는 단 한번만 실행된다.

correlated subquery
만약 subquery가 outer query에 값을 의존할때 subquery를 correlated subquery라 부른다.
아래 예의 tblProducts.Id가 outer query에 있는 tblProducts에 의존하고 있다.

Select Name, 
(Select SUM(QuantitySold) from tblProductsSales where ProductId = tblProducts.Id) as QtySold
from tblProducts
order by Name

correlated subquery는 outer query에 의해 select되는 모든 행들에대해 한번씩 실행된다.
correlated subquery는 독립적으로 실행될수 없다.


61강 Creating a large table with random data for performance testing

-- If Table exists drop the tables
If (Exists (select * 
            from information_schema.tables 
            where table_name = 'tblProductSales'))
Begin
 Drop Table tblProductSales
End

If (Exists (select * 
            from information_schema.tables 
            where table_name = 'tblProducts'))
Begin
 Drop Table tblProducts
End

-- Recreate tables
Create Table tblProducts
(
 [Id] int identity primary key,
 [Name] nvarchar(50),
 [Description] nvarchar(250)
)

Create Table tblProductSales
(
 Id int primary key identity,
 ProductId int foreign key references tblProducts(Id),
 UnitPrice int,
 QuantitySold int
)

--Insert Sample data into tblProducts table
Declare @Id int
Set @Id = 1

While(@Id <= 300000)
Begin
 Insert into tblProducts values('Product - ' + CAST(@Id as nvarchar(20)), 
 'Product - ' + CAST(@Id as nvarchar(20)) + ' Description')
 
 Print @Id
 Set @Id = @Id + 1
End

-- Declare variables to hold a random ProductId, 
-- UnitPrice and QuantitySold
declare @RandomProductId int
declare @RandomUnitPrice int
declare @RandomQuantitySold int

-- Declare and set variables to generate a 
-- random ProductId between 1 and 100000
declare @UpperLimitForProductId int
declare @LowerLimitForProductId int

set @LowerLimitForProductId = 1
set @UpperLimitForProductId = 100000

-- Declare and set variables to generate a 
-- random UnitPrice between 1 and 100
declare @UpperLimitForUnitPrice int
declare @LowerLimitForUnitPrice int

set @LowerLimitForUnitPrice = 1
set @UpperLimitForUnitPrice = 100

-- Declare and set variables to generate a 
-- random QuantitySold between 1 and 10
declare @UpperLimitForQuantitySold int
declare @LowerLimitForQuantitySold int

set @LowerLimitForQuantitySold = 1
set @UpperLimitForQuantitySold = 10

--Insert Sample data into tblProductSales table
Declare @Counter int
Set @Counter = 1

While(@Counter <= 450000)
Begin
 select @RandomProductId = Round(((@UpperLimitForProductId - @LowerLimitForProductId) * Rand() + @LowerLimitForProductId), 0)
 select @RandomUnitPrice = Round(((@UpperLimitForUnitPrice - @LowerLimitForUnitPrice) * Rand() + @LowerLimitForUnitPrice), 0)

 select @RandomQuantitySold = Round(((@UpperLimitForQuantitySold - @LowerLimitForQuantitySold) * Rand() + @LowerLimitForQuantitySold), 0)
 
 Insert into tblProductsales 
 values(@RandomProductId, @RandomUnitPrice, @RandomQuantitySold)

 Print @Counter
 Set @Counter = @Counter + 1
End


62강 What to choose for performance SubQuery or Joins
MSDN에 따르면 대부분의 경우 sql server에서 subquery를 사용하는 query와 join을 사용하는 query간의 퍼포먼스 차이는 없다.

다음의 코드로 query실행시마다 query와 execution plan 캐시를 지우고 테스트한다.
CHECKPOINT; 
GO 
DBCC DROPCLEANBUFFERS; -- Clears query cache
Go
DBCC FREEPROCCACHE; -- Clears execution plan cache
GO

Name과 팔린 TotalQuantity를 얻는 query
Select Name, 
(Select SUM(QuantitySold) from tblProductsSales where ProductId = tblProducts.Id) as QtySold <= where절에 주목 tblProducts로 table에 접근하고 있다.(?)
from tblProducts
order by Name

join으로

Select [Name], SUM(QuantitySold) as TotalQuantity
from tblProducts
left join tblProductSales
on tblProducts.Id = tblProductSales.ProductId
group by [Name]
order by Name

다시 MSDN에 따르면 existence가 check되어야하는 몇가지 경우 join이 더 나은 퍼포먼스를 보여준다고 한다. 아니면 nested query가 outer query 각각의 결과에
대해 처리 되어야 하는경우 join이 더 나은 결과를 보여준다고 한다.

일반적으로 join이 subquery보다 빠르다. 하지만 실제는 sql server에 의해 생성되어지는 execution plan에 전적으로 의존한다.
우리가 query를 어떻게 썼는지는 전혀 중요하지 않으며 sql server가 query를 execution plane으로 항상 변환한다.
양쪽의 query가 똑같은 plan을 생성할 정도로 똑똑하다면 같은 결과를 얻을것이다.

이론적으로 하기보다는 각각의 옵션 퍼포먼스를 보기위해 client statistics와 execution plan을 켜고 확인뒤 결정하길바란다.(버튼이 있으며 query실행뒤 결과창에 같이 뜬다.)


63강 Cursors
관계형 데이타 매니지먼트 시스템은 SET들에 있는 데이타를 다루는데 아주 뛰어나다.
예를 들면 다음과 같은 "Update" query는 WHERE절에있는 조건에 매치되는 행들의 셋을 동시에 update한다.
Update tblProductsales Set UnitPrice = 50 where ProductId = 101

하지만 행들을 행단위로 처리할 필요가 있을때가 있으며 그때가 cursor가 필요할때이다. cursor는 퍼포먼스에 아주 안좋으며 항상 피해야한다.
대부분의 경우 cursor는 join으로 쉽게 대체 가능하다.

(대강 이터레이터로 생각하면될듯...)

4가지 타입의 cursor가 있다. 나중에 살펴본다.
1.Forward-only
2.Static
3.Keyset
4.Dynamic

Declare @ProductId int

-- Declare the cursor using the declare keyword
Declare ProductIdCursor CURSOR FOR 
Select ProductId from tblProductSales

-- Open statement, executes the SELECT statment
-- and populates the result set
Open ProductIdCursor

-- Fetch the row from the result set into the variable
Fetch Next from ProductIdCursor into @ProductId

-- If the result set still has rows, @@FETCH_STATUS will be ZERO
While(@@FETCH_STATUS = 0)
Begin
 Declare @ProductName nvarchar(50)
 Select @ProductName = Name from tblProducts where Id = @ProductId
 
 if(@ProductName = 'Product - 55')
 Begin
  Update tblProductSales set UnitPrice = 55 where ProductId = @ProductId
 End
 else if(@ProductName = 'Product - 65')
 Begin
  Update tblProductSales set UnitPrice = 65 where ProductId = @ProductId
 End
 else if(@ProductName like 'Product - 100%')
 Begin
  Update tblProductSales set UnitPrice = 1000 where ProductId = @ProductId
 End
 
 Fetch Next from ProductIdCursor into @ProductId 
End

-- Release the row set
CLOSE ProductIdCursor 
-- Deallocate, the resources associated with the cursor
DEALLOCATE ProductIdCursor


60000개의 행들을 행단위 순차처리를 했을때 45초 결렸다. join을 사용하게 되면 엄청난 퍼포먼스 증가를 얻을수있다.


64강 Replacing cursors using joins

Update tblProductSales
set UnitPrice = 
 Case 
  When Name = 'Product - 55' Then 155
  When Name = 'Product - 65' Then 165
  When Name like 'Product - 100%' Then 10001
 End     
from tblProductSales
join tblProducts
on tblProducts.Id = tblProductSales.ProductId
Where Name = 'Product - 55' or Name = 'Product - 65' or 
Name like 'Product - 100%'

cursor 사용시 45초 소모되던것이 3초 소모. 켜서의 사용은 마지막 선택이어야 한다!.

Where절을 없애면 모든 행에 대해 실행되며 조금 느려진다. Case문 사용 주의 할것!. Case의 When에 걸리는 것이 없으면 NULL 리턴되므로 원래 값을 넘긴다.

5초정도 소모. 모든 행에 대해 실행되어서..
Update tblProductSales
set UnitPrice = 
 Case 
  When Name = 'Product - 55' Then 155
  When Name = 'Product - 65' Then 165
  When Name like 'Product - 100%' Then 10001
  Else
  UnitPrice
 End     
from tblProductSales
join tblProducts
on tblProducts.Id = tblProductSales.ProductId


65강 List all tables in a sql server database using a query 
SSMS에 있는 object explorer에서는 특정 데이타베이스의 모든 테이블들을 볼수있다. 이 기능을 어떻게 query로 만드는가?
3가지 system view가 있다.
1.SYSOBJECTS - sql server 2000, 2005, 2008
2.SYS.TABLES - 2005이상
3.INFOMATION_SCHEMA.TABLES - 2005이상


Select * From sysobjects <= 모든 object를 보여준다. table, view, procedure등
Select * From sysobjects where xtype = 'U' <= table만 보여준다. U:Usertable, FN:Scalar function, P:Stored Procedure, V:View, xtype을 보려면 msdn으로!
Select distinct xtype from systobjects <= 현재 있는 distinct xtype출력

Select * From sys.tables
Select * From sys.views
Select * From sys.procedures

Select * From INFOMATION_SCHEMA.TABLES <= table과 view
Select * From INFOMATION_SCHEMA.VIEWS
Select * From INFOMATION_SCHEMA.ROUTINES <= function, porcedure (ROUTINE_TYPE으로 골라 내라)


66강 Writing re-runnable sql server scripts Part 66  <= 인터뷰 질문에 잘나온다.
re-runnable script? 1번 이상 실행시켰을때 에러를 던지지 않는 스크립트.

USE [Sample] <= Sample 데이타베이스에서 작업하라!
Create table tblEmployee
(
 ID int identity primary key,
 Name nvarchar(100),
 Gender nvarchar(10),
 DateOfBirth DateTime
)

re-runnable하게 만드려면
1.table의 존재를 체크
2.존재하지 않으면 생성
3.존재하면 테이블이 이미 있다고 메세지 출력


Use [Sample]
If not exists (select * from information_schema.tables where table_name = 'tblEmployee')
Begin
 Create table tblEmployee
 (
  ID int identity primary key,
  Name nvarchar(100),
  Gender nvarchar(10),
  DateOfBirth DateTime
 )
 Print 'Table tblEmployee successfully created'
End
Else
Begin
 Print 'Table tblEmployee already exists'
End


내장함수 OBJECT_ID()가 존재여부를 확인하는데 쓰일수 있다.
IF OBJECT_ID('tblEmployee') IS NULL
Begin
   -- Create Table Script
   Print 'Table tblEmployee created'
End
Else
Begin
   Print 'Table tblEmployee already exists'
End

재생성 샘플
Use [Sample]
IF OBJECT_ID('tblEmployee') IS NOT NULL
Begin
 Drop Table tblEmployee
End
Create table tblEmployee
(
 ID int identity primary key,
 Name nvarchar(100),
 Gender nvarchar(10),
 DateOfBirth DateTime
)



Use [Sample]
ALTER TABLE tblEmployee
ADD EmailAddress nvarchar(50)

컬럼 체크를 통해 재실행 가능 스크립트 생성
Use [Sample]
if not exists(Select * from INFORMATION_SCHEMA.COLUMNS where COLUMN_NAME='EmailAddress' and TABLE_NAME = 'tblEmployee' and TABLE_SCHEMA='dbo') 
<= table이름뿐만이 아니라 TABLE_SCHEMA까지 확인하고 있다. tblEmployee가 스키마마다 있을수 있으니...
Begin
 ALTER TABLE tblEmployee
 ADD EmailAddress nvarchar(50)
End
Else
BEgin
 Print 'Column EmailAddress already exists'
End

col_length()함수로 컬럼의 유무를 체크!
If col_length('tblEmployee','EmailAddress') is not null
Begin
 Print 'Column already exists'
End
Else
Begin
 Print 'Column does not exist'
End



67강 Alter database table columns without dropping table
Salary colume의 속성을 nvarchar(20)에서 int로 바꾸고 싶다.
Design을 통해 바꾸면 에러가 난다.
 Saving changes is not permitted. ...

테이블 drop, recreate, populates data를 다시 하지않고 컬럼 정의를 바꿀수 있는 방법

1.sql query를 써라
Alter table tblEmployee
Alter column Salary int

2."Prevent saving changes that require table re-creation" 옵션을 끄면 design에서 바꿀수 있다.


68강 Optional parameters in sql server stored procedures
Create Proc spSearchEmployees
@Name nvarchar(50) = NULL, <= 파라메터에 default값을 넣어준다.
@Email nvarchar(50) = NULL,
@Age int = NULL,
@Gender nvarchar(50) = NULL
as
Begin
 Select * from tblEmployee where
 (Name = @Name OR @Name IS NULL) AND  <= @Name이 Null이 들어올 경우 true가 된다. 아무런 파라메터를 안넣어주면 모든 데이타 출력된다.
 (Email = @Email OR @Email IS NULL) AND
 (Age = @Age OR @Age IS NULL) AND
 (Gender = @Gender OR @Gender IS NULL) 
End

Execute spSearchEmployees <= 모든행 출력
Execute spSearchEmployees @Gender = 'Male' <= Male만 출력
Execute spSearchEmployees @Gender = 'Male', @Age = 29 

asp 사용해서 호출하는 예제 스킵!


https://www.red-gate.com/simple-talk/sql/t-sql-programming/questions-about-t-sql-transaction-isolation-levels-you-were-too-shy-to-ask
69강 sql server concurrent transactions
같은 시간에 같은 데이타로 작업하게되는 2개 이상의 transaction들은 concurrency 이슈를 발생시킨다.

common concurrency problem (나중에 설명)
1.Dirty Reads
2.Lost Updates
3.Nonrepeatable Reads
4.Phantom Reads

이를 해결 하는 방법은 어떠한 경우든 1개의 트랜젝션만 실행되게 하는것이다. 모든 트랜젝션이 큐잉되고 다른 트랜젝션이 완료되기전까지
오래 기다려야 할지도 모른다. 만약 이런식으로 serialize access를 하게되면 나쁜 퍼포먼스를 보이게 된다.

sql server는 concurrency문제와 퍼포먼스의 벨런싱을 위해 몇가지 transaction isolation levels을 제공한다.
1.Read Uncommitted
2.Read Committed
3.Repeatable Read
4.Snapshot
5.Serializable

트랜젝션에서 선택한 isolation level에 따라 동시성 문제와 퍼포먼스의 문제가 다양해지게 된다.

Isolation Level	/Dirty Reads	/Lost Update	/Nonrepeatable Reads	/Phantom Reads
Read Uncommitted Y Y Y Y
Read Committed N Y Y Y
Repeatable Read N N N Y
Snapshot N N N N
Serializable N N N N

가장 낮은 Read Uncommitted을 선택하면 동시 트랜젝션의 갯수가 늘어나지만 모든 동시성문제를 갖게된다.
가장 높은 Isolation level을 선택하면 동시성 문제가 없어지지만 같은 데이타에서 발생하는 동시 트랜젝션의 수가 적어진다.

71강 sql server dirty read example
dirty read (uncommitted data read) : 한 트랜젝션이 다른 트랜젝션이 아직 커밋하지 않은 데이타를 읽도록 허가 되었을때 일어난다.
대부분의 경우 별로 문제가 되지 않는다. 그러나 첫 트랜젝션이 롤백되었을때 두번째 트랜젝션은 더이상 존재하지 않는 dirty data를 갖고 있게 된다.

Transaction 1 : 
Begin Tran
Update tblInventory set ItemsInStock = 9 where Id=1

-- Billing the customer
Waitfor Delay '00:00:15'
-- Insufficient Funds. Rollback transaction

Rollback Transaction

Transaction 2 :
Set Transaction Isolation Level Read Uncommitted
Select * from tblInventory where Id=1

Read Uncommitted transaction isolation level은 dirty read side effect를 가지고 있는 유일한 isolation level이다.
모든 isolation level중 가장 약하다. Read Uncommitted로 설정되어 있을때 dirty data를 읽을수있다.
dirty data를 읽을수 있는 다른 방법은 NOLOCK table hint를 사용하는것이다.

Select * from tblInventory (NOLOCK) where Id=1


72강 sql server lost update problem
lost update problem : 2개의 트랜젝션이 같은데이타를 읽고 쓸때 일어난다.

-- Transaction 1
Begin Tran
Declare @ItemsInStock int

Select @ItemsInStock = ItemsInStock
from tblInventory where Id=1

-- Transaction takes 10 seconds
Waitfor Delay '00:00:10'
Set @ItemsInStock = @ItemsInStock - 1

Update tblInventory
Set ItemsInStock = @ItemsInStock where Id=1

Print @ItemsInStock

Commit Transaction


-- Transaction 2
Begin Tran
Declare @ItemsInStock int

Select @ItemsInStock = ItemsInStock
from tblInventory where Id=1

-- Transaction takes 1 second
Waitfor Delay '00:00:1'
Set @ItemsInStock = @ItemsInStock - 2

Update tblInventory
Set ItemsInStock = @ItemsInStock where Id=1

Print @ItemsInStock

Commit Transaction

트랜젝션1을 실행시키고 트랜젝션2를 실행시키면 9가 된다. 트랜젝션2의 update가 1에의해 덮어써진다.
Read Uncommitted, Read Committed transaction isolation level 2개는 lost update problem을 가지고 있다.
Repeatable Read, Snapshot, and Serializable isolation level은 위의 side effect를 가지고 있지 않다.
Repeatable Read는 추가적으로 table의 행에 lock을 걸어 다른곳에서 update, delete되는 것을 막는다. 이는 lost update problem을 해결한다.

위의 transaction을 순서대로 실행시키면 2번째 트랜젝션이 에러를 내며 종료된다.
Transaction was deadlocked on lock resources with another process and has been chosen as the deadlock victim. Rerun the transaction.


73강 Non repeatable read example
Non repeatable read problem은 한 트랜젝션이 같은 data를 2번 읽을때 다른 트랜잭션이 첫번째 트랜젝션의 첫번째와 두번째 read사이에 Update를 할때
나타난다.
-- Transaction 1
Begin Transaction
Select ItemsInStock from tblInventory where Id = 1

-- Do Some work
waitfor delay '00:00:10'

Select ItemsInStock from tblInventory where Id = 1
Commit Transaction

-- Transaction 2
Update tblInventory set ItemsInStock = 5 where Id = 1

Repeatable read 보다 높은 레벨의 isolation level은 non-repeatable read problem을 해결한다.
non-repeatable read problem을 해결하기 위해 트랜젝션1에 Set transaction isolation level repeatable read을 한다.
이를통해 트랜젝션1이 읽은 데이타가 update, delete되는 것을 방지한다.

-- Transaction 1
Set transaction isolation level repeatable read
Begin Transaction
Select ItemsInStock from tblInventory where Id = 1

-- Do Some work
waitfor delay '00:00:10'

Select ItemsInStock from tblInventory where Id = 1
Commit Transaction

-- Transaction 2
Update tblInventory set ItemsInStock = 5 where Id = 1

트랜젝션2는 트랜젝션1이 끝날때까지 block된다.


74강 Phantom reads example
Phantom read는 한 트랜젝션이 같은 query를 2번 실행했을때 각각 결과가 다른 행의 수를 갖는것을 말한다.
두번째 트랜젝션이 첫번째 트랜젝션에의해 실행된 WHERE절과 일치하는 새로운 행을 insert했을때 발생한다.
-- Transaction 1
Begin Transaction
Select * from tblEmployees where Id between 1 and 3
-- Do Some work
waitfor delay '00:00:10'
Select * from tblEmployees where Id between 1 and 3
Commit Transaction

-- Transaction 2
Insert into tblEmployees values(2, 'Marcus')

트랜젝션1을 Serializable로 맞추면 해결된다. 트랜젝션1이 끝날때까지 트랜젝션2는 block된다.
-- Transaction 1
Set transaction isolation level serializable
Begin Transaction
Select * from tblEmployees where Id between 1 and 3
-- Do Some work
waitfor delay '00:00:10'
Select * from tblEmployees where Id between 1 and 3
Commit Transaction

-- Transaction 2
Insert into tblEmployees values(2, 'Marcus')

repeatable read 와 serializable의 차이점
repeatable read은 단지 non-repeatable read만을 막을뿐이다. repeatable read는 트랜젝션이 읽은 data가 Update, delete되는 것만 막지 새로운
행이 추가되는것을 막지 못한다.

serializable은 non-repeatable read과 phantom read problem을 막는다.


75강 Snapshot isolation level
serializable과 snapshot isolation level의 차이점
serializable은 lock을 사용해서 구현되었다. 즉 트랜젝션동안 리소스들이 lock이 걸린다. concurrency side effect는 없지만 lock으로인해
상당한 cost를 치루게된다.
snapshot은 lock을 사용하지 않는다. Tempdb에 버전을 유지한다. lock을 사용하지 않기때문에 serializable보다 많은 동시트랜젝션을 처리할수있다.

--Transaction 1
Set transaction isolation level serializable
Begin Transaction
Update tblInventory set ItemsInStock = 5 where Id = 1
waitfor delay '00:00:10'
Commit Transaction

-- Transaction 2
Set transaction isolation level serializable
Select ItemsInStock from tblInventory where Id = 1

serializable에서는 트랜젝션2가 block된다.

트랜젝션2의 isolation level을 snapshot으로 바꾸어보자.
snapshot isolation level을 사용하기 위해서는 첫째 database level에서 enabled되어야 하고 snapshot isolation level을 지정해야한다.

-- Transaction 2
-- Enable snapshot isloation for the database
Alter database SampleDB SET ALLOW_SNAPSHOT_ISOLATION ON
-- Set the transaction isolation level to snapshot
Set transaction isolation level snapshot
Select ItemsInStock from tblInventory where Id = 1

트랜젝션2는 block되지 않으며 트랜젝션1이 실행되기 전의 data를 출력해준다.

snapshot isolation level에서의 modifying
snapshot isolation level을 쓰는 트랜젝션에서 같은 데이타를 동시에 update하려 할때 어떤일이 일어나는가?
트랜젝션1이 실행되고 트랜젝션2가 같은 데이타를 업데이트 하려할때 block이 걸리며 트랜젝션1이 종료되면 트랜젝션2가 에러를 출력한다.(Lost Update방지)
Snapshot isolation transaction aborted due to update conflict. 
You cannot use snapshot isolation to access table 'dbo.tblInventory' directly or indirectly in database 'SampleDB' 
to update, delete, or insert the row that has been modified or deleted by another transaction. 
Retry the transaction or change the isolation level for the update/delete statement.
트랜젝션2가 작업을 완료하기를 원한다면 다시 실행시켜야한다.

--Transaction 1
Set transaction isolation level serializable
Begin Transaction
Update tblInventory set ItemsInStock = 5 where Id = 1
waitfor delay '00:00:10'
Commit Transaction

-- Transaction 2
-- Enable snapshot isloation for the database
--Alter database SampleDB SET ALLOW_SNAPSHOT_ISOLATION ON <= 한번만 하면 된다.
-- Set the transaction isolation level to snapshot
Set transaction isolation level snapshot
Update tblInventory set ItemsInStock = 8 where Id = 1


76강 Read committed snapshot isolation level
Read committed snapshot isolation level은 다른 별도의 isolation level이 아니다.
Read committed isolation level의 다른 구현 방법이다. 
Read committed isolation level의 문제점은 다른 트랜젝션이 Update하려는 데이타를 동시에 read하려할때 block된다는 것이다.

--Transaction 1
Set transaction isolation level Read Committed
Begin Transaction
Update tblInventory set ItemsInStock = 5 where Id = 1
waitfor delay '00:00:10'
Commit Transaction

-- Transaction 2
Set transaction isolation level read committed
Begin Transaction
Select ItemsInStock from tblInventory where Id = 1
Commit Transaction

트랜젝션1을 실행뒤 트랜젝션2를 실행하면 트랜젝션2가 block되는 것을 확인할수 있다.

database level에서 Read committed snapshot isolation을 활성화 하는것으로 트랜젝션2가 row의 lock대신 row versionning 테크닉을
쓸수있게 할수있다.

다음을 써서 READ_COMMITTED_SNAPSHOT isolation을 쓸수있다.
Alter database SampleDB SET READ_COMMITTED_SNAPSHOT ON
주의: 위의 query는 다른 커넥션이 없을때만 실행된다. 아니면 block된다.

READ_COMMITTED_SNAPSHOT을 켜고 같이 테스트를 하면 트랜젝션2는 block되지 않고 트랜젝션1이 실행되기 이전의 data를 리턴한다.
이는 트랜젝션2가 READ_COMMITTED_SNAPSHOT을 사용하기 때문이다.

같은 것을 Read committed snapshot isolation대신 snapshot isolation level로 가능한지 확인해보자.
Step 1 : Turn off READ_COMMITTED_SNAPSHOT
Alter database SampleDB SET READ_COMMITTED_SNAPSHOT OFF

Step 2 : Enable snapshot isolation level at the database level
Alter database SampleDB SET ALLOW_SNAPSHOT_ISOLATION ON

--Transaction 1
Set transaction isolation level Read Committed
Begin Transaction
Update tblInventory set ItemsInStock = 5 where Id = 1
waitfor delay '00:00:10'
Commit Transaction

-- Transaction 2
Set transaction isolation level snapshot
Begin Transaction
Select ItemsInStock from tblInventory where Id = 1
Commit Transaction

Read committed snapshot isolation level을 사용했을때와 결과가 같다.
그렇다면 Read committed snapshot isolation level과 snapshot isolation level의 차이점은 무엇인가?


77강 Difference between snapshot isolation and read committed snapshot

Read committed snapshot isolation           Snapshot Isolation
No Update conflict                          Vulnerable to update conflict
application 수정이 필요없이 동작              application 수정이 필요할지도 모른다.
distributed transaction에 쓰일수 있다         distributed transaction에 쓰일수 없다.
statement-level read consistency             transaction-level read consistency

Update conflicts : Snapshot Isolation은 update conflict에 취약지만 Read committed snapshot isolation은 그렇지 않다.
snapshot isolation일때 다른 트랜젝션이 이미 업데이트한 데이타를 동시에 업데이트하려할때 update conflict가 발생하며
트랜젝션은 종료되고 에러와 함께 롤백된다.

Alter database SampleDB SET ALLOW_SNAPSHOT_ISOLATION ON

--Transaction 1
Set transaction isolation level snapshot
Begin Transaction
Update tblInventory set ItemsInStock = 8 where Id = 1
waitfor delay '00:00:10'
Commit Transaction

-- Transaction 2
Set transaction isolation level snapshot
Begin Transaction
Update tblInventory set ItemsInStock = 5 where Id = 1
Commit Transaction


트랜젝션2가 트랜젝션1이 끝날때까지 block되었다가 트랜젝션1이 완료될때 트랜젝션2가 update conflict를 발생시키며 에러와함께 롤백된다.


Read Committed Sanpshot Isolation

Alter database SampleDB SET ALLOW_SNAPSHOT_ISOLATION OFF
Alter database SampleDB SET READ_COMMITTED_SNAPSHOT ON

--Transaction 1
Set transaction isolation level read committed
Begin Transaction
Update tblInventory set ItemsInStock = 8 where Id = 1
waitfor delay '00:00:10'
Commit Transaction

-- Transaction 2
Set transaction isolation level read committed
Begin Transaction
Update tblInventory set ItemsInStock = 5 where Id = 1
Commit Transaction

트랜젝션2가 트랜젝션1이 끝날때까지 block되었다가 트랜젝션1이 완료될때 트랜젝션2가 완료된다.

application 수정: 만약 기존에 작성한 코드가 default Read Committed isolation라면 기존의 코드에 수정없이
Read Committed Snapshot Isolation로 쉽게 바꿀수 있다. READ_COMMITTED_SNAPSHOT으로 database를 세팅하면된다.
이 세팅은  read committed isolation이 committed data read시 row versionning을 사용하게 한다.

Distributed transactions: read committed isolation은 분산트랜젝션에 사용가능하지만 snapshot isolation은 불가능하다.

Read consistency: read committed isolation은 statement-level read consistency이지만 snapshot isolation은 transaction-level이다.

read committed isolation
Alter database SampleDB SET ALLOW_SNAPSHOT_ISOLATION OFF
Alter database SampleDB SET READ_COMMITTED_SNAPSHOT ON

Select * From tblInventory Where Id = 1
--10

--Transaction 1
Set transaction isolation level read committed
Begin Transaction
Update tblInventory set ItemsInStock = 8 where Id = 1


-- Transaction 2
Set transaction isolation level read committed
Begin Transaction
Select * From tblInventory Where Id = 1
--10


-- Transaction1
Commit Transaction --트랜젝션 완료!

-- Transaction2
Select * From tblInventory Where Id = 1
--8 <= statement level
Commit Transaction

snapshot isolation
Alter database SampleDB SET READ_COMMITTED_SNAPSHOT OFF
Alter database SampleDB SET ALLOW_SNAPSHOT_ISOLATION ON

Select * From tblInventory Where Id = 1
--10

--Transaction 1
Set transaction isolation level read committed
Begin Transaction
Update tblInventory set ItemsInStock = 8 where Id = 1


-- Transaction 2
Set transaction isolation level read committed
Begin Transaction
Select * From tblInventory Where Id = 1
--10


-- Transaction1
Commit Transaction --트랜젝션 완료!

-- Transaction2
Select * From tblInventory Where Id = 1
--10 <= transaction level
Commit Transaction
Select * From tblInventory Where Id = 1
--8



78강 SQL Server deadlock example
deadlock이 발생하면 한 프로세스를 deadlock victim으로 선택하고 롤백시킨다.
Msg 1205, Level 13, State 51, Line 1
Transaction (Process ID 57) was deadlocked on lock resources with another process and has been chosen as the deadlock victim. Rerun the transaction.

-- Transaction 1
Begin Tran
Update TableA Set Name = 'Mark Transaction 1' where Id = 1
-- From Transaction 2 window execute the first update statement
Update TableB Set Name = 'Mary Transaction 1' where Id = 1
-- From Transaction 2 window execute the second update statement
Commit Transaction


-- Transaction 2
Begin Tran
Update TableB Set Name = 'Mark Transaction 2' where Id = 1
-- From Transaction 1 window execute the second update statement
Update TableA Set Name = 'Mary Transaction 2' where Id = 1
-- After a few seconds notice that one of the transactions complete
-- successfully while the other transaction is made the deadlock victim
Commit Transaction


79강 SQL Server deadlock victim selection
sql server는 어떻게 deadlock을 감지하는가?
Lock monitor thread가 디폴트로 5초에 한번씩 deadlock이 있는지 없는지 감지하기 위해 실행된다.
deadlock을 발견하면 deadlock detection interval이 deadlock 빈도에따라 5초에서 100밀리초까지 줄어든다.
deadlock이 발생하지 않으면 데이타베이스 엔진은 서치 빈도를 5초까지 점점 다시 늘린다.

deadlock이 감지되면 어떻게 되나?
감지되면 쓰레드들중 하나를 deadlock victim으로 골라 deadlock을 끝낸다.
deadlock victim은 롤백되고 1205에러를 application에 리턴한다. 롤백은 deadlock victim이 가지고 있던 모든 lock을
릴리즈하며 다른 트랜잭션이 unblock되어 진행할수있게 한다.

DEADLOCK_PRIORITY란?
디폴트로 데이타베이스엔진은 롤백비용이 적은 것을 deadlock victim으로 선정한다.
하지만 SET DEADLOCK_PRIORITY문을 통해 우선순위를 정할수 있다.

SET DEADLOCK_PRIORITY Normalized

DEADLOCK_PRIORITY
1. 디폴트는 Normal
2. LOW, NORAML, HIGH가 있다.
3. -10 - 10 사이의 int
LOW: -5 NORAML: 0 HIGH: 5

deadlock victim 선정 기준
1. DEADLOCK_PRIORITY가 다르다면 가장 낮은 것을 선정
2. 우선순위가 같다면 롤백 비용이 가장 적은것을 선정
3. 1,2가 같다면 랜덤하게 선택


80강 Logging deadlocks in sql server

To turn on the trace flag
DBCC Traceon(1222, -1) -- -1: global 없으면 session

To check the status of the trace flag
DBCC TraceStatus(1222, -1)

To turn off the trace flag
DBCC Traceoff(1222, -1)


Create procedure spTransaction1
as
Begin
    Begin Tran
    Update TableA Set Name = 'Mark Transaction 1' where Id = 1
    Waitfor delay '00:00:05'
    Update TableB Set Name = 'Mary Transaction 1' where Id = 1
    Commit Transaction
End

Create procedure spTransaction2
as
Begin
    Begin Tran
    Update TableB Set Name = 'Mark Transaction 2' where Id = 1
    Waitfor delay '00:00:05'
    Update TableA Set Name = 'Mary Transaction 2' where Id = 1
    Commit Transaction
End

execute sp_readerrorlog <= 에러로그 보기


81강 SQL Server deadlock analysis and prevention
error log는 3가지 section으로 이루어져있다.
Deadlock Victim: deadlock victim으로 선택되어 죽은 process ID를 포함한 정보
Process-List: 데드락에 참여된 프로세스들의 리스트를 포함한다.
Resource-List: 데드락에 연관된 프로세스들에의해 소유되어진 리소스(database objects)들의 리스트를 포함한다.

Process-List안의 정보
loginname
isolationlevel
procedure_name
inputbuf: 데드락이 발생했을때 실행중인 프로세스의 코드

Resource-List안의 정보
objectname: 데드락에 얽힌 리소스 이름
owner-list: owner id와 리스스의 lock mode가 있다. lockmode는 동시트랜젝션에서 리소스가 어떻게 접근되어질지를 결정한다.
S=> Shared lock, U=> Update lock, X => Exclusive lock등
waiter-list: lock을 얻고 싶어하는 process id와 mode


82강 Capturing deadlocks in sql profiler

1.sql profiler : tool메뉴에 있다. 실행
2.profiler가 뜨면 file/new trace로 database connect
3.general 탭에서 use the template을 blank로 설정
4.Events Selection탭 Locks>Deadlock graph 체크
5.Run 클릭
6.deadlock이 발생하면 profiler에 그래프가 뜬다.

deadlock graph data는 xdl확장자를 가진 xml이다. File - Export - Extract SQL Server Events - Extract Deadlock Events메뉴에서 export할수 있다.
graph는 대부분 보면 알수 있다.

Log Used: 트랜젝션이 사용한 log space. 많을수록 롤백 코스트가 크다. 적은쪽이 kill된다.
HoBt ID : Heap Or Binary Tree ID. 이 id를 사용하여 sys.partitions view에 deadlock에 얽힌 data objects를 찾기위해 query할수있다.

SELECT object_name([object_id])
FROM sys.partitions
WHERE hobt_id = 72057594041663488


83강 SQL Server deadlock error handling
try catch로 감싸서 error 처리

Alter procedure spTransaction1
as 
Begin 
    Begin Tran
    Begin Try 
         Update TableA Set Name = 'Mark Transaction 1' where Id = 1 
         Waitfor delay '00:00:05' 
         Update TableB Set Name = 'Mary Transaction 1' where Id = 1 
         -- If both the update statements succeeded.
         -- No Deadlock occurred. So commit the transaction.
         Commit Transaction
         Select 'Transaction Successful'   
    End Try
    Begin Catch
         -- Check if the error is deadlock error
         If(ERROR_NUMBER() = 1205)
         Begin
             Select 'Deadlock. Transaction failed. Please retry'
         End
         -- Rollback the transaction
         Rollback
    End Catch   
End

Alter procedure spTransaction2 
as 
Begin 
    Begin Tran
    Begin Try
         Update TableB Set Name = 'Mary Transaction 2' where Id = 1
         Waitfor delay '00:00:05'
         Update TableA Set Name = 'Mark Transaction 2' where Id = 1
         Commit Transaction
         Select 'Transaction Successful'   
    End Try
    Begin Catch
         If(ERROR_NUMBER() = 1205)
         Begin
             Select 'Deadlock. Transaction failed. Please retry'
        End
         Rollback
    End Catch   
End


84강 Handling deadlocks in ado net
//try catch롤 써서 asp.net c#에서 database의 예외를 잡는다. 걍 보기만 하자...
protected void Button1_Click(object sender, EventArgs e)
  {
      try
      {
          string cs = ConfigurationManager.ConnectionStrings["DBCS"].ConnectionString;
          using (SqlConnection con = new SqlConnection(cs))
          {
              SqlCommand cmd = new SqlCommand("spTransaction1", con);
              cmd.CommandType = CommandType.StoredProcedure;
              con.Open();
              cmd.ExecuteNonQuery();
              Label1.Text = "Transaction successful";
              Label1.ForeColor = System.Drawing.Color.Green;
          }
      }
      catch (SqlException ex)
      {
          if (ex.Number == 1205)
          {
              Label1.Text = "Deadlock. Please retry";
          }
          else
          {
              Label1.Text = ex.Message;
          }
          Label1.ForeColor = System.Drawing.Color.Red;
      }
  }


85강 Retry logic for deadlock exceptions
asp.net jquery ajax를 사용하여 프론트가 정해진 횟수만큼 Retry하게 만드는 영상 그냥 참고용...

86강 How to find blocking queries in sql server
blocking은 open transaction이 있을때 발생한다.
DBCC OpenTran은 가장 오래된 active transaction만을 보여준다. 모든 트랜젝션을 보여주지 않는다.
즉 어떤 open transaction에 의해 자신의 query가 block되었는지 알수없다. 오랜된것 1개만 보여주므로 자신을 막고 있는 query가 제일 오래된 것이
아닐때 알수가 없다.

https://www.sqlskills.com/blogs/paul/script-open-transactions-with-text-and-plans/
SELECT
    [s_tst].[session_id],
    [s_es].[login_name] AS [Login Name],
    DB_NAME (s_tdt.database_id) AS [Database],
    [s_tdt].[database_transaction_begin_time] AS [Begin Time],
    [s_tdt].[database_transaction_log_bytes_used] AS [Log Bytes],
    [s_tdt].[database_transaction_log_bytes_reserved] AS [Log Rsvd],
    [s_est].text AS [Last T-SQL Text],
    [s_eqp].[query_plan] AS [Last Plan]
FROM
    sys.dm_tran_database_transactions [s_tdt]
JOIN
    sys.dm_tran_session_transactions [s_tst]
ON
    [s_tst].[transaction_id] = [s_tdt].[transaction_id]
JOIN
    sys.[dm_exec_sessions] [s_es]
ON
    [s_es].[session_id] = [s_tst].[session_id]
JOIN
    sys.dm_exec_connections [s_ec]
ON
    [s_ec].[session_id] = [s_tst].[session_id]
LEFT OUTER JOIN
    sys.dm_exec_requests [s_er]
ON
    [s_er].[session_id] = [s_tst].[session_id]
CROSS APPLY
    sys.dm_exec_sql_text ([s_ec].[most_recent_sql_handle]) AS [s_est]
OUTER APPLY
    sys.dm_exec_query_plan ([s_er].[plan_handle]) AS [s_eqp]
ORDER BY
    [Begin Time] ASC;
GO

위의 스크립트를 쓰면 open transaction을 디스플레이 할수있다.

open transaction이 발생하면 유저에게 연락하여 조치를 취한다. 최후의 방법으로는 process kill이 있다.

Process killing
1.sql server activity monitor
2.KILL Process_ID 명령

session을 kill하게 되면 트랜젝션이 하던 작업은 롤백된다. 데이타베이스는 트랜젝션이 시작하기 전의 상태로 되돌아 가야한다.

87강 SQL Server except operator
EXCEPT operator는 오른쪽 쿼리에 없는 왼쪽 쿼리의 유니크행을 리턴한다
- sql server 2005에서 도입
- 모든 쿼리에 컬럼의 숫자와 순서와 반드시 동일해야한다.
- data type이 같거나 호환되어야 한다.
- oracle에서의 MINUS operator와 비슷하다.

Select Id, Name, Gender
From TableA
Except
Select Id, Name, Gender
From TableB

order By절은 오른쪽 쿼리에 한번만 쓰여져야 한다.
Select Id, Name, Gender, Salary
From tblEmployees
Where Salary >= 50000
Except
Select Id, Name, Gender, Salary
From tblEmployees
Where Salary >= 60000
order By Name


88강 Difference between except and not in

Select Id, Name, Gender From TableA
Except
Select Id, Name, Gender From TableB

위의 except대신 Not in operator로 같은 결과를 얻을수 있다.

Select Id, Name, Gender From TableA
Where Id NOT IN (Select Id from TableB)

차이점?
1. Except는 결과에서 중복행을 제거한다. NOT IN()은 중복을 제거 하지 않는다.
2. Except는 2개의 쿼리의 컬럼 갯수가 같아야한다. NOT IN()은 outer query의 한개의 컬럼과 subquery의 한개의 컬럼을 비교한다.(Id만 비교하고 있다)


89강 Intersect operator
INTERSECT operator는 왼쪽과 오른쪽의 query에서 같은 행들을 뽑아낸다.
- sql server 2005에서 도입
- 모든 쿼리에 컬럼의 숫자와 순서와 반드시 동일해야한다.
- data type이 같거나 호환되어야 한다.

Select Id, Name, Gender from TableA
Intersect
Select Id, Name, Gender from TableB

Select TableA.Id, TableA.Name, TableA.Gender
From TableA Inner Join TableB
On TableA.Id = TableB.Id

차이점?
1. Intersect 결과에서 중복행을 제거한다. inner join은 중복을 제거 하지 않는다.

Join에 Distinct를 적용해서 비슷하게 만들수 있다.
Select DISTINCT TableA.Id, TableA.Name, TableA.Gender
From TableA Inner Join TableB
On TableA.Id = TableB.Id

2.INNER JOIN은 2개의 NULL을 2개의 다른 값으로 취급한다. 그래서 NULLABLE컬럼을 기준으로 2개의 테이블을 join할때 양쪽에 NULL값이 있을때
INNER JOIN의 결과셋에는 그러한 행들이 포함되지 않는다. 반면 INTERSECT는 NULL을 같은값으로 보고 결과에 포함시킨다.

Insert into TableA values(NULL, 'Pam', 'Female')
Insert into TableB values(NULL, 'Pam', 'Female')

INTERSECT query
Select Id, Name, Gender from TableA
Intersect
Select Id, Name, Gender from TableB

출력
NULL, 'Pam', 'Female'


INNER JOIN query
Select TableA.Id, TableA.Name, TableA.Gender
From TableA Inner Join TableB
On TableA.Id = TableB.Id

NULL Id가 출력되지 않는다.


90강 Difference between union intersect and except
UNION : 합집합의 유니크 행
UNION ALL: 중복포함 합집합
INTERSECT : 교집합의 유니크 행
EXCEPT : 차집합의 유니크 행


91강 Cross apply and outer apply
2문장은 join의 예제이다.

Select D.DepartmentName, E.Name, E.Gender, E.Salary
from Department D
Inner Join Employee E
On D.Id = E.DepartmentId

Select D.DepartmentName, E.Name, E.Gender, E.Salary
from Department D
Left Join Employee E
On D.Id = E.DepartmentId

만약 physical table을 접근할수 없고 table valued function을 갖고 있다고 할때 위 문장을 쓰고 싶다.

Create function fn_GetEmployeesByDepartmentId(@DepartmentId int)
Returns Table
as
Return
(
    Select Id, Name, Gender, Salary, DepartmentId
    from Employee where DepartmentId = @DepartmentId
)
Go
Select * from fn_GetEmployeesByDepartmentId(1) <= DepartmentId가 1인 Employee return

Select D.DepartmentName, E.Name, E.Gender, E.Salary
from Department D
Inner Join fn_GetEmployeesByDepartmentId(D.Id) E  <= D.Id에서 에러
On D.Id = E.DepartmentId

Msg 4104, Level 16, State 1, Line 3
The multi-part identifier "D.Id" could not be bound.

이럴때 Cross Apply, Outer Apply를 써야한다. 의미적으로 Cross Apply는 Inner Join과 같고 Outer Apply는 Left Outer Join과 같다.

Select D.DepartmentName, E.Name, E.Gender, E.Salary
from Department D
Cross Apply fn_GetEmployeesByDepartmentId(D.Id) E

Select D.DepartmentName, E.Name, E.Gender, E.Salary
from Department D
Outer Apply fn_GetEmployeesByDepartmentId(D.Id) E


Cross Apply, Outer Apply는 어떻게 동작하는가?
- Apply operator는 sql server 2005에 도입되었다.
- 테이블을 table valued function과 join할때 쓰인다.
- Apply operator의 오른쪽에있는 table valued function은 왼쪽에 있는 테이블(outer table)의 각각의 행마다 호출된다.
- Cross Apply는 matching되는 행만 리턴(의미적으로 Inner Join과 같다.)
- Outer Apply는 matching + non-matching행을 리턴(의미적으로 Left Outer Join과 같다.) 매칭되지 않은 table valued function의 컬럼은 NULL값이 된다.


92강 DDL Triggers in sql server 
SQL server에는 4종류의 trigger가 있다.
1.DML trigger - Data Manipulation Language.(INSERT, UPDATE, DELETE)
2.DDL trigger - Data Definitaion Language.(CREATE, ALTER, DROP )
3.CLR trigger - Common Language Runtime
3.Logon trigger

DDL trigger란?
DDL이벤트에 대응하여 호출되는 트리거들. 
DDL이벤트 - Table, Function, Index, Stored Procedure등에 CREATE, ALTER, DROP 명령을 하는것(MSDN에 나와있다)
어떤 DDL-like한 operation을 하는 system stored procedure들도 DDL trigger를 fire할수 있다.
예- sp_rename system stored procedure

DDL trigger 사용용도
-지정된 DDL이벤트에 대응하여 어떤 코드를 실행시키고 싶을때
-database schema의 변경을 막고 싶을때
-유저가 database structure의 변경을 감시하고 싶을때

문법
CREATE TRIGGER [Trigger_Name]
ON [Scope (Server|Database)]
FOR [EventType1, EventType2, EventType3, ...],
AS
BEGIN
   -- Trigger Body
END


DDL triggers scope : database 혹은 server level로 지정될수 있다.

Use SampleDB
Go

CREATE TRIGGER trMyFirstTrigger
ON Database
FOR CREATE_TABLE
AS
BEGIN
   Print 'New table created'
END

Programmability > Database Triggers folder안에 트리거가 생성된다.

ALTER TRIGGER trMyFirstTrigger
ON Database
FOR CREATE_TABLE, ALTER_TABLE, DROP_TABLE <= 여러개의 이벤트
AS
BEGIN
   Print 'A table has just been created, modified or deleted'
END

변경 막기
ALTER TRIGGER trMyFirstTrigger
ON Database
FOR CREATE_TABLE, ALTER_TABLE, DROP_TABLE
AS
BEGIN
   Rollback <= 롤백!
   Print 'You cannot create, alter or drop a table'
END

다시 CREATE, ALTER, DROP을 하려면 생성된트리거를 지우거나 disable시켜야한다.

trigger disable 시키는 방법
1. object explorer에서 context menu > disable 선택
2. DISABLE TRIGGER trMyFirstTrigger ON DATABASE
trigger enable 시키는 방법
1. object explorer에서 context menu > enable 선택
2. ENABLE TRIGGER trMyFirstTrigger ON DATABASE

어떤 system sp들은 DDL-like operation을 하며 이는 DDL trigger들을 호출한다.
sp_rename 트리거
CREATE TRIGGER trRenameTable
ON DATABASE
FOR RENAME
AS
BEGIN
 Print 'You just renamed something'
END

sp_rename 'TestTable', 'NewTestTable'
sp_rename 'NewTestTable.Id' , 'NewId', 'column'


93강 Server scoped ddl triggers
CREATE TRIGGER tr_ServerScopeTrigger
ON ALL SERVER <= scope가 바뀐다
FOR CREATE_TABLE, ALTER_TABLE, DROP_TABLE
AS
BEGIN
 ROLLBACK
 Print 'You cannot create, alter or drop a table in any database on the server'
END

database폴더가 아닌 Server Objects>Triggers 폴더에 생긴다.

DISABLE TRIGGER tr_ServerScopeTrigger ON ALL SERVER
ENABLE TRIGGER tr_ServerScopeTrigger ON ALL SERVER
DROP TRIGGER tr_ServerScopeTrigger ON ALL SERVER


94강 sql server trigger execution order
Server scoped trigger들은 항상 database scoped trigger들보다 먼저 호출된다. 이 순서는 변경이 할 수 없다.

sp_settriggerorder를 사용하여 server-scoped 또는 database-scoped trigger들의 실행 순서를 변경할수있다.

sp_settriggerorder는 4개의 파레메터를 갖는다.
@triggername : trigger 이름
@order : FIRST, LAST, None None일 경우 Random 순서를 갖는다.
@stmttype : 트리거를 호출하는 SQL문. INSERT, UPDATE, DELETE 또는 DDL event
@namespace : trigger의 scope, DATABASE, SERVER, NULL

EXEC sp_settriggerorder
@triggername = 'tr_DatabaseScopeTrigger1',
@order = 'none',
@stmttype = 'CREATE_TABLE',
@namespace = 'DATABASE'
GO

같은 event를 처리하는 database-scoped 와 server-scoped trigger가 있을때 실행순서는 다음과 같다.
1. The server-scope trigger marked First
2. Other server-scope triggers
3. The server-scope trigger marked Last
4. The database-scope trigger marked First
5. Other database-scope triggers
6. The database-scope trigger marked Last


95강 Audit table changes in sql server
다음은 모든 database에서의 모든 table의 변경을 감시하는 트리거이다.

CREATE TRIGGER tr_AuditTableChanges
ON ALL SERVER <= server scope이므로 모든 데이타베이스에대해 동작
FOR CREATE_TABLE, ALTER_TABLE, DROP_TABLE
AS
BEGIN
    DECLARE @EventData XML
    SELECT @EventData = EVENTDATA()

    INSERT INTO SampleDB.dbo.TableChanges <= server scope이므로 전체 이름을 써줘야한다.
    (DatabaseName, TableName, EventType, LoginName,
     SQLCommand, AuditDateTime)
    VALUES
    (
         @EventData.value('(/EVENT_INSTANCE/DatabaseName)[1]', 'varchar(250)'),
         @EventData.value('(/EVENT_INSTANCE/ObjectName)[1]', 'varchar(250)'),
         @EventData.value('(/EVENT_INSTANCE/EventType)[1]', 'nvarchar(250)'),
         @EventData.value('(/EVENT_INSTANCE/LoginName)[1]', 'varchar(250)'),
         @EventData.value('(/EVENT_INSTANCE/TSQLCommand)[1]', 'nvarchar(2500)'),
         GetDate()
    )
END

EventData()함수는 XML으로 event data를 리턴한다.
트리거 안에서 Select EventData()하면

<EVENT_INSTANCE>
  <EventType>CREATE_TABLE</EventType>
  <PostTime>2015-09-11T16:12:49.417</PostTime>
  <SPID>58</SPID>
  <ServerName>VENKAT-PC</ServerName>
  <LoginName>VENKAT-PC\Tan</LoginName>
  <UserName>dbo</UserName>
  <DatabaseName>SampleDB</DatabaseName>
  <SchemaName>dbo</SchemaName>
  <ObjectName>MyTable</ObjectName>
  <ObjectType>TABLE</ObjectType>
  <TSQLCommand>
    <SetOptions ANSI_NULLS="ON" ANSI_NULL_DEFAULT="ON"
                ANSI_PADDING="ON" QUOTED_IDENTIFIER="ON"
                ENCRYPTED="FALSE" />
    <CommandText>
      Create Table MyTable
      (
         Id int,
         Name nvarchar(50),
         Gender nvarchar(50)
      )
    </CommandText>
  </TSQLCommand>
</EVENT_INSTANCE>

96강 Logon Triggers in SQL Server
이름이 의미하듯 Logon event에 반응하여 호출되는 trigger.
Logon Trigger는 인증이 끝났지만 session은 연결되기 전에 호출된다.

Logon Trigger는 다음과 같이 쓰일수 있다.
1. login activity 추적
2. login 제한
3. 특정 로그인에 대한 session의 갯수 제한

CREATE TRIGGER tr_LogonAuditTriggers
ON ALL SERVER
FOR LOGON
AS
BEGIN
    DECLARE @LoginName NVARCHAR(100)

    Set @LoginName = ORIGINAL_LOGIN()

    IF (SELECT COUNT(*) FROM sys.dm_exec_sessions
         WHERE is_user_process = 1
         AND original_login_name = @LoginName) > 3
    BEGIN
         Print 'Fourth connection of ' + @LoginName + ' blocked'  <= error log에 써진다.
         ROLLBACK  <= 로그인 취소된다!
    END
END

Execute sp_readerrorlog <= error log 보기

Object explorer가 1개의연결 query window를 연결할때마다 연결이 생성된다.


97강 Select into
한테이블에서 새로운 테이블로 data를 insert하는데 select into문이 쓰인다.

Select Into문은 다음과 같은것을 할수있다.

1.이미 있는 테이블로 부터 모든 행과 열을 복사한다. 존재하는 테이블의 백업을 만들때 아주 유용하다.
Select * into EmployeeBackup From Employees <= EmployeeBackup이 이미 존재하는 테이블이면 에러~ EmployeeBackup은 문이 실행되면 바로 생성된다.

2.존재하는 테이블에서 모든 행과 열을 외부 테이타베이스에 있는 새로운 테이블로 복사한다.
Select * Into HRDB.dbo.EmployeeBackup From Employees

3.새로운 테이블로 선택한 컬럼만 복사한다
Select Id, Name, Gender Into EmployeeBackup From Employees

4.새로운 테이블로 선택한 행만 복사한다
Select * Into EmployeeBackup From Employees Where DeptId = 1

5.2개 이상의 테이블로 부터 새로운 테이블로 복사한다.
Select * Into EmployeeBackup From Employees
Inner Join Departments
On Employees.DeptId = Departments.DepartmentId
위의 문장은 Employees.DeptId와 Departments.DepartmentI가 겹치게 출력된다.

Select Employees.*, Departments.DepartmentName Into EmployeeBackup From Employees
Inner Join Departments
On Employees.DeptId = Departments.DepartmentId

6.존재하는 테이블과 매치되는 컬럼과 데이타타입을 가진 새로운 테이블을 생성한다.
Select * Into EmployeeBackup From Employees Where 1 <> 1 <= where절이 항상 false이므로 해당되는 행이 없다!

7.다른 sql server instance에 존재하는 테이블의 모든 행과 열을 복사할때, 이것을 위해선 linked server를 생성하고 4part naming convention을 써야한다.
Select * Into TargetTable
From [SourceServer].[SourceDB].[dbo].[SourceTable]


Select Into는 이미 존재하는 테이블에 쓸수 없다는것을 기억하자.
만약 존재하는 테이블에 넣어야 한다면 Insert Into문을 써라.
INSERT INTO ExistingTable (ColumnList) SELECT ColumnList From SourceTable

Insert Into EmployeeBackup Select * From Employees
Insert Into EmployeeBackup(Id, Name, Gender) Select Id, Name, Gender From Employees <=특정 컬럼만 넣고 싶을때!

98강 Difference between where and having

Product별 sales합
SELECT Product, SUM(SaleAmount) AS TotalSales
FROM Sales
GROUP BY Product


이때 sales합이 1000인 행들만 출력하고 싶다고 하자. 이때 Having을 쓴다.

SELECT Product, SUM(SaleAmount) AS TotalSales
FROM Sales
GROUP BY Product
Having SUM(SaleAmount) > 1000

만약 Having대신 Where를 쓰면 syntax error가 발생한다. Where절은 aggregate function(sum, min, max, avg등)들과는 함께쓸수 없기때문이다.
요약하면 Where는 aggregate function을 쓸 수 없는 반면 Having은 쓸 수 있다.
우리가 사용할때 별로 신경쓰지 않는 다른 차이점이 있다.

Where절은 aggregate function이 수행되기전에 행들을 필더링하고 Having절은 aggregate function이 수행된후 행들을 필터링한다.


아래 문장은 'iPhone', 'Speakers'만을 검색해 와서 sum()을 수행한다.
SELECT Product, SUM(SaleAmount) AS TotalSales
FROM Sales
WHERE Product in ('iPhone', 'Speakers')
GROUP BY Product

아래 문장은 모든 행들 가져온뒤, Sum()을 수행하고 'iPhone', 'Speakers'가 아닌 것들을 제외한다.
SELECT Product, SUM(SaleAmount) AS TotalSales
FROM Sales
GROUP BY Product
HAVING Product in ('iPhone', 'Speakers')

퍼포먼스 관점에서 Having은 Where보다 느리며 가능한 피해야한다.

또 다른점은 Where는 Group By 이전에 나오고 Having은 Group By 이후 나온다..

Where와 Having의 차이점
1.Where절은 집계함수와 같이 쓸 수 없지만 Having은 쓸 수 있다. 이것이 의미하는 것은 Where는 각각의 행들을 필터링하는데 쓰여지고,
반면 Having은 그룹들을 필터링 하는데 쓰여진다.

2.Where는 GroupBy 이전에 나온다. 이것이 의미하는것은 Where절은 집계함수가 수행되기전에 행들을 필터링하는것을 의미한다.
Having은 Group By이후에 나온다. 이것이 의미하는 것은 Having절은 집계함수가 수행된후 필터링하는 것을 의미한다.
Having은 Where보다 느리며 가능한 사용을 피해야한다.

3.Where와 Having은 Select문에서 같이 쓰일 수 있다. 이 경우 Where절이 각각의 행들을 먼저 필터링한다. 그 다음 행들이 그룹화되며
집계함수가 수행된다. 그다음 Having절이 group들을 필더링한다.


99강 Table valued parameters
sql server 2008 이후 지원되는 기능이다.
Table valued parameters(예를 들면 data 여러줄)는 테이블을 sp의 파라메터로 넘길수 있게 한다.

Step 1 : Create User-defined Table Type
CREATE TYPE EmpTableType AS TABLE
(
    Id INT PRIMARY KEY,
    Name NVARCHAR(50),
    Gender NVARCHAR(10)
)
Go

Programmability>Types>User-Defined Table Types에 생성된다.

Step 2 : User-defined Table Type을 파라메터로 sp를 생성한다. 
Table valued parameter는 sp 또는 function에 반드시 read-only로 넘겨야한다.
이것은 sp, function안에서 DML opertion(INSERT, UPDATE or DELETE)을 수행할수 없다는 의미이다.

CREATE PROCEDURE spInsertEmployees
@EmpTableType EmpTableType READONLY <= read-only
AS
BEGIN
    INSERT INTO Employees
    SELECT * FROM @EmpTableType
END

Step 3 : 테이블 변수를 만들고 초기화뒤 sp에 넘겨 호출한다.
DECLARE @EmployeeTableType EmpTableType

INSERT INTO @EmployeeTableType VALUES (1, 'Mark', 'Male')
INSERT INTO @EmployeeTableType VALUES (2, 'Mary', 'Female')
INSERT INTO @EmployeeTableType VALUES (3, 'John', 'Male')
INSERT INTO @EmployeeTableType VALUES (4, 'Sara', 'Female')
INSERT INTO @EmployeeTableType VALUES (5, 'Rob', 'Male')

EXECUTE spInsertEmployees @EmployeeTableType
다음에 ADO.net에서 테이블을 넘기는 방법을 알아보자

100강 Send datatable as parameter to stored procedure
스킵! asp.net 샘플임..

101강 Grouping Sets in SQL Server
sql server 2008 이상 지원되는 기능.

Country와 Gender별 Salary의 합을 구하고 싶다고 하자.
Select Country, Gender, Sum(Salary) as TotalSalary
From Employees 
Group By Country, Gender

그런데 같이 Country별 Salary의 합을 추가하고 싶다고 하자.
Select Country, Gender, Sum(Salary) as TotalSalary
From Employees 
Group By Country, Gender

UNION ALL

Select Country, NULL, Sum(Salary) as TotalSalary
From Employees 
Group By Country

그런데 Gender별 Salary도 따로 추가.
Select Country, Gender, Sum(Salary) as TotalSalary
From Employees 
Group By Country, Gender

UNION ALL

Select Country, NULL, Sum(Salary) as TotalSalary
From Employees 
Group By Country

UNION ALL

Select NULL, Gender, Sum(Salary) as TotalSalary
From Employees 
Group By Gender

그런데 다시 모든 salary를 또 추가.
Select Country, Gender, Sum(Salary) as TotalSalary
From Employees 
Group By Country, Gender

UNION ALL

Select Country, NULL, Sum(Salary) as TotalSalary
From Employees 
Group By Country

UNION ALL

Select NULL, Gender, Sum(Salary) as TotalSalary
From Employees 
Group By Gender

UNION ALL

Select NULL, NULL, Sum(Salary) as TotalSalary
From Employees 

위 query는 2가지 문제를 가지고 있다.
1.너무 query가 길다. 더 길어질수도 있다.
2.각각의 query마다 Employees 테이블을 접근해서 4번 접근해야만 한다.


Grouping Sets 기능을 쓰면 query의 양을 줄일수 있다.
Select Country, Gender, Sum(Salary) TotalSalary
From Employees
Group BY
  GROUPING SETS
  (
        (Country, Gender), -- Sum of Salary by Country and Gender
        (Country),               -- Sum of Salary by Country
        (Gender) ,               -- Sum of Salary by Gender
        ()                             -- Grand Total
  )


Order By를 다음과 같이 써서 정렬 할수도 있다.
Select Country, Gender, Sum(Salary) TotalSalary
From Employees
Group BY
  GROUPING SETS
  (
        (Country, Gender), -- Sum of Salary by Country and Gender
        (Country),               -- Sum of Salary by Country
        (Gender) ,               -- Sum of Salary by Gender
        ()                             -- Grand Total
  )
Order By Grouping(Country), Grouping(Gender), Gender


102강 Rollup
계층에서 여러레벨의 집계작업을 하기 위해 RULLUP을 쓴다.

Country TotalSalary
India 12000
UK 17000
USA 22500
NULL 51500

위와같은 결과를 얻기 이해 가장 쉬운방법은 ROLLUP과 사용한 Group By이다.
SELECT Country, SUM(Salary) AS TotalSalary
FROM Employees
GROUP BY ROLLUP(Country)

아래와 같이 쓸수도 있다.
SELECT Country, SUM(Salary) AS TotalSalary
FROM Employees
GROUP BY Country WITH ROLLUP

아래는 Rollup을 쓰지 않는 코드이다.
SELECT Country, SUM(Salary) AS TotalSalary
FROM Employees
GROUP BY Country

UNION ALL

SELECT NULL, SUM(Salary) AS TotalSalary
FROM Employees

Grouping을 쓸수도 있다.
SELECT Country, SUM(Salary) AS TotalSalary
FROM Employees
GROUP BY GROUPING SETS
(
    (Country),
    ()
)

다른 예제를 보자. Country Gender별 Total, Subtoatl for Country, Grand Total


Country Gender TotalSalary
India Female 4000  <= Country Gender
India Male 8000
India NULL 1200 <= Country Subtotal
UK Female 5000
UK Male 12000
UK NULL 17000
USA Female 12500
USA Male 10000
USA NULL 22500
NULL  NULL 51500 <= Grand Total

Using ROLLUP with GROUP BY
SELECT Country, Gender, SUM(Salary) AS TotalSalary
FROM Employees
GROUP BY ROLLUP(Country, Gender)

--OR

SELECT Country, Gender, SUM(Salary) AS TotalSalary
FROM Employees
GROUP BY Country, Gender WITH ROLLUP

Using UNION ALL with GROUP BY
SELECT Country, Gender, SUM(Salary) AS TotalSalary
FROM Employees
GROUP BY Country, Gender

UNION ALL

SELECT Country, NULL, SUM(Salary) AS TotalSalary
FROM Employees
GROUP BY Country

UNION ALL

SELECT NULL, NULL, SUM(Salary) AS TotalSalary
FROM Employees

Using GROUPING SETS
SELECT Country, Gender, SUM(Salary) AS TotalSalary
FROM Employees
GROUP BY GROUPING SETS
(
    (Country, Gender),
    (Country),
    ()
)


103강 Cube in SQL Server
Cube()함수는 Group By CUBE()에 정의된 컬럼의 모든 조합을 생성해 결과 셋을 만드는 함수이다.

Country Gender TotalSalary
India Female 4000  <= Country Gender
UK Female 5000
USA Female 12500
NULL Female 21500
India Male 8000
UK Male 12000
USA Male 10000
NULL Male 30000
NULL  NULL 51500 <= Grand Total
India NULL 1200 <= Country Subtotal
UK NULL 17000
USA NULL 22500


Using Cube with Group By
SELECT Country, Gender, SUM(Salary) AS TotalSalary
FROM Employees
GROUP BY Cube(Country, Gender)
--OR
SELECT Country, Gender, SUM(Salary) AS TotalSalary
FROM Employees
GROUP BY Country, Gender with Cube

Grouping 사용과 동일
SELECT Country, Gender, SUM(Salary) AS TotalSalary
FROM Employees
GROUP BY
  GROUPING SETS
  (
        (Country, Gender),
        (Country),
        (Gender),
        ()
  )

UNION ALL 사용
SELECT Country, Gender, SUM(Salary) AS TotalSalary
FROM Employees
GROUP BY Country, Gender

UNION ALL

SELECT Country, NULL, SUM(Salary) AS TotalSalary
FROM Employees
GROUP BY Country

UNION ALL

SELECT NULL, Gender, SUM(Salary) AS TotalSalary
FROM Employees
GROUP BY Gender

UNION ALL

SELECT NULL, NULL, SUM(Salary) AS TotalSalary
FROM Employees


104강 Difference between cube and rollup in SQL Server
CUBE()는 선택한 컬럼의 모든 조합에대한 aggregation을 보여주는 반면 ROLLUP()은 선택된 컬럼의 hierarhy를 보여준다.

ROLLUP(Continent, Country, City) produces Sum of Salary for the following hierarchy
Continent, Country, City
Continent, Country, 
Continent
()

CUBE(Continent, Country, City) produces Sum of Salary for all the following column combinations
Continent, Country, City
Continent, Country, 
Continent, City
Continent
Country, City
Country,
City
()

만약 선택된 컬럼이 1개라면 ROLLUP()과 CUBE()의 차이는 없다.


105강 Grouping function
Grouping()함수
Grouping(Column)함수는 Group By list에 있는 컬럼이 집계되었는지 아닌지를 가리킨다.
1: 집계됨 0: 집계 안됨


SELECT   Continent, Country, City, SUM(SaleAmount) AS TotalSales,
         GROUPING(Continent) AS GP_Continent,
         GROUPING(Country) AS GP_Country,
         GROUPING(City) AS GP_City
FROM Sales
GROUP BY ROLLUP(Continent, Country, City)


Continent Country City TotalSales GP_Continent GP_Country GP_City
Asia India Bangalore 1000 0 0 0 (Continent Country City 어떠한것으로도 집계되지 않은 값)
Asia India NULL 3000 0 0 1 (Asia India의 모든 City로 값이 집계되었다.)
Asia NULL NULL 3000 0 1 1 (Asia의 모든Country 모든 City로 값이 집계되었다)
NULL NULL NULL 3000 1 1 1 (data가 모든 컬럼에의해 집계되었다)


Grouping()함수의 실제 사용예
어떤 컬럼이 결과 셋에서 집계되면 컬럼은 NULL값을 갖는다. 만약 NULL대신 All로 바꾼다면 더 좋을것이고 GROUPING()함수가 편리하다.
SELECT  
    CASE WHEN
         GROUPING(Continent) = 1 THEN 'All' ELSE ISNULL(Continent, 'Unknown')
    END AS Continent,
    CASE WHEN
         GROUPING(Country) = 1 THEN 'All' ELSE ISNULL(Country, 'Unknown')
    END AS Country,
    CASE
         WHEN GROUPING(City) = 1 THEN 'All' ELSE ISNULL(City, 'Unknown')
    END AS City,
    SUM(SaleAmount) AS TotalSales
FROM Sales
GROUP BY ROLLUP(Continent, Country, City)

Asia India Bangalore 1000 0 0 0
Asia India All 3000 0 0 1 (Asia India의 모든 도시가 Grouping)
Asia All All 3000 0 1 1
All All All 3000 1 1 1

아래처럼 ISNULL()함수만 써서 가능하지 않는가?
SELECT   ISNULL(Continent, 'All') AS Continent,
         ISNULL(Country, 'All') AS Country,
         ISNULL(City, 'All') AS City,
         SUM(SaleAmount) AS TotalSales
FROM Sales
GROUP BY ROLLUP(Continent, Country, City)

가능하긴 하지만 데이타에 NULL이 없을경우에만 가능하다.

City에 실제 값이 NULL일경우, 즉 어떤 City인지 모른다는 표시일것이다.
ISNULL(City, 'All') AS City 문장은 City의 값이 NULL일경우 All로 표시된다.
하지만 
WHEN GROUPING(City) = 1 THEN 'All' ELSE ISNULL(City, 'Unknown') NULL일 경우 Unknonwn으로 표시된다.


106강 GROUPING ID function in SQL Server
GROUPING ID()함수는 level of grouping을 계산한다.

문법
Grouping()함수는 1개의 컬럼을 인자로 받는 반면 GROUPING_ID()함수의 인자는 Group By의 컬럼리스트와 매칭되어야 한다.
GROUPING(Col1)
GROUPING_ID(Col1, Col2, Col3,...)

Grouping()은 Group By에 있는 컬럼이 집계되었는지 아닌지를 가리킨다.
GROUPING_ID()함수는 이진수 합으로 모든 Grouping()함수를 합한뒤 int값을 리턴한다.
GROUPING_ID(A, B, C) =  GROUPING(A) + GROUPING(B) + GROUPING(C)

SELECT   Continent, Country, City, SUM(SaleAmount) AS TotalSales,
         CAST(GROUPING(Continent) AS NVARCHAR(1)) +  --int 더하기가 아닌 bit필드로 표현하기 위해 nvarchar형으로 변환
         CAST(GROUPING(Country) AS NVARCHAR(1)) +
         CAST(GROUPING(City) AS NVARCHAR(1)) AS Groupings,
         GROUPING_ID(Continent, Country, City) AS GPID
FROM Sales
GROUP BY ROLLUP(Continent, Country, City)

Continent Country City TotalSales Groupings GPID
Asia India Bangalore 1000 000 0
Asia India NULL 3000 001 1
Asia NULL NULL 3000 011 3
NULL NULL NULL 3000 111 7

GROUPING_ID()의 사용 용도
Sorting by level of grouping
SELECT   Continent, Country, City, SUM(SaleAmount) AS TotalSales,
         GROUPING_ID(Continent, Country, City) AS GPID
FROM Sales
GROUP BY ROLLUP(Continent, Country, City)
ORDER BY GPID

Filter by level of grouping
SELECT   Continent, Country, City, SUM(SaleAmount) AS TotalSales,
         GROUPING_ID(Continent, Country, City) AS GPID
FROM Sales
GROUP BY ROLLUP(Continent, Country, City)
HAVING GROUPING_ID(Continent, Country, City) = 3


107강 Debugging sql server stored procedures
디버깅을 할때 에러가 나는 경우 대부분은 Server name에 실제 컴퓨터이름이 넣어져 있지 않아서이다. '.'으로는 디버깅이 안된다.
Debug 메뉴에 전부 있다. 단축키 보고 해보면 될듯.

Conditional Breakpoint: break point위에서 context menu > condition선택



108강 Over clause
PARTITION BY 와 결합된 OVER절은 파티션으로 data를 나누는데 쓰여진다.

문법
function (...) OVER (PARTITION BY col1, Col2, ...)
명시된 함수는 각각의 Partition을 조작한다.

예
COUNT(Gender) OVER (PARTITION BY Gender)
data를 Gender로 파티션할것이다. 2개의 파티션이 있을것이고(Male, Female) COUNT()함수는 각각의 파티션에 적용될것이다.
다음과 같은 함수들과 같이 쓰일 수 있다. 아래 말고도 더 있음..
COUNT(), AVG(), SUM(), MIN(), MAX(), ROW_NUMBER(), RANK(), DENSE_RANK()


Gender별 GenderTotal AvgSal MinSal MaxSal을 출력하는 query
SELECT Gender, COUNT(*) AS GenderTotal, AVG(Salary) AS AvgSal,
      MIN(Salary) AS MinSal, MAX(Salary) AS MaxSal
FROM Employees
GROUP BY Gender

만약 집계되지 않는 값(Name, Salary)을 집계된 값들과 같이 출력하고 싶다고 해보자
Name Salary Gender (Gender별)GenderTotal AvgSal MinSal MaxSal
Sara 4000 Female 4 5375 4000 7000
Mary 5000 Female 4 5375 4000 7000

아래의 query는 실패한다. 

SELECT Name, Salary, Gender, COUNT(*) AS GenderTotal, AVG(Salary) AS AvgSal,
        MIN(Salary) AS MinSal, MAX(Salary) AS MaxSal
FROM Employees
GROUP BY Gender

Column 'Employees.Name' is invalid in the select list because it is not contained in either an aggregate function or the GROUP BY clause

Group By query에서는 집계되지 않는 컬럼을 포함할수가 없다.

위의 결과를 달성하는 한 방법은 subquery에 집계결과들을 넣고 Join하는 것이다.
SELECT Name, Salary, Employees.Gender, Genders.GenderTotals,
        Genders.AvgSal, Genders.MinSal, Genders.MaxSal   
FROM Employees
INNER JOIN
(SELECT Gender, COUNT(*) AS GenderTotals,
          AVG(Salary) AS AvgSal,
         MIN(Salary) AS MinSal, MAX(Salary) AS MaxSal
FROM Employees
GROUP BY Gender) AS Genders
ON Genders.Gender = Employees.Gender

단점은 복잡해보이고 query의 양이 많다는것이다
다음과 같이 Partition By와 결합된 Over절을 이용하는것이 더 낫다.

SELECT Name, Salary, Gender,
        COUNT(Gender) OVER(PARTITION BY Gender) AS GenderTotals,
        AVG(Salary) OVER(PARTITION BY Gender) AS AvgSal,
        MIN(Salary) OVER(PARTITION BY Gender) AS MinSal,
        MAX(Salary) OVER(PARTITION BY Gender) AS MaxSal
FROM Employees

109강 Row Number function
Row_Number()함수
=>sql server 2005부터 지원
=>1부터 시작하는 행번호를 러턴
=>Order By 절이 필요하다.
=>Partition By절은 optional하다.
=>data가 파티션되면 파티션이 바뀔때 행번호가 1로 리셋된다.

문법
ROW_NUMBER() OVER (ORDER BY Col1, Col2)

PARTITION BY 없는 Row_Number()함수
SELECT Name, Gender, Salary,
        ROW_NUMBER() OVER (ORDER BY Gender) AS RowNumber <= ORDER BY가 없으며 문법 에러
FROM Employees

PARTITION BY있는 Row_Number()함수
SELECT Name, Gender, Salary,
        ROW_NUMBER() OVER (PARTITION BY Gender ORDER BY Gender) AS RowNumber
FROM Employees

Name Gender Salary RowNumber
Pam Female 5500  1
Sara Female 4000  2
Mary Female 5000  3
Jodi Female 7000  4
Tom Male 5500 1
Ron Male 6500 1
Ben Male 3500 1

Row_Number()함수 usecase <=인터뷰에 자주 나옴
table에 있는 중복된 행을 각각 1개만 남기고 나머진 제거하라

With EmployeeCTE As
{
  Select *, ROW_NUMBER() Over(Partition By ID Order By ID) As RowNumber
  From Employees
}
Delete From EmployeesCTE Where RowNumber > 1


110강 Rank and Dense Rank in SQL Server
RANK(), DENSE_RANK()함수
=>sql server 2005부터 지원
=>Order By절에의해 정렬된 행들의 순서에 기초해 1부터 시작하는 랭크를 러턴
=>Order By 절이 필요하다.
=>Partition By절은 optional하다.
=>data가 파티션되면 파티션이 바뀔때 랭크가 1로 리셋된다.

RANK(), DENSE_RANK()의 차이
만약 랭크가 1인 2개의 행이 있다면(같아서)다음과 같이 랭크가 출력된다.
RANK() returns - 1, 1, 3, 4, 5  <=Rank값의 중간이 비어있다. 1이 둘이므로 2가 없다.
DENSE_RANK returns - 1, 1, 2, 3, 4

문법
RANK() OVER (ORDER BY Col1, Col2, ...)
DENSE_RANK() OVER (ORDER BY Col1, Col2, ...)

Partition By 없는 Rank(),Dense_Rank()함수
Rank()함수는 1등이 2명일때 2등 랭크는 스킵한다. 3등부터 시작
Dense_Rank()함수는 1등 2명에게 1등 3번째에게 2등을 준다.

SELECT Name, Salary, Gender,
RANK() OVER (ORDER BY Salary DESC) AS [Rank],
DENSE_RANK() OVER (ORDER BY Salary DESC) AS DenseRank
FROM Employees

Partition By 가 있는 Rank(),Dense_Rank()함수
SELECT Name, Salary, Gender,
RANK() OVER (PARTITION BY Gender ORDER BY Salary DESC) AS [Rank], <= Rank가 함수 이름이므로 []로 감싸준다.
DENSE_RANK() OVER (PARTITION BY Gender ORDER BY Salary DESC)
AS DenseRank
FROM Employees

Rank(),Dense_Rank()함수 usecase
2개의 함수 모드 Nth highest salary를 찾는데 쓰일수 있다. 하지만 어떤 함수를 쓸것인가?는 tie일경우 무엇을 할지에따라 달라진다.

만약 가장 높은 salary를 2명이 갖고있을때 2가지 다른 비즈니스경우가 있다.
1. 만약 2번째 높은 salary를 알아내야 할때 Rank()함수를 쓴다.
2. 만약 tie인 행 다음의 Salary를 리턴해야하는경우(2번째로 높은 Salary) Dense_rank()함수를 쓴다.

WITH Result AS
(
    SELECT Salary, RANK() OVER (ORDER BY Salary DESC) AS Salary_Rank
    FROM Employees
)
SELECT TOP 1 Salary FROM Result WHERE Salary_Rank = 2
2명이 가장높은 Salary로 tie이므로 Rank()함수는 2번째로 높은 Salary를 리턴하지 않는다.

WITH Result AS
(
    SELECT Salary, DENSE_RANK() OVER (ORDER BY Salary DESC) AS Salary_Rank
    FROM Employees
)
SELECT TOP 1 Salary FROM Result WHERE Salary_Rank = 2
2명이 첫번째 가장높은 Salary이고 다음이 두번째로 높은 Salary이다. Dense_Rank()함수는 2등을 리턴한다.

Female중 랭크가 2인 Salary의 값
WITH Result AS
(
    SELECT Salary, Gender,
           DENSE_RANK() OVER (PARTITION BY Gender ORDER BY Salary DESC)
           AS Salary_Rank
    FROM Employees
)
SELECT TOP 1 Salary FROM Result WHERE Salary_Rank = 3
AND Gender = 'Female'


111강 Difference between rank dense rank and row number in SQL
Rank() Dense_Rank() Row_Number() 함수의 비슷한점
=>Order By절에의해 정렬된 행들의 순서에 기초해 1부터 시작하는 int를 리턴(tie가 없을때=>중복이 없다)
=>Order By 절이 필요하다.
=>Partition By절은 optional하다.
=>data가 파티션되면 파티션이 바뀔때 1로 리셋된다.

차이점
Row_Number()
중복이 있더라도 강 행마다 1부터 증가하는 유니크 숫자를 리턴
Rank()
1부터 증가하는 숫자를 리턴. 중복되는 랭킹은 스킵!
Dense_Rank()
1부터 증가하는 숫자를 리턴. 중복되는 랭킹을 스킵하지 않는다.


112강 Calculate running total
running total : 누적합계
sql server 2012 이후 버전에서 사용가능하다.

누적합계를 구하는 query
SELECT Name, Gender, Salary,
        SUM(Salary) OVER (ORDER BY ID) AS RunningTotal   <= ORDER BY ID인 이유는 나중에 설명
FROM Employees

Name Gender Salary RunningTotal
Make Male 5000 5000
John Male 4500 9500
Pam Female 5500 15000  <= 이런식으로 salary의 누적합계가 출력된다.

파티션과 함께 누적 계산
SELECT Name, Gender, Salary,
        SUM(Salary) OVER (PARTITION BY Gender ORDER BY ID) AS RunningTotal
FROM Employees

Pam Female 5500 5500
Sara Female 4000 9500
...
Make Male 5000 5000 <= 파티션마다 누적합계는 리셋된다.
John Male 4500 9500

Salary를 Order By에 쓰면 어떤 일이 일어나는가?
Salary에 중복된 값이 있으면 모든 중복된 값이 합쳐져서 누적합계에 한번에 더해진다.

SELECT Name, Gender, Salary,
        SUM(Salary) OVER (ORDER BY Salary) AS RunningTotal
FROM Employees

Todd Male 3500 3500
Saram Female 4000 12000
Mark Male 5000 27000 <= 누적합계에 5000이 세번 한꺼번에 더해졌다.
Mary Female 5000 27000
Ron Male 5000 27000

running total을 쓸경우 Order By절에는 Unique한 컬럼을 지정하는것이 낫다.

113강 NTILE function in SQL Server
NTILE() 함수
=>sql server 2005부터 지원
=>Order By 절이 필요하다.
=>Partition By절은 optional하다.
=>명시된 그룹수로 행들을 분배하나.
=>만약 행의 수가 그룹 수로 나눠지지 않으면 2개의 다른 사이즈의 그룹을 갖게된다.
=>큰그룹이 먼저 나온다.

10행의 NTile(2)는 행들을 2개의 그룹으로 나눈다(그룹당 5행)
10행의 NTile(3)는 행들을 3개의 그룹으로 나눈다(1그룹: 4행 2,3그룹: 3행)

Partition By 없는 NTile()함수
SELECT Name, Gender, Salary,
NTILE(3) OVER (ORDER BY Salary) AS [Ntile]
FROM Employees
Id Name Gender Salary NTile
1, 'Mark', 'Male', 5000 1
2, 'John', 'Male', 4500 1
3, 'Pam', 'Female', 5500 1
4, 'Sara', 'Female', 4000 1
5, 'Todd', 'Male', 3500 2
6, 'Mary', 'Female', 5000 2
7, 'Ben', 'Male', 6500 2
8, 'Jodi', 'Female', 7000 3
9, 'Tom', 'Male', 5500 3
10, 'Ron', 'Male', 5000 3

행의 수보다 그룹수가 많을때는 1행당 1그룹 배치.
10개의 행일때 10그룹까지 나온다.
SELECT Name, Gender, Salary,
NTILE(11) OVER (ORDER BY Salary) AS [Ntile]
FROM Employees

Partition By가 있는 NTile()함수
파티션 마다 그룹을 다시 나눈다.

SELECT Name, Gender, Salary,
NTILE(3) OVER (PARTITION BY GENDER ORDER BY Salary) AS [Ntile] <=Female을 3개의 그룹으로 Male을 3개의 그룹으로
FROM Employees


114강 Lead and Lag functions in SQL Server 2012
Lead(), Lag()함수
=>sql server 2005부터 지원
=>Lead()함수는 현재 행뒤에 오는 행의 data를 접근할때 쓰여진다.
=>Lag()함수는 현재 행앞에 있는 행의 data를 접근할때 쓰여진다.
=>Order By 절이 필요하다.
=>Partition By절은 optional하다.

문법
LEAD(Column_Name, Offset, Default_Value) OVER (ORDER BY Col1, Col2, ...)
LAG(Column_Name, Offset, Default_Value) OVER (ORDER BY Col1, Col2, ...)

SELECT Name, Gender, Salary,
  LEAD(Salary, 2, -1) OVER (ORDER BY Salary) AS Lead_2,  <= 현재행의 앞 2행에서 Salary를 가져와라. 없으면 -1
  LAG(Salary, 1, -1) OVER (ORDER BY Salary) AS Lag_1
FROM Employees

Id Name Gender Salary Lead_2 Lag_1
1, 'Mark', 'Male', 1000 3000 -1
2, 'John', 'Male', 2000 4000 1000
3, 'Pam', 'Female', 3000 5000 2000
4, 'Sara', 'Female', 4000 6000 3000
5, 'Todd', 'Male', 5000 7000 4000
6, 'Mary', 'Female', 6000 8000 5000
7, 'Ben', 'Male', 7000 9000 6000
8, 'Jodi', 'Female', 8000 9500 7000
9, 'Tom', 'Male', 9000 -1 8000
10, 'Ron', 'Male', 9500 -1 9000


파티션 별로 Lead, Lag가 이루어진다.
SELECT Name, Gender, Salary,
  LEAD(Salary, 2, -1) OVER (PARTITION By Gender ORDER BY Salary) AS Lead_2,
  LAG(Salary, 1, -1) OVER (PARTITION By Gender ORDER BY Salary) AS Lag_1
FROM Employees


115강 FIRST VALUE function in SQL Server
First_Value()함수
=>sql server 2005부터 지원
=>명시된 컬럼의 첫번째 값을 가져온다.
=>Order By 절이 필요하다.
=>Partition By절은 optional하다.

문법
FIRST_VALUE(Column_Name) OVER (ORDER BY Col1, Col2, ...)

SELECT Name, Gender, Salary,
FIRST_VALUE(Name) OVER (ORDER BY Salary) AS FirstValue
FROM Employees

역시 똑같이 파티션 별로 FIRST_VALUE()함수가 작동한다.
SELECT Name, Gender, Salary,
FIRST_VALUE(Name) OVER (PARTITION BY Gender ORDER BY Salary) AS FirstValue
FROM Employees
 
116강 Window functions in SQL Server
sql server에는 다른 종류의 window function들이 있다.
Aggregate functions - AVG, SUM, COUNT, MIN, MAX etc..
Ranking functions - RANK, DENSE_RANK, ROW_NUMBER etc..
Analytic functions - LEAD, LAG, FIRST_VALUE, LAST_VALUE etc...

Over절은 위의 함수들이 조작할 partitioning과 행들의 나열(즉 window)을 정의한다.
이런 까닭에 이러한 함수들을 window function이라고 한다.
Over절은 이러한 함수들이 조작할 window를 정의하기 위해 다음과 같은 3가지 인자를 받는다.
Order By : 행들의 논리적 순서를 정의한다.
Partition By : query result set을 partition으로 나눈다. window함수는 각각의 파티션에 
따로 적용된다.
ROWS 또는 RANGE 절: 파티션안의 시작 끝을 명시함으로서 파티션안의 행들을 더 제한한다.
ROWS 또는 RANGE 절의 디폴트는 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW 이다.


다음과 같이 Salary의 평균을 계산해서 모든 행에 출력하려고 해보자
Id Name Gender Salary Average
1, 'Mark', 'Male', 1000 5450
2, 'John', 'Male', 2000 5450
3, 'Pam', 'Female', 3000 5450
4, 'Sara', 'Female', 4000 5450
5, 'Todd', 'Male', 5000 5450
6, 'Mary', 'Female', 6000 5450
7, 'Ben', 'Male', 7000 5450
8, 'Jodi', 'Female', 8000 5450
9, 'Tom', 'Male', 9000 5450
10, 'Ron', 'Male', 9500 5450

아래와 같은 query가 그 일을 할거라고 생각할지도 모른다.
SELECT Name, Gender, Salary,
  AVG(Salary) OVER(ORDER BY Salary) AS Average
FROM Employees

하지만 아래의 결과를 보듯 전체 평균을 출력하지 않는다. 현재의 행과 앞의 행들의 평균을 생성한다.
이유는 ROWS 또는 RANGE 절의 디폴트가(RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) 적용되었기때문이다.

Id Name Gender Salary Average
1, 'Mark', 'Male', 1000 1000
2, 'John', 'Male', 2000 1500
3, 'Pam', 'Female', 3000 2000
4, 'Sara', 'Female', 4000 2500
5, 'Todd', 'Male', 5000 3000
6, 'Mary', 'Female', 6000 3500
7, 'Ben', 'Male', 7000 4000
8, 'Jodi', 'Female', 8000 4500
9, 'Tom', 'Male', 9000 5000
10, 'Ron', 'Male', 9500 5450

이를 수정하기 위해선 ROWS 또는 RANGE 절을  ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING로 명시해야한다.
SELECT Name, Gender, Salary,
  AVG(Salary) OVER(ORDER BY Salary ROWS BETWEEN
  UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS Average
FROM Employees

같은 효과를 보기위해 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING을 쓸수도 있다.

ROWS와 RANGE의 차이점은 무엇인가? 다음강의에 설명!

다음의 쿼리를 써서
1.현재 행
2.현재행의 1행 앞
3.현재행의 1행 뒤
의 평균을 계산할수 있다.

SELECT Name, Gender, Salary,
  AVG(Salary) OVER(ORDER BY Salary
  ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING) AS Average
FROM Employees

117강 Difference between rows and range
Name Salary RunningTotal
'Mark', 1000 1000
'John', 2000 3000
'Pam', 3000 6000
'Sara', 4000 10000
'Todd', 5000 15000

RunningTotal 구하기
SELECT Name, Salary,
  SUM(Salary) OVER(ORDER BY Salary) AS RunningTotal
FROM Employees

위의 query는 명시적으로 ROWS, Range절을 쓰지 않았다.
그래서 디폴트인 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW를 쓰게 된다.

ELECT Name, Salary,
  SUM(Salary) OVER(ORDER BY Salary
  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS RunningTotal
FROM Employees

RANGE를 ROWS로 바꿔 써도 같은 결과를 얻을수 있다.

SELECT Name, Salary,
  SUM(Salary) OVER(ORDER BY Salary
  ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS RunningTotal
FROM Employees

ROWS와 RANGE의 차이점은?
차이를 이해하기 위해 중복되는 값으로 바꾸어보자
Update Employees set Salary = 1000 where Id = 2
Update Employees set Salary = 3000 where Id = 4

아래 query를 실행하면 
SELECT Name, Salary,
  SUM(Salary) OVER(ORDER BY Salary
  ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS RunningTotal
FROM Employees

Name Salary RunningTotal
'Mark', 1000 1000
'John', 1000 2000
'Pam', 3000 5000
'Sara', 3000 80000
'Todd', 5000 13000

RANGE로 바꾸어 실행하면
SELECT Name, Salary,
  SUM(Salary) OVER(ORDER BY Salary
  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS RunningTotal
FROM Employees

Name Salary RunningTotal
'Mark', 1000 2000
'John', 1000 2000
'Pam', 3000 8000
'Sara', 3000 8000
'Todd', 5000 13000

예상대로 나오지 않는다. ROWS와 RANGE의 주요 차이점은 중복된 행들이 어떻게 되는가?이다.
ROWS는 중복들을 distinct values로 다루는반면 RANGE는 single Entity로 다룬다.


118강 LAST VALUE function in SQL Server
Last_Value()함수
=>sql server 2012부터 지원
=>명시된 컬럼의 마지막 값을 가져온다.
=>Order By 절이 필요하다.
=>Partition By절은 optional하다.
=>Rows, Range절은 optional, 그러나 원하는대로 동작하지 않으면 명시적으로 써줘야된다.

문법
LAST_VALUE(Column_Name) OVER (ORDER BY Col1, Col2, ...)

Salary가 가장 높은 사람을 찾고 싶다.
SELECT Name, Gender, Salary,
  LAST_VALUE(Name) OVER (ORDER BY Salary) AS LastValue
FROM Employees
예측대로 동작하지 않는다.
ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING 를 써서 전체중에 가장 높은 사람을 구하자

SELECT Name, Gender, Salary,
  LAST_VALUE(Name) OVER (ORDER BY Salary ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS LastValue
FROM Employees

성별로 파티션예제
SELECT Name, Gender, Salary,
  LAST_VALUE(Name) OVER (PARTITION BY Gender ORDER BY Salary
  ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS LastValue
FROM Employees


119강 UNPIVOT in SQL Server
Pivot operator는 컬럼들을 행들로 바꾼다. 반면에 Unpivot은 컬럼들을 행들로 바꾼다.

SalesAgent India US UK
'David', 960, 520, 360
'John', 970, 540, 800


SELECT SalesAgent, Country, SalesAmount
FROM tblProductSales
UNPIVOT
(
       SalesAmount
       FOR Country IN (India, US ,UK)
) AS UnpivotExample

SalesAgent Country SalesAmount
David India 960
David US 520
David UK 360
John India 970
John US 540
John UK 800


120강 Reverse PIVOT table in SQL Server
Pivot operator가 한것을 Unpivot operator로 되돌리는것이 항상 가능한가?
아니요, 항상은 안된다. 만약 Pivot이 데이타를 집계하지 않았으면 가능하지만 집계가 이루어 졌다면 Unpivot으로 원본데이타로 돌아갈수 없다.

'David','India',960
'David','US',520
'John','India',970
'John','US',540

Pivot하면?
SELECT SalesAgent, India, US
FROM tblProductSales
PIVOT
(
 SUM(SalesAmount)
 FOR Country IN (India, US)
) AS PivotTable

SalesAgent India US
David 960 520
John 970 540

다음으로 다시 Unpivot하면 원본데이타가 나온다.
SELECT SalesAgent, Country, SalesAmount
FROM
(SELECT SalesAgent, India, US
FROM tblProductSales
PIVOT
(
 SUM(SalesAmount)
 FOR Country IN (India, US)
) AS PivotTable) P
UNPIVOT
(
 SalesAmount
 FOR Country IN (India, US)
) AS UnpivotTable

위의 경우 Unpivot했을때 원본데이타를 얻을수 있었다. 왜냐하면 SUM() 집계합수가 사실상 집계를 하지 않았기때문이다.(중복이 없어서 집계할것이 없었다)

Insert into tblProductSales values('David','India',100) 을 실행하여 중복을 넣으면?

SalesAgent Country SalesAmount
David India 960
David US 520
David UK 360
John India 970
John US 540
John UK 800
David,India,100

Pivot하면
SELECT SalesAgent, India, US
FROM tblProductSales
PIVOT
(
 SUM(SalesAmount)
 FOR Country IN (India, US)
) AS PivotTable

SalesAgent India US
David 1060 520
John 970 540

Unpivot하면
SELECT SalesAgent, Country, SalesAmount
FROM
(SELECT SalesAgent, India, US
FROM tblProductSales
PIVOT
(
 SUM(SalesAmount)
 FOR Country IN (India, US)
) AS PivotTable) P
UNPIVOT
(
 SalesAmount
 FOR Country IN (India, US)
) AS UnpivotTable

행이 1개가 사라져 있다. 데이타베이스는 집계 정보를 알수가 없어 원본데이타로 되돌리는 것이 불가능하다.
David India 1060
David US 520
David UK 360
John India 970
John US 540
John UK 800



121강 Choose function in SQL Server
Choose()함수
=>sql server 2012부터 지원
=>사용가능한 값들의 리스트로 부터 명시된 값을 리턴한다.
=>index위치는 1부터 시작이다.(0 아님)

문법
CHOOSE( index, val_1, val_2, ... )

SELECT CHOOSE(2, 'India','US', 'UK') AS Country <= US 출력

다른예
'Mark', '01/11/1980' JAN
'John', '12/12/1981' DEC
'Amy', '11/21/1979' NOV
'Ben', '05/14/1978' MAY
'Sara', '03/17/1970' MAR
'David', '04/05/1978' APR

CASE문 사용하여 Month를 만들기
SELECT Name, DateOfBirth,
  CASE DATEPART(MM, DateOfBirth)
      WHEN 1 THEN 'JAN'
      WHEN 2 THEN 'FEB'
      WHEN 3 THEN 'MAR'
      WHEN 4 THEN 'APR'
      WHEN 5 THEN 'MAY'
      WHEN 6 THEN 'JUN'
      WHEN 7 THEN 'JUL'
      WHEN 8 THEN 'AUG'
      WHEN 9 THEN 'SEP'
      WHEN 10 THEN 'OCT'
      WHEN 11 THEN 'NOV'
      WHEN 12 THEN 'DEC'
  END
  AS [MONTH]
FROM Employees

Case사용했을때 코드가 너무 많다. Choose()함수를 사용하여 줄일수 있다.

SELECT Name, DateOfBirth,CHOOSE(DATEPART(MM, DateOfBirth),
       'JAN', 'FEB', 'MAR', 'APR', 'MAY', 'JUN', 'JUL', 'AUG',
       'SEP', 'OCT', 'NOV', 'DEC') AS [MONTH]
FROM Employees


122강 IIF function in SQL Server
Choose()함수
=>sql server 2012부터 지원
=>Boolean expression에따라 2개중 하나의 값을 리턴한다.
=>case 표현식의 축약판이다.

문법
IIF ( boolean_expression, true_value, false_value )

DECLARE @Gender INT
SET @Gender = 1
SELECT IIF( @Gender = 1, 'Male', 'Femlae') AS Gender


Case문
SELECT Name, GenderId,
        CASE WHEN GenderId = 1
                      THEN 'Male'
                      ELSE 'Female'
                   END AS Gender
FROM Employees

IIF문
SELECT Name, GenderId, IIF(GenderId = 1, 'Male', 'Female') AS Gender
FROM Employees


122강 TRY PARSE function in SQL Server 2012
Try_Parse()함수
=>sql server 2012부터 지원
=>string을 Date/Time 이나 숫자로 변환한다.
=>명시된 형으로 변환하지 못하면 NULL 리턴
=>.net Framework Common Language Runtime(CLR) 필요
문법
TRY_PARSE ( string_value AS data_type )

SELECT TRY_PARSE('99' AS INT) AS Result <= 99
SELECT TRY_PARSE('ABC' AS INT) AS Result <= NULL

에러메세지 출력을 위해 Case, IIF사용
SELECT
CASE WHEN TRY_PARSE('ABC' AS INT) IS NULL
           THEN 'Conversion Failed'
           ELSE 'Conversion Successful'
END AS Result

SELECT IIF(TRY_PARSE('ABC' AS INT) IS NULL, 'Conversion Failed',
                 'Conversion Successful') AS Result


PARSE와 TRY_PARSE의 차이점
PARSE()는 변환 실패시 에러 반번 Try_Parse()는 변환 실패시 NULL리턴


124강 TRY CONVERT function in SQL Server 2012
Try_Convert()함수
=>sql server 2012부터 지원
=>string을 명시된 데이타타입으로 변환
=>명시된 형으로 변환하지 못하면 NULL 리턴
=>만약 요청된 변환이 명시적으로 허용된것이 아니면 Try_Convert()가 에러 발생
문법
TRY_CONVERT ( data_type, value, [style] )
style은 optional.(msdn 볼것)


SELECT TRY_CONVERT(INT, '99') AS Result
SELECT TRY_CONVERT(INT, 'ABC') AS Result <= NULL
SELECT TRY_CONVERT(XML, 10) AS Result <= int의 XML로 변환은 명시적으로 허가되지 않으므로 에러 발생!

Case문을 통해 에러 메세지 출력
SELECT
CASE WHEN TRY_CONVERT(INT, 'ABC') IS NULL
           THEN 'Conversion Failed'
           ELSE 'Conversion Successful'
END AS Result

IIF를 통해 에러 메세지 출력
SELECT IIF(TRY_CONVERT(INT, 'ABC') IS NULL, 'Conversion Failed',
                 'Conversion Successful') AS Result

Convert()와 Try_Convert()차이점
Convert()는 변환에 실패 하면 에러 발생, 반면 Try_Convert()는 에러대신 NULL리턴
SELECT CONVERT(INT, 'ABC') AS Result <= Error
SELECT TRY_CONVERT(INT, 'ABC') AS Result <= NULL 리턴


Try_Parse()와 Try_Convert() 차이점
Try_Parse()는 string을 date/time또는 number data로 변환한다. 다른 datatype은 변경 불가능하다
Try_Convert()는 general type에대한 변환에도 쓰인다. 예를 들면 string을 XML로 변환할수 있다.

SELECT TRY_CONVERT(XML, '<root><child/></root>') AS [XML] <= XML로 변환
SELECT TRY_PARSE('<root><child/></root>' AS XML) AS [XML] <= 에러 Invalid data type xml in function TRY_PARSE

Try_Parse()는 .net CLR에 의존 Try_Convert()는 의존하지 않는다.


125강 EOMONTH function in SQL Server 2012
EOMONTH()함수 (End Of MONTH)
=>sql server 2012부터 지원
=>명시된 date의 달의 마지날 날을 리턴
문법
EOMONTH ( start_date [, month_to_add ] )

SELECT EOMONTH('11/20/2015') AS LastDay => 30/11/2016

SELECT EOMONTH('3/20/2016', 2) AS LastDay => 29/02/2016

SELECT Name, DateOfBirth, DATEPART(DD,EOMONTH(DateOfBirth)) AS LastDay <= 마지막 날의 일수만 뽑기
FROM Employees


126강 DATEFROMPARTS function in SQL Server
DATEFROMPARTS()함수
=>sql server 2012부터 지원
=>명시된 year, moth, day를위한 date를 리턴
=>3가지 파라메터 (year, month, dat)는 모두 integer 
=>잘못된 인자가 입력되면 에러 발생
=>인자중 하나라도 NULL이 있으면 NULL리턴
문법
DATEFROMPARTS ( year, month, day )

SELECT DATEFROMPARTS ( 2015, 10, 25) AS [Date] <= 25/10/2015

SELECT DATEFROMPARTS ( 2015, 15, 25) AS [Date]
<=Cannot construct data type date, some of the arguments have values which are not valid.

sql server 2012에서 도입된 새로운 날짜 함수들
EOMONTH 

DATETIMEFROMPARTS : DateTime 리턴
문법
DATETIMEFROMPARTS ( year, month, day, hour, minute, seconds, milliseconds )

SMALLDATETIMEFROMPARTS : SmallDateTime리턴
문법
SMALLDATETIMEFROMPARTS ( year, month, day, hour, minute )

나중에 살펴볼 함수들
TIMEFROMPARTS
DATETIME2FROMPARTS
DATETIMEOFFSETFROMPARTS


127강 Difference between DateTime and SmallDateTime in SQL Server
차이점 정리
          SmallDateTime                           DateTime
날짜범위 January 1, 1900, through June 6, 2079	  January 1, 1753, through December 31, 9999
시간범위 00:00:00 through 23:59:59	              00:00:00 through 23:59:59.997
정확도    1 Minute	                              3.33 Milli-seconds
사이즈    4byte                                   8byte
디폴트값  1900-01-01 00:00:00	                    1900-01-01 00:00:00	

범위 밖의 날짜를 입력하면 에러
Insert into Employees ([SmallDateTime]) values ('01/01/1899')
Insert into Employees ([SmallDateTime]) values ('07/06/2079')
Insert into Employees ([DateTime]) values ('01/01/1752')
The conversion of a varchar data type to a smalldatetime data type resulted in an out-of-range value

정확도는 반올림관련된 설명인데 별로 중요하진 않은듯...스킵


128강 DateTime2FromParts function in SQL Server 2012
DateTime2FromParts()함수
=>sql server 2012부터 지원
=>DateTime2 리턴
=>모든 파라메터는 integer type이다.
=>잘못된 인자가 들어오면 error 리턴
=>NULL이 입력되면 NULL리턴
=>만약 precision인자가 NULL이면 함수는 에러 리턴
문법
DATETIME2FROMPARTS ( year, month, day, hour, minute, seconds, fractions, precision )

SELECT DATETIME2FROMPARTS ( 2015, 11, 15, 20, 55, 55, 0, 0 ) AS [DateTime2]
2015-11-15 20:55:55

SELECT DATETIME2FROMPARTS ( 2015, NULL, 15, 20, 55, 55, 0, 0 ) AS [DateTime2]
NULL

SELECT DATETIME2FROMPARTS ( 2015, 15, 15, 20, 55, 55, 0, NULL ) AS [DateTime2]
에러
Scale argument is not valid. Valid expressions for data type datetime2 scale argument are integer constants and integer constant expressions.

SELECT DATETIME2FROMPARTS ( 2015, 11, 15, 20, 55, 55, 5, 4 ) AS [DateTime2]
2015-11-15 20:55:55:0005

TimerFromParts()함수
=>time 리턴
문법
TIMEFROMPARTS ( hour, minute, seconds, fractions, precision )


129강 Difference between DateTime and DateTime2 in SQL Server
               DateTime                                            DateTime2
날짜범위 January 1, 1753, through December 31, 9999		  January 1, 0001, through December 31, 9999

시간범위 00:00:00 through 23:59:59.997		              00:00:00 through 23:59:59.9999999
정확도    3.33 Milli-seconds		                        100 nanoseconds
사이즈    8byte                                         6-8byte(precision에 따라 다르다)
디폴트값  1900-01-01 00:00:00	                          1900-01-01 00:00:00	

Datetime2가 Datetime보다 범위가 넓으며 훨씩 정확하다.
Datetime2를 쓰는 것을 추천하며 Datetime을 쓰는 단하나의 이유는 하위 호환성뿐이다.

문법
DATETIME2 [ (fractional_seconds_precision) ]
=>초의 소수부 precision을 지정할수있다.
=>precision은 0-7
=>디폴트 precision은 7
=>precision1-2 6byte, precision3-4 7byte, precision5-7 8byte

DECLARE @TempTable TABLE
(
    DateTime2Precision1 DATETIME2(1),
    DateTime2Precision2 DATETIME2(2),
    DateTime2Precision3 DATETIME2(3),
    DateTime2Precision4 DATETIME2(4),
    DateTime2Precision5 DATETIME2(5),
    DateTime2Precision6 DATETIME2(6),
    DateTime2Precision7 DATETIME2(7)
)

Insert DateTime value into each column
INSERT INTO @TempTable VALUES
(  
    '2015-10-20 15:09:12.1234567',
    '2015-10-20 15:09:12.1234567',
    '2015-10-20 15:09:12.1234567',
    '2015-10-20 15:09:12.1234567',
    '2015-10-20 15:09:12.1234567',
    '2015-10-20 15:09:12.1234567',
    '2015-10-20 15:09:12.1234567'
)

The following query retrieves the prcision, the datetime value, and the storage size.
SELECT 'Precision - 1' AS [Precision],
         DateTime2Precision1 AS DateValue,
         DATALENGTH(DateTime2Precision1) AS StorageSize
FROM @TempTable

UNION ALL

SELECT 'Precision - 2',
         DateTime2Precision2,
         DATALENGTH(DateTime2Precision2) AS StorageSize
FROM @TempTable

UNION ALL

SELECT 'Precision - 3',
         DateTime2Precision3,
         DATALENGTH(DateTime2Precision3)
FROM @TempTable

UNION ALL

SELECT 'Precision - 4',
         DateTime2Precision4,
         DATALENGTH(DateTime2Precision4)
FROM @TempTable

UNION ALL

SELECT 'Precision - 5',
         DateTime2Precision5,
         DATALENGTH(DateTime2Precision5)
FROM @TempTable

UNION ALL

SELECT 'Precision - 6',
         DateTime2Precision6,
         DATALENGTH(DateTime2Precision6)
FROM @TempTable

UNION ALL
SELECT 'Precision - 7',
         DateTime2Precision7,
         DATALENGTH(DateTime2Precision7) AS StorageSize
FROM @TempTable

Precision DateValue StorageSize
0 2-15-10-20 15:09:12.0000000 6
1 2-15-10-20 15:09:12.1000000 6
2 2-15-10-20 15:09:12.1200000 6
3 2-15-10-20 15:09:12.1230000 7
4 2-15-10-20 15:09:12.1234000 7
5 2-15-10-20 15:09:12.1234500 8
6 2-15-10-20 15:09:12.1234560 8
7 2-15-10-20 15:09:12.1234567 8


130강 Offset fetch next in SQL Server 2012
sql 개발자의 흔한 일중하나는 result셋의 한페이지를 리턴해주는 sp를 만드는것이다.
sql server 2012의 OFFSET FETCH절은 paging구현을 아주 쉽게 만든다.

tblProducts에 100개의 행이 있다고 하자.

다음의 스크립트로 100개의 행을 populate한다.
Declare @Start int
Set @Start = 1

Declare @Name varchar(25)
Declare @Description varchar(50)

While(@Start <= 100)
Begin
  Set @Name = 'Product - ' + LTRIM(@Start)
  Set @Description = 'Product Description - ' + LTRIM(@Start)
  Insert into tblProducts values (@Name, @Description, @Start * 10)
  Set @Start = @Start + 1
End

OFFSET FETCH 절
=> sql server 2012부터 사용가능하다
=> result셋으로 부터 result의 한페이지를 리턴한다.
=> Order By절이 필요하다.

OFFSET FETCH 문법
SELECT * FROM Table_Name
ORDER BY Column_List
OFFSET Rows_To_Skip ROWS
FETCH NEXT Rows_To_Fetch ROWS ONLY

1.Id로 테이블 정렬
2.첫 10행을 스킵
3.다음 10행을 가져온다.
SELECT * FROM tblProducts
ORDER BY Id
OFFSET 10 ROWS
FETCH NEXT 10 ROWS ONLY

일반적으로 fontend application으로부터 PageNumber와 PageSize를 얻는다.
다음 sp는 PageNumber, PageSize를 파라메터로 받아 정확한 행들을 리턴한다.

CREATE PROCEDURE spGetRowsByPageNumberAndSize
@PageNumber INT,
@PageSize INT
AS
BEGIN
  SELECT * FROM tblProducts
  ORDER BY Id
  OFFSET (@PageNumber - 1) * @PageSize ROWS
  FETCH NEXT @PageSize ROWS ONLY
END

EXECUTE spGetRowsByPageNumberAndSize 3, 10


131강 Identifying object dependencies in SQL Server
다음 sql스크립트는 2개의 테이블 2개의 sp와 1개의 view를 생성한다.
Create table Departments
(
    Id int primary key identity,
    Name nvarchar(50)
)
Go

Create table Employees
(
    Id int primary key identity,
    Name nvarchar(50),
    Gender nvarchar(10),
    DeptId int foreign key references Departments(Id)
)
Go

Create procedure sp_GetEmployees
as
Begin
    Select * from Employees
End
Go

Create procedure sp_GetEmployeesandDepartments
as
Begin
    Select Employees.Name as EmployeeName,
                   Departments.Name as DepartmentName
    from Employees
    join Departments
    on Employees.DeptId = Departments.Id
End
Go

Create view VwDepartments
as
Select * from Departments
Go

Departments를 삭제하려하면 Employees의 foreign key 제약 때문에 삭제가 안된다.
Employees를 삭제하면 삭제된다. 하지만 sp_GetEmployees, sp_GetEmployeesandDepartments, VwDepartments는 Employees에 의존하고 있으며
sp와 view를 실행하면 에러가 난다. 이러한 상황을 막기 위해 dependency를 파악하는 것은 중요하다.

Sql Server Management Studio에서 dependency를 찾는 방법
=>Object explorer에서 원하는 Object의 context menu>view dependency를 클릭
object에 dependency가 있는 object들과 object가 의존하는 object 전부를 볼수있다.


132강 sys dm sql referencing entities in SQL Server
다음의 dynamic management function들을 사용하여 종속성을 알수있다.
sys.dm_sql_referencing_entities
sys.dm_sql_referenced_entities

Select * from sys.dm_sql_referencing_entities('dbo.Employees','Object')

referencing entity와 referenced entity의 차이점
어떤 object가 다른 저장되는 object안의 sql statement안에서 이름으로 나타날때 종속성이 생성된다.
sql expression안에 나타나있는 object를 referenced entity라하고 sql expression을 가지고 있는 object를 referencing entity라고 한다.

sp_GetEmployeesandDepartments이 참조하고 있는 모든 entity를 리턴한다.
sp_GetEmployeesandDepartments
Select * from
sys.dm_sql_referenced_entities('dbo.sp_GetEmployeesandDepartments','Object')

주의: 위의 두 dynamic management함수는 반드시 schema name(dbo.sp_GetEmployeesandDepartments)을 써야한다.
만약 schema name을 쓰지 않으면 아무 결과도 얻지 못한다.

Schema-bound dependency 와 Non-schema-bound dependency의 차이점
Schema-bound dependency: 참조하고 있는 object가 있는한 참조되고 있는 object는 drop되거나 수정될수 없다.
예) SCHEMABINDING 옵션으로 생성된 view, foreign key constraint를 가진 table

Non-schema-bound dependency: 참조되고 있는 object의 drop이나 수정을 제한하지 않는다.


133강 sp depends in SQL Server
sp_depends는 deprecation이며 앞으로 없어진다. 132강의 dynamic management 함수를 써라.
Execute sp_depends 'ObjectName'
=>ObjectName이 table이면 table에 의존하는 view, procedure들이 리턴
=>ObjectName이 view 또는 procedure이면 의존하고 있는 table또는 view들을 리턴한다.

Create table Employees
(
    Id int primary key identity,
    Name nvarchar(50),
    Gender nvarchar(10)
)
Go

Create procedure sp_GetEmployees
as
Begin
    Select * from Employees
End
Go

sp_depends 'Employees'를 하면 employees에 종속적인 sp_GetEmployees가 출력된다.(table이므로)

sp_depends는 종속성을 제대로 리포트하지 못하는 문제가 있다.
Drop table Employees
Create table Employees
(
    Id int primary key identity,
    Name nvarchar(50),
    Gender nvarchar(10)
)

Employees를 drop뒤 다시 Create했을때
sp_depends 'Employees' <= 종속성 보고가 없다!

걍 쓰지 마라.


134강 Sequence object in SQL Server 2012
Sequence object
=> 2012에 도입
=> 오름, 내림 차순으로 숫자 값의 Sequence를 생성

CREATE SEQUENCE [schema_name . ] sequence_name
    [ AS [ built_in_integer_type | user-defined_integer_type ] ]
    [ START WITH <constant> ]
    [ INCREMENT BY <constant> ]
    [ { MINVALUE [ <constant> ] } | { NO MINVALUE } ]
    [ { MAXVALUE [ <constant> ] } | { NO MAXVALUE } ]
    [ CYCLE | { NO CYCLE } ]
    [ { CACHE [ <constant> ] } | { NO CACHE } ]
    [ ; ]


int 형으로 1에서부터 시작하여 1씩 증가하는 sequnece object
CREATE SEQUENCE [dbo].[SequenceObject] 
AS INT
START WITH 1
INCREMENT BY 1

sequnece로 부터 값 가져오기
SELECT NEXT VALUE FOR [dbo].[SequenceObject]

현재 값을 가져오고 싶다면
SELECT * FROM sys.sequences WHERE name = 'SequenceObject'

sequence object의 값을 리셋
ALTER SEQUENCE [SequenceObject] RESTART WITH 1

sequence를 사용하여 insert
INSERT INTO Employees VALUES
(NEXT VALUE for [dbo].[SequenceObject], 'Ben', 'Male')
INSERT INTO Employees VALUES
(NEXT VALUE for [dbo].[SequenceObject], 'Sara', 'Female')

줄어드는 sequence
CREATE SEQUENCE [dbo].[SequenceObject] 
AS INT
START WITH 100
INCREMENT BY -1

min, max를 가진 sequence
CREATE SEQUENCE [dbo].[SequenceObject]
  START WITH 100
  INCREMENT BY 10
  MINVALUE 100
  MAXVALUE 150

SELECT NEXT VALUE FOR [dbo].[SequenceObject] 로 15을 넘기면 에러 출력
The sequence object 'SequenceObject' has reached its minimum or maximum value. Restart the sequence object to allow new values to be generated.

cycle옵션
ALTER SEQUENCE [dbo].[SequenceObject]
  INCREMENT BY 10
  MINVALUE 100
  MAXVALUE 150
  CYCLE
150을 넘어가면 다시 100부터 시작한다.

cache옵션 숫자를 디스크가 아닌 메모리에서 읽는다. 10개의 숫자를 메모리로 캐시하는 명령
CREATE SEQUENCE [dbo].[SequenceObject]
  START WITH 1
  INCREMENT BY 1
  CACHE 10

Programmability > Sequence 폴더에서 GUI로 생성 및 조작 가능하다.


135강 Difference between sequence and identity in SQL Server
identity 속성은 table 컬럼 속성이며 이는 table에 묶여있다는 것을 의미한다.
반면 sequence는 user-defined database object이고 어떠한 테이블에서도 묶여있지 않다.
sequence의 가치는 여러 테이블간에 공유가 가능하다는 점이다.

2개의 테이블에 공유되는 sequence
INSERT INTO Customers VALUES
   (NEXT VALUE for [dbo].[SequenceObject], 'Ben', 'Male')
INSERT INTO Customers VALUES
   (NEXT VALUE for [dbo].[SequenceObject], 'Sara', 'Female')

INSERT INTO Users VALUES
   (NEXT VALUE for [dbo].[SequenceObject], 'Tom', 'Male')
INSERT INTO Users VALUES
   (NEXT VALUE for [dbo].[SequenceObject], 'Pam', 'Female')
INSERT INTO Users VALUES
   (NEXT VALUE for [dbo].[SequenceObject], 'David', 'Male')
GO

identity를 증가 시키기 위해서는 행을 insert해야하지만 sequence는 insert할 필요가 없다.
NEXT VALUE FOR절은 쓰면 다음 값을 생성할수 있다.
INSERT INTO Employees VALUES ('Todd', 'Male')
SELECT NEXT VALUE FOR [dbo].[SequenceObject]


identity값은 max값을 설정할수없다.컬럼의 datatype에 따른다. sequence는 있다.

identity값은 CYCLE옵션이 없어 자동으로 리셋이 불가능 하지만 sequence는 가능하다.


136강 Guid in SQL Server
Guid는 global하게 unique한 16byte binary datatype이다. Global Unique IDentifier를 의미한다.
Guid와 UNIQUEIDENTIFIER는 교환가능한 같은 용어이다.

Guid 변수를 생성하기 위해 UNIQUEIDENTIFIER 키워드를 사용한다.
Declare @ID UNIQUEIDENTIFIER
SELECT @ID = NEWID()
SELECT @ID as MYGUID

NEWID()함수를 사용하여 Guid를 생성한다.
SELECT NEWID()
0BB83607-00D7-4B2C-8695-32AD3812B6F4

언제 Guid를 써야 하는지 예를 들어보자
1. 2나라에서 비즈니스를 하고 있다고 가정(usa, india)
2. usa는 usa db를 쓰고 있다.
Create Database USADB
Go

Use USADB
Go

Create Table USACustomers
(
     ID int primary key identity,
     Name nvarchar(50)
)
Go

Insert Into USACustomers Values ('Tom')
Insert Into USACustomers Values ('Mike')

Select * From USADB.dbo.USACustomers

3. india는 india db를 쓰고 있다.
Create Database USADB
Go

Use USADB
Go

Create Table USACustomers
(
     ID int primary key identity,
     Name nvarchar(50)
)
Go

Insert Into USACustomers Values ('Tom')
Insert Into USACustomers Values ('Mike')

Select * From USADB.dbo.USACustomers

둘다 int를 id로서 쓰고 있으며 이는 각각 unique하다.

4. 2나라의 모든 customer를 합쳐서 보고 싶다.
Create Table Customers
(
     ID int primary key,
     Name nvarchar(50)
)

Go

Insert Into Customers
Select * from IndiaDB.dbo.IndiaCustomers
Union All
Select * from USADB.dbo.USACustomers

여기서 에러가 발생한다. 이는 양쪽 테이블의 identity컬럼의 datatype이 int이기때문이다. 
한테이블에서만 uniqueness를 유지하고 싶다면 integer는 매우 좋다. 하지만 IndiaCustomers와 USACustomers테이블 사이에서
Id 컬럼은 unique하지 않다.
Msg 2627, Level 14, State 1, Line 1
Violation of PRIMARY KEY constraint. Cannot insert duplicate key in object 'dbo.Customers'. The duplicate key value is (1).
The statement has been terminated.
반면 Guid는 table, database, server간에 unique하다. Guid는 전역적으로 unique함을 보장한다.

Use USADB
Go

Create Table USACustomers1
(
     ID uniqueidentifier primary key default NEWID(),
     Name nvarchar(50)
)
Go

Insert Into USACustomers1 Values (Default, 'Tom')
Insert Into USACustomers1 Values (Default, 'Mike')

Next, create IndiaCustomers1 table and populate it with data.

Use IndiaDB
Go

Create Table IndiaCustomers1
(
     ID uniqueidentifier primary key default NEWID(),
     Name nvarchar(50)
)
Go

Insert Into IndiaCustomers1 Values (Default, 'John')
Insert Into IndiaCustomers1 Values (Default, 'Ben')

Select data from both the tables (USACustomers1 & IndiaCustomers1). Notice the ID column values. They are unique across both the tables.

Select * From IndiaDB.dbo.IndiaCustomers1
UNION ALL
Select * From USADB.dbo.USACustomers1

다음 Customer1을 만들자
Create Table Customers1
(
     ID uniqueidentifier primary key,
     Name nvarchar(50)
)
Go
Insert Into Customers1
Select * from IndiaDB.dbo.IndiaCustomers1
Union All
Select * from USADB.dbo.USACustomers1

Guid의 주된 장점은 전역적 unique이다.
이는 여러 테이블로부터 한테이블로 레코드를 통합하는데 극도로 쓸모있다.

키로서 Guid를 쓰는 주된 단점은 크기가 16byte라는것이다. sql server에서 가장 큰 datatype이고 integer는 4byte이다.
Guid로 빌드된 index는 integer에비해 크기가 크며 느리다. 게다가 Guid는 읽기 어렵다.

정리하자면 Guid는 전역적인 unique identifier가 필요할때만 써라. 다른 경우에는 int를 쓰는것이 낫다.


137강 How to check GUID is null or empty in SQL Server
Guid Null체크 방법
Declare @MyGuid Uniqueidentifier
If(@MyGuid IS NULL)
Begin
     Print 'Guid is null'
End
Else
Begin
     Print 'Guid is not null'
End

Declare @MyGuid UniqueIdentifier
If(@MyGuid IS NULL)
Begin
     Set @MyGuid = NEWID()
End

Select @MyGuid

Declare @MyGuid UniqueIdentifier
Select ISNULL(@MyGuid, NewID())

Guid Empty란?
00000000-0000-0000-0000-000000000000
전부 0인 Guid

Empty Guid생성 방법
SELECT CAST(CAST(0 AS BINARY) AS UNIQUEIDENTIFIER)
또는
SELECT CAST(0x0 AS UNIQUEIDENTIFIER)

Empty Guid 체크 방법

Declare @MyGuid UniqueIdentifier
Set @MyGuid = '00000000-0000-0000-0000-000000000000'
If(@MyGuid = '00000000-0000-0000-0000-000000000000')
Begin
     Print 'Guid is Empty'
End
Else
Begin
     Print 'Guid is not Empty'
End

cast연산을 써서 체크하는 방법
Declare @MyGuid UniqueIdentifier
Set @MyGuid = '00000000-0000-0000-0000-000000000000'
If(@MyGuid = Cast(0x0 as Uniqueidentifier))
Begin
     Print 'Guid is Empty'
End
Else
Begin
     Print 'Guid is not Empty'
End


138강 Dynamic SQL in SQL Server
Dynamic SQL이란?
=> 실행시간에 string들로부터 만들어지는 sql문

다음과 같은 sp를 만들어서 Employee를 검색한다고 하자.
Create Procedure spSearchEmployees
@FirstName nvarchar(100),
@LastName nvarchar(100),
@Gender nvarchar(50),
@Salary int
As
Begin

     Select * from Employees where
     (FirstName = @FirstName OR @FirstName IS NULL) AND
     (LastName  = @LastName  OR @LastName  IS NULL) AND
     (Gender      = @Gender    OR @Gender    IS NULL) AND
     (Salary      = @Salary    OR @Salary    IS NULL)
End
Go

위의 sp는 4개의 항목밖에 없어서 복잡해조이지 않지만 만약 20개이상의 필터 조건이라면? 게다가 추가적으로 and, or같은 condition이 붙는다면
sp는 크고 복잡해지며 유지보수가 힘들게 된다. 복잡도를 낮추기위한 한가지 방법은 dynamic sql을 사용하는 것이다. 유저가 search page에서
어떠한 조건을 선택했는지에따라 실행시간에 where절을 생성해 내는것이며 이는 복잡도를 줄인다.

하지만 dynamic sql이 보안과 퍼포먼스측면에서 안좋다는 논란이 있다는 것을 들어봤을것이다.
이는 dynamic sql을 제대로 구현하지 못했을경우 사실이다. 보안관점에서 sql injection attack의 열린문이될수도 있으며 퍼포먼스 관점에서는
cached sql query plan이 재사용되지 않을수 있다. 만약 적절히 구현된다면 이런한 문제를 가지지 않는다.

간단한 dynamic sql예제를 만들어보자.
dynamic sql은 sp_executesql을 사용해 실행한다.
sp_executesql
@statement => 첫번째 파라메터이며 필수이다. 실행할 sql문을 포함한다.
@params => 두번째 파라메터이며 optional하다. @statement에서 쓰일 파라메터들을 선언하는데 쓰인다.
나머지 파라메터들은 @params에 선언한 파라메터들의 값이다. sp호출할때처럼 쓴다.

Declare @sql nvarchar(1000)
Declare @params nvarchar(1000)

Set @sql = 'Select * from Employees where FirstName=@FirstName and LastName=@LastName'
Set @params = '@FirstName nvarchar(100), @LastName nvarchar(100)'

Execute sp_executesql @sql, @params, @FirstName='Ben',@LastName='Hoskins'


139강 Implement search web page using ASP NET and Stored Procedure

spSearchEmployees를 수정하여 default로 NULL을 갖도록 수정한다.
Alter Procedure spSearchEmployees
@FirstName nvarchar(100) = NULL,
@LastName nvarchar(100) = NULL,
@Gender nvarchar(50) = NULL,
@Salary int = NULL
As
Begin

     Select * from Employees where
     (FirstName = @FirstName OR @FirstName IS NULL) AND
     (LastName  = @LastName  OR @LastName  IS NULL) AND
     (Gender      = @Gender    OR @Gender    IS NULL) AND
     (Salary      = @Salary    OR @Salary    IS NULL)
End
Go


ASP.net webform의 처리부분만 보자
using System;
using System.Configuration;
using System.Data;
using System.Data.SqlClient;

namespace DynamicSQLDemo
{
    public partial class SearchPageWithoutDynamicSQL : System.Web.UI.Page
    {
        protected void Page_Load(object sender, EventArgs e)
        {}

        protected void btnSearch_Click(object sender, EventArgs e)
        {
            string connectionStr = ConfigurationManager
                .ConnectionStrings["connectionStr"].ConnectionString;
            using(SqlConnection con = new SqlConnection(connectionStr))
            {
                SqlCommand cmd = new SqlCommand();
                cmd.Connection = con;
                cmd.CommandText = "spSearchEmployees";
                cmd.CommandType = CommandType.StoredProcedure;

                if(inputFirstname.Value.Trim() != "")
                {
                    SqlParameter param = new SqlParameter
                        ("@FirstName", inputFirstname.Value);
                    cmd.Parameters.Add(param);
                }

                if (inputLastname.Value.Trim() != "")
                {
                    SqlParameter param = new SqlParameter
                        ("@LastName", inputLastname.Value);
                    cmd.Parameters.Add(param);
                }

                if (inputGender.Value.Trim() != "")
                {
                    SqlParameter param = new SqlParameter
                        ("@Gender", inputGender.Value);
                    cmd.Parameters.Add(param);
                }

                if (inputSalary.Value.Trim() != "")
                {
                    SqlParameter param = new SqlParameter
                        ("@Salary", inputSalary.Value);
                    cmd.Parameters.Add(param);
                }

                con.Open();
                SqlDataReader rdr = cmd.ExecuteReader();
                gvSearchResults.DataSource = rdr;
                gvSearchResults.DataBind();
            }
        }
    }
}


140강 Implement search web page using ASP NET and Dynamic SQL
아래와 같이 sp가 아닌 dynamic sql구현 가능.

using System;
using System.Configuration;
using System.Data;
using System.Data.SqlClient;
using System.Text;

namespace DynamicSQLDemo
{
    public partial class SearchPageWithDynamicSQL : System.Web.UI.Page
    {
        protected void Page_Load(object sender, EventArgs e)
        { }

        protected void btnSearch_Click(object sender, EventArgs e)
        {
            string strConnection = ConfigurationManager
                .ConnectionStrings["connectionStr"].ConnectionString;

            using (SqlConnection con = new SqlConnection(strConnection))
            {
                SqlCommand cmd = new SqlCommand();
                cmd.Connection = con;

                StringBuilder sbCommand = new
                    StringBuilder("Select * from Employees where 1 = 1"); 

                if (inputFirstname.Value.Trim() != "")
                {
                    sbCommand.Append(" AND FirstName=@FirstName");
                    SqlParameter param = new
                        SqlParameter("@FirstName", inputFirstname.Value);
                    cmd.Parameters.Add(param);
                }

                if (inputLastname.Value.Trim() != "")
                {
                    sbCommand.Append(" AND LastName=@LastName");
                    SqlParameter param = new
                        SqlParameter("@LastName", inputLastname.Value);
                    cmd.Parameters.Add(param);
                }

                if (inputGender.Value.Trim() != "")
                {
                    sbCommand.Append(" AND Gender=@Gender");
                    SqlParameter param = new
                        SqlParameter("@Gender", inputGender.Value);
                    cmd.Parameters.Add(param);
                }

                if (inputSalary.Value.Trim() != "")
                {
                    sbCommand.Append(" AND Salary=@Salary");
                    SqlParameter param = new
                        SqlParameter("@Salary", inputSalary.Value);
                    cmd.Parameters.Add(param);
                }

                cmd.CommandText = sbCommand.ToString();
                cmd.CommandType = CommandType.Text;

                con.Open();
                SqlDataReader rdr = cmd.ExecuteReader();
                gvSearchResults.DataSource = rdr;
                gvSearchResults.DataBind();
            }
        }
    }
}

위의 코드에서 StringBuilder("Select * from Employees where 1 = 1"); 부분을 주목..
where 1=1을 사용함으로 해서 밑의 if문에서 where를 붙여야 하는지 말아야 하는지에대한 코드가 없어졌다.

sql profiler를 가동시켜보자.
1. SSMS 기동
2. tools > SQL Server profiler
3. localserver connect
4. run

위의 코드를 실행하면 profiler에서 dynamic sql문을 볼수있다.
exec sp_executesql N'Select * from Empolyees where 1=1 AND Gender=@Gender',N'@Gender nvarchar(4)', @Gender=N'Male'

139강에서 쓰인 sp문을 profile에서 보면 다음과 같이 나온다.
exec spSearchEmployees @Gender=N'Male'



141강 Prevent sql injection with dynamic sql
140강에서는 parammeters를 썼기때문에 sql injection attack에 당하지 않는다. 이는 좋은 dynamic sql구현이다.
많은 개발자들이 유저의 input value를 그대로 string concat하는것을 보았으며 이는 sql injection의 open door이다.

아래는 sql injection에 당하는 나쁜 dynamic sql문의 예이다.
using System;
using System.Configuration;
using System.Data;
using System.Data.SqlClient;
using System.Text;

namespace DynamicSQLDemo
{
    public partial class SearchPageWithDynamicSQL : System.Web.UI.Page
    {
        protected void Page_Load(object sender, EventArgs e)
        { }

        protected void btnSearch_Click(object sender, EventArgs e)
        {
            string strConnection = ConfigurationManager
                .ConnectionStrings["connectionStr"].ConnectionString;

            using (SqlConnection con = new SqlConnection(strConnection))
            {
                SqlCommand cmd = new SqlCommand();
                cmd.Connection = con;

                StringBuilder sbCommand = new
                    StringBuilder("Select * from Employees where 1 = 1");

                if (inputFirstname.Value.Trim() != "")
                {
                    sbCommand.Append(" AND FirstName = '" +
                        inputFirstname.Value + "'");  <= string 연결!
                }


                if (inputLastname.Value.Trim() != "")
                {
                    sbCommand.Append(" AND LastName = '" +
                        inputLastname.Value + "'");
                }

                if (inputGender.Value.Trim() != "")
                {
                    sbCommand.Append(" AND Gender = '" +
                        inputGender.Value + "'");
                }

                if (inputSalary.Value.Trim() != "")
                {
                    sbCommand.Append(" AND Salary = " + inputSalary.Value);
                }

                cmd.CommandText = sbCommand.ToString();
                cmd.CommandType = CommandType.Text;

                con.Open();
                SqlDataReader rdr = cmd.ExecuteReader();
                gvSearchResults.DataSource = rdr;
                gvSearchResults.DataBind();
            }
        }
    }
}

FirstName에 ' Drop database SalesDB -- 을 유저가 입력한다면 다음과 같은 sql이 실행된다.
Select * from Employees where 1 = 1 AND FirstName = '' Drop database SalesDB --'

만약 parameter를 써서 dynamic sql을 작성한다면 다음과 같은 sql이 생성되며 이는 문제가 되지 않는다.
exec sp_executesql N'Select * from Employees where 1 = 1 AND FirstName=@FirstName',N'@FirstName nvarchar(26)',@FirstName=N''' Drop database SalesDB --'

sp에서는 이러한 문제가 일어나지않는다.
exec spSearchEmployees @FirstName=N''' Drop database SalesDB --'
어떠한 값을 넣더라도 @FirstName의 값으로 인식된다.

여기서 중요한 점은 stored procedure안에 dynamic sql을 가지고 있고, 파라메터대신 string 결합을 통해 dynamic sql을 만들고 있다면 sql injection에 취악한것이다.

정리하면 조합되는 양이 많은 복잡한 로직을 구현할때 dynamic sql은 유연하다. 하지만 제대로 구현되지 않으면 sql injection의 open door이다.
항상 user input value를 string 결합하는 대신 parameter를 써라!

parameter를 쓰는 다른 장점은 cached query plan을 재사용할수 있게 하는것이며 이는 퍼포먼스의 극적인 향상을 가져온다.


142강 Dynamic SQL in Stored Procedure
Create Procedure spSearchEmployees
@FirstName nvarchar(100) = NULL,
@LastName nvarchar(100) = NULL,
@Gender nvarchar(50) = NULL,
@Salary int = NULL
As
Begin

     Select * from Employees where
     (FirstName = @FirstName OR @FirstName IS NULL) AND
     (LastName  = @LastName  OR @LastName  IS NULL) AND
     (Gender      = @Gender    OR @Gender    IS NULL) AND
     (Salary      = @Salary    OR @Salary    IS NULL)
End
Go
139강의 sp는 dynamic sql이 없다. 이는 sql injection에 당하지 않는다.

ASP.net같은 client application혹은 sp에 dynamic sql을 생성할때마다 어떤경우던 user input값을 string concatenate하면 안된다!
parameter를 대신 써야 한다.

아주 안좋은 예를 보자
Create Procedure spSearchEmployeesBadDynamicSQL
@FirstName nvarchar(100) = NULL,
@LastName nvarchar(100) = NULL,
@Gender nvarchar(50) = NULL,
@Salary int = NULL
As
Begin

     Declare @sql nvarchar(max)

     Set @sql = 'Select * from Employees where 1 = 1'
         
     if(@FirstName is not null)
          Set @sql = @sql + ' and FirstName=''' + @FirstName + ''''
     if(@LastName is not null)
          Set @sql = @sql + ' and LastName=''' + @LastName + ''''
     if(@Gender is not null)
          Set @sql = @sql + ' and Gender=''' + @Gender + ''''
     if(@Salary is not null)
          Set @sql = @sql + ' and Salary=''' + @Salary + ''''

     Execute sp_executesql @sql
End
Go
using System;
using System.Configuration;
using System.Data;
using System.Data.SqlClient;

namespace DynamicSQLDemo
{
    public partial class DynamicSQLInStoredProcedure : System.Web.UI.Page
    {
        protected void Page_Load(object sender, EventArgs e)
        {}

        protected void btnSearch_Click(object sender, EventArgs e)
        {
            string connectionStr = ConfigurationManager
                .ConnectionStrings["connectionStr"].ConnectionString;
            using (SqlConnection con = new SqlConnection(connectionStr))
            {
                SqlCommand cmd = new SqlCommand();
                cmd.Connection = con;
                cmd.CommandText = "spSearchEmployeesGoodDynamicSQL";
                cmd.CommandType = CommandType.StoredProcedure;

                if (inputFirstname.Value.Trim() != "")
                {
                    SqlParameter param = new SqlParameter("@FirstName",
                        inputFirstname.Value);
                    cmd.Parameters.Add(param);
                }

                if (inputLastname.Value.Trim() != "")
                {
                    SqlParameter param = new SqlParameter("@LastName",
                        inputLastname.Value);
                    cmd.Parameters.Add(param);
                }

                if (inputGender.Value.Trim() != "")
                {
                    SqlParameter param = new SqlParameter("@Gender",
                        inputGender.Value);
                    cmd.Parameters.Add(param);
                }

                if (inputSalary.Value.Trim() != "")
                {
                    SqlParameter param = new SqlParameter("@Salary",
                        inputSalary.Value);
                    cmd.Parameters.Add(param);
                }

                con.Open();
                SqlDataReader rdr = cmd.ExecuteReader();
                gvSearchResults.DataSource = rdr;
                gvSearchResults.DataBind();
            }
        }
    }
}
' Drop database SalesDB --을 넣으면 drop된다.

파라메터를 쓰면 sql injection에 당하지 않게된다.
Create Procedure spSearchEmployeesGoodDynamicSQL
@FirstName nvarchar(100) = NULL,
@LastName nvarchar(100) = NULL,
@Gender nvarchar(50) = NULL,
@Salary int = NULL
As
Begin

     Declare @sql nvarchar(max)
     Declare @sqlParams nvarchar(max)

     Set @sql = 'Select * from Employees where 1 = 1'
         
     if(@FirstName is not null)
          Set @sql = @sql + ' and FirstName=@FN'
     if(@LastName is not null)
          Set @sql = @sql + ' and LastName=@LN'
     if(@Gender is not null)
          Set @sql = @sql + ' and Gender=@Gen'
     if(@Salary is not null)
          Set @sql = @sql + ' and Salary=@Sal'

     Execute sp_executesql @sql,
     N'@FN nvarchar(50), @LN nvarchar(50), @Gen nvarchar(50), @sal int',
     @FN=@FirstName, @LN=@LastName, @Gen=@Gender, @Sal=@Salary
End
Go


143강 Sql server query plan cache
query가 실행되면 sql server에 무슨일이 일어나는가?
sql server에서는 모든 query는 실행되기 전에 query plan을 필요로한다. 처음으로 query를 실행했다면 query는 컴파일 되고
query plan이 생성되어진다. 이 query plan은 sql server query plan cache에 저장된다.

다음에 같은 query를 실행했을 경우 캐시된 query plan은 재사용된다. 이것은 sql server가 같은 query에는 query plan을 생성할 필요가 없다는것을 의미한다.
query plan을 재사용하는 것은 퍼포먼스를 향상시킨다.

자주 사용될수록 캐시에 오래 남는다.

sql server의 plan cache에 무엇이 있는지 어떻게 체크하는가?
체크하기 위해서는 다음 3가지 dynamic management view들과 함수를 사용한다.
1. sys.dm_exec_cached_plans
2. sys.dm_exec_sql_text
3. sys.dm_exec_query_plan

SELECT cp.usecounts, cp.cacheobjtype, cp.objtype, st.text, qp.query_plan
FROM sys.dm_exec_cached_plans AS cp
CROSS APPLY sys.dm_exec_sql_text(plan_handle) AS st
CROSS APPLY sys.dm_exec_query_plan(plan_handle) AS qp
ORDER BY cp.usecounts DESC

plan cache를 모두 지우기 위해서는 다음 명령을 사용한다.
DBCC FREEPROCCACHE

sql 7이후 종류에 상관없이 거의 모든것이 캐시된다.

query plan의 재사용성을 높이기 위해 고려해야 하는 것들.
Select * From Employees Where FirstName = 'Mark'
위와 같은 query를 처음 실행하였을때 query는 컴파일되고 plan이 생성되어지며 cache에 저장된다.
같은 query를 실행했을때 이미 존재하는 plan을 사용한다. 명심할점은 cache loop up은 query text의 hash를 사용해서 이루어진다.
만약 query의 text가 조금이라도 변경되면 존재하는 plan을 사용할수 없다.
예를 들면 의미 없는 스페이스 한칸, 혹은 대소문자의 변경은 새로운 plan을 만들어낸다.

Select * From Employees Where FirstName = 'Steve'
Select * From Employees Where FirstName = 'Mary'

위의 2문장도 새로운 plan을 각각 생성하게 된다.
이와 같은 이유때문에 cached query plan을 사용하는 parameterized query가 매우 중요하다.
sql server는 parameter의 값을 query text의 일부로 취급하지 않는다. 그래서 sql server는 바뀐 파라메터 값에 상관없이
cached query plan을 재사용한다.

Declare @FirstName nvarchar(50)
Set @FirstName = 'Steve'
Execute sp_executesql N'Select * from Employees where FirstName=@FN', N'@FN nvarchar(50)', @FirstName

하나 중요한것은 sp안에있는 dynamic sql이 있다고 할때 sp의 query plan은 dynamic sql의 query plan을 포함하지 않는다.
dynamic sql은 자신의 것을 따로 갖고 있다.

요약하자면 절때로! user input을 string concatenate하지 마라! parameterized query는 cached plan을 재사용할수 있게 하며
sql injection attack을 방어한다.


144강 exec vs sp executesql in sql server
sql server에는 dynamic sql을 실행하는 방법이 2가지 이다.
1. Exec/Execute
2. sp_executesql

인터넷 검색을 하면 다음과 같은 2가지 면에서 exec보다 sp_executesql이 우위에 있다는 글을 쉽게 찾을수 있다.
1. sql injection attack에 취약하다.
2. cahced query plan이 쓰여지지 않을수도있으며 이는 나쁜 퍼포먼스를 보여준다.

이말은 일반적으로 맞다. 하지만 QUOTENAME()함수를 쓰면 sql injection attack과 sql server의 auto-parameterisation기능때문에
퍼포먼스도 이슈가 되지 않는다.

exec()는 무엇인가?
Exec()/Execute()함수는 dynamic sql을 실행하기 위해 쓰여진다. 실행하기 원하는 sql문, 단 하나의 파라메터밖에 없다.
다음 예는 sql injection attack에 취약하다.

Declare @FN nvarchar(50)
Set @FN = 'John'
Declare @sql nvarchar(max)
Set @sql = 'Select * from Employees where FirstName = ''' +  @FN + ''''
Exec(@sql)

@FN을 바꾸면 database가 drop된다.

Declare @FN nvarchar(50)
Set @FN = ''' Drop Database SalesDB --'''
Declare @sql nvarchar(max)
Set @sql = 'Select * from Employees where FirstName = ''' + @FN + ''''
Exec(@sql)


하지만 다음과 같이 QUOTENAME()함수를 쓰면 sql injection을 막을수있다.

Declare @FN nvarchar(50)
Set @FN = ''' Drop Database SalesDB --'''
Declare @sql nvarchar(max)
Set @sql = 'Select * from Employees where FirstName = ' + QUOTENAME(@FN,'''')
--Print @sql
Exec(@sql)

QUOTENAME(@FN,'''')을 사용하여 ''를 delimiter로 사용한것에 주목하라. 만약 user input에 single quote가 있다면 이중화된다.

만약 @FN='John'을 이 함수에 넣는다면 'John'으로 다시 wrapped된다.

Declare @FN nvarchar(50)
Set @FN = 'John'
Declare @sql nvarchar(max)
Set @sql = 'Select * from Employees where FirstName = ' + QUOTENAME(@FN,'''')
Print @sql

위 문장을 실행시키면 아래의 query가 찍힌다.
Select * from Employees where FirstName = 'John'

만약 sql을 inject하려해도 QUOTENAME()함수가 모든 input을 다른 '의 쌍으로 감싸버리기때문에 FirstName의 값으로서 다루어지며
sql injection을 막는다.

sql server의 auto-parameterisation 기능으로 query plan은 재사용될수 있다.
sql server는 명시적으로 선언하지 않더라도 parameter value들을 감지할수 있고 그것 자체의 parameterised query를 생성한다.
하지만 이것에 예외가 있다. auto-parameterisationdms 2가지 방식으로 온다(?). Simple and Forced. 이는 나중에 살펴보자.

다음 명령으로 plan캐시를 지우자.
DBCC FREEPROCCACHE

다음을 실행해보자. Set @FN = 'Mary'을 주목!
Declare @FN nvarchar(50)
Set @FN = 'Mary'
Declare @sql nvarchar(max)
Set @sql = 'Select * from Employees where FirstName = ' + QUOTENAME(@FN,'''')
Exec(@sql)

plan캐시에 무엇이 있는지 다음으로 살펴보면
SELECT cp.usecounts, cp.cacheobjtype, cp.objtype, st.text, qp.query_plan
FROM sys.dm_exec_cached_plans AS cp
CROSS APPLY sys.dm_exec_sql_text(plan_handle) AS st
CROSS APPLY sys.dm_exec_query_plan(plan_handle) AS qp
ORDER BY cp.usecounts DESC

Prepared type의 (@1 varchar(8000))Select * from [Employees] where [FirstName]=@1 이라는 auto-parameterised query를 볼수있다.

Declare @FN nvarchar(50)
Set @FN = 'Mark'
Declare @sql nvarchar(max)
Set @sql = 'Select * from Employees where FirstName = ' + QUOTENAME(@FN,'''')
Exec(@sql)
를 실행하면 위의 auto-parameterised query의 usecounts가 올라가는 것을 확인할수있다.

요약하면
=>QUOTENAME()함수를 쓰면 Exec()사용시에 sql injection을 막을수있다.
=>sql server가 auto-parameterised query쿼리를 생성해서 plan의 재사용성에도 문제가 없다.
=>exec()보다 sp_executesql 사용을 추천한다. 
sql server의 auto-parameterisation 기능에 의존하는대신 명시적으로 parameterise할수 있기 때문이다.
exec()는 테스트 코드에만 쓰고 production code에는 쓰지 않는 것을 추천한다.


145강 Dynamic sql table name variable
sp에 table이름을 넘기는 방법에대해...이는 일반적으로 자주 묻는 질문중 하나이다.

Create procedure spDynamicTableName
@TableName nvarchar(100)
As
Begin
     Declare @sql nvarchar(max)
     Set @sql = 'Select * from ' + @TableName
     Execute sp_executesql @sql
End

위의 sp는 sql Injection에 취약한 string 결합을 쓰는 sp이다. 당연히 string결합대신 parameterised sql statement를 왜 안쓰는거지?라는 생각이 들것이다.
대답은 그게 안된다. sql server는 table name과 column name은 parameter로 전달 할 수 있게 허락하지 않는다.
다음 예를 보면 @TabName으로 parameterized query를 생성하고 있고 실행시 sp가 성공적으로 생성된다.

Create procedure spDynamicTableName1
@TableName nvarchar(100)
As
Begin
     Declare @sql nvarchar(max)
     Set @sql = 'Select * from @TabName'
     Execute sp_executesql @sql, N'@TabName nvarchar(100)',
     @TabName = @TableName
End

하지만 실행하려 할때 Must declare the table variable "@TabName" 에러를 일으킨다.

해결방법은 QUOTENAME()함수를 쓰는것이다. QUOTENAME() 함수는 다음에 자세히 살펴본다.
QUOTENAME()함수는 default로 string을 []로 감싸버린다.
SELECT QUOTENAME('Employees')
=>[Employees]

다음과 같이 QUOTENAME()사용하도록 수정한다.
Alter procedure spDynamicTableName
@TableName nvarchar(100)
As
Begin
     Declare @sql nvarchar(max)
     Set @sql = 'Select * from ' + QUOTENAME(@TableName)
     Execute sp_executesql @sql
End

'Employees; Drop database SalesDB'이 @TableName으로 입력되었을때 [Employees; Drop database SalesDB]이되며
이는 정당한 table이름이다. [Employees; Drop database SalesDB]의 table이 없기때문에 Invalid object name.에러가 발생하게 된다.


146강 Quotename function in SQL Server
Set @tableName = 'USA Customers' => 이 부분을 유저 입력으로 생각할것!

다음은 에러가 나는 코드이다.
Declare @sql nvarchar(max)
Declare @tableName nvarchar(50)
Set @tableName = 'USA Customers'
Set @sql = 'Select * from ' + @tableName
Execute sp_executesql @sql

실행하게 되면 에러
Msg 208, Level 16, State 1, Line 1
Invalid object name 'USA'.

@sql에 다음과 같은 문장이 들어가기 때문이다.
Select * from USA Customers

테이블 이름에 공백이 있으므로 다음과 같이 []로 감싸줘야한다.
Select * from [USA Customers]

위의 sp를 수정하려면 Set @tableName = '[USA Customers]'로 수정하거나
Set @sql = 'Select * from [' + @tableName +']'로 수정해야한다.

첫번째 방법으로 한다면 공격당하게 된다.
Declare @sql nvarchar(max)
Declare @tableName nvarchar(50)
Set @tableName = '[USA Customers] Drop Database SalesDB'
Set @sql = 'Select * from ' + @tableName
Execute sp_executesql @sql

두번째 방법도 마찬가지로 공격당하게 된다.
Declare @sql nvarchar(max)
Declare @tableName nvarchar(50)
Set @tableName = 'USA Customers] Drop Database SalesDB --'
Set @sql = 'Select * from [' + @tableName +']'
Execute sp_executesql @sql

따라서 제대로 수정하는 방법은 QUOTENAME()함수를 사용하여 아래와 같이 고치는것이다.
Declare @sql nvarchar(max)
Declare @tableName nvarchar(50)
Set @tableName = 'USA Customers Drop Database SalesDB --'
Set @sql = 'Select * from ' + QUOTENAME(@tableName)
Execute sp_executesql @sql

위의 코드를 실행시키면 Invalid object name 'USA Customers Drop Database SalesDB --에러가 발생하지만 SalesDB는 Drop되지 않는다.

아래의 코드는 정상적으로 실행되며 sql injection문제가 없는 코드이다.
Declare @sql nvarchar(max)
Declare @tableName nvarchar(50)
Set @tableName = 'USA Customers'
Set @sql = 'Select * from ' + QUOTENAME(@tableName)
Execute sp_executesql @sql

만약 schema name 'dbo'를 쓰고 싶다면?
Declare @sql nvarchar(max)
Declare @tableName nvarchar(50)
Set @tableName = 'dbo.USA Customers'
Set @sql = 'Select * from ' + QUOTENAME(@tableName)
Execute sp_executesql @sql

위의 query는 다음 에러를 출력하며 실패한다.
Invalid object name 'dbo.USA Customers'

Select * From [dbo].[USA Customers] <= 이렇게 []를 감싸줘야 한다.

Declare @sql nvarchar(max)
Declare @tableName nvarchar(50)
Set @tableName = 'USA Customers'
Set @sql = 'Select * from ' + QUOTENAME('dbo') + '.' + QUOTENAME(@tableName)
Execute sp_executesql @sql

QUOTENAME()함수
=>2개의 파라메터를 받는다. 첫번째는 string, 두번째는 sql server가 string을 감쌀 delimiter
=>delimiter는 '[', ']', '''', '"', 만 가능하다. 다른 문자가 들어온다면 NULL을 리턴한다. '[', ']'은 같다.
=>두번째의 디폴트 파라메터는 []이다.

SELECT QUOTENAME('USA Customers','"') => "USA Customers" 리턴
SELECT QUOTENAME('USA Customers','''') => 'USA Customers' 리턴

아래 문장은 전부  [USA Customers] 리턴
SELECT QUOTENAME('USA Customers') 
SELECT QUOTENAME('USA Customers','[') 
SELECT QUOTENAME('USA Customers',']')

SELECT QUOTENAME('USA Customers','*') => NULL 리턴

테이블 이름에 브라켓이 있다면 QUOTENAME()는 escape character로 표시하기 위해 이중화한다.
SELECT QUOTENAME('USA ] Customers') => [USA ]] Customers] 리턴

QUOTENAME()함수의 효과를 제거하기 위해 PARSENAME()을 쓴다.

Declare @tableName nvarchar(50)
Set @tableName = 'USA ] Customers'
Set @tableName = QUOTENAME(@tableName)
Print @tableName => [USA ]] Customers] 출력

Set @tableName = PARSENAME(@tableName,1)
Print @tableName => USA ] Customers 출력

PARSENAME()함수는 2가지 파라메터를 갖는다.
첫번째는 Object name, 두번째는 Object piece이다. Object piece는 int이고 다음과 같다.
1 = Object name
2 = Schema name
3 = Database name
4 = Server name
 

147강 Dynamic SQL vs Stored Procedure
1. 비즈니스 로직과 데이타베이스 로직의 분리
stored procedure는 비즈니스 로직과 데이타베이스 로직을 분리할수 있게 해준다. 분리의 장점은 둘다 체크할 필요가 없다는것.
비즈니스 로직의 문제는 어플리케이션에서 데이타베이스 로직은 sp만 체크하면 된다. sp의 또다른 장점 하나는 sp의 수정만 있을경우
어플리케이션 컴파일이 필요없다는 것이다.
만약 클라이언트 코드에서 dynamic sql을 조립하여 보내준다면 버그가 있을경우 어플리케이션을 수정해야 하므로 이러한 장점을 잃게된다.
어플리케이션 코드를 수정하는 것은 컴파일, 빌드, 배포가 필요하다.

2. 네트워크 트래픽
sp는 procedure이름과 몇개의 파라메터만 필요하므로 네트워크 트래픽을 줄인다.
dynamic sql에서는 전체 sql statement를 보내야 할수도 있다. 만약 query가 50-60라인을 가진 복잡한 쿼리라면 클라이언트 어플리케이션과
데이타베이스간의 네트워크 트래픽을 상상해보라.

3. sql injection attack
sp는 sql injection attack을 방지한다. 일반적으로 dynamic sql은 주의하지않으면 sql injection attack의 열린문이다.
하지만 dynamic sql에서도 parameterized query를 사용함으로서 sql injection attack을 막을 수 있다.
가끔 어떤경우 table명이나 column명을 파라메터로 넘겨야 할때가 있다. 그런경우 QUOTENAME()을 사용하여 막을수있다.

4. cahced query plan 재사용
sp는 cahced query plan을 재사용성을 높임으로서 퍼포먼스를 높일수있다.
dynamic sql에서도 parameterized query를 사용함으로서 cahced query plan의 재사용성을 높일수있다.
만약 parameterized query를 사용하지 않는다면 sql server의 auto-parameterisationr 기능이 자동으로 parameter를 감지해서
parameterized query생성하여 재사용성을 높인다.

중요한점은 OLTP쿼리들은 cahced query plan의 이득이있다. 하지만 data가 drift하고 optimizer의 선택이 바뀌는 OLAP 시스템은
cahced query plan 바람직하지 않을수있다.

5. 유지보수
sp안의 static sql에서는 문법에러가 바로 보고되므로 프로그램 작성이 쉽다는것이 sp의 한 장점이다. 반면 sp안에 dynamic sql이 있다면
실행전까지 어떠한 에러도 발견하지 못할것이다.
static sql을 가지고 있는 sp들은 sp_depends를 사용하여 종속성 체크를 할수 있기때문에 유지보수가 쉽다.
만약 sp에 dynamic sql을 가지고 있거나 클라이언트로부터 sql을 받는다면 이러한 이득을 잃게된다.

Create Proc myProcedure1
as
Begin
  Select * From Employees
End
Go

Create Proc myProcedure2
as
Begin
  Declare @sql nvarchar(100)
  Set @sql = 'Select * From Employees'
  Execute sp_executesql @sql
End

Execute sp_depends Employees  <= myProcedure2는 결과에 출력 안된다


6. 유연한 로직 구현
가끔은 sp가 dynamic sql에 비해 유연한 로직의 구현이 힘들때가 있다.
예를 들면 20개 이상의 필터를 가진 sp를 구현한다고하자. 이러한 sp는 구현하기가 복잡해지며 더욱 안좋은 상황은 이러한 필터들 사이에 
AND, OR등의 컨디션을 적고싶을때이다. sp는 아주 커지고 복잡해지며 유지보수하기 힘들어진다.
이러한 복잡도를 줄이는 한방법은 dynamic sql을 쓰는 것이다. 유저가 선택한 필터에따라 Where절을 런타임에 dynamic하게 만들고
이러한 것은 복잡도를 줄일수있다.


148강 Dynamic sql output parameter
성별별 total employee 구하기 만들기

Declare @sql nvarchar(max)
Declare @gender nvarchar(10)
Set @gender = 'Male'
Set @sql = 'Select Count(*) from Employees where Gender=@gender'
Execute sp_executesql @sql, N'@gender nvarchar(10)', @gender

위의 dynamic sql은 output parameter를 쓰고 있지 않다. 다음과 같이 고친다.

Declare @sql nvarchar(max)
Declare @gender nvarchar(10)
Declare @count int
Set @gender = 'Male'
Set @sql = 'Select @count = Count(*) from Employees where Gender=@gender'
Execute sp_executesql @sql, N'@gender nvarchar(10), @count int OUTPUT', @gender, @count OUTPUT
Select @count

만약 @count뒤의 OUTPUT을 빼먹는다면 @count는 NULL을 리턴한다.
sp로 만들어보자

Create procedure spEmployeeCount
@gender nvarchar(10)
@count int OUTPUT
as
Begin
  Declare @sql nvarchar(max)
  Set @sql = 'Select @count = Count(*) from Employees where Gender=@gender'
  Execute sp_executesql @sql, N'@gender nvarchar(10), @count int OUTPUT', @gender, @count OUTPUT
End

149강 Temp tables in dynamic sql
dynamic sql에서 생성된 테이블은 호출한 procedure에서 접근이 불가능하다. dynamic sql이 실행된 이후 drop된다.

Create procedure spTempTableInDynamicSQL
as
Begin
       Declare @sql nvarchar(max)
       Set @sql = 'Create Table #Test(Id int)
                           insert into #Test values (101)
                           Select * from #Test'
       Execute sp_executesql @sql
End
Execute spTempTableInDynamicSQL  <= 문제없다.

Alter procedure spTempTableInDynamicSQL
as
Begin
       Declare @sql nvarchar(max)
       Set @sql = 'Create Table #Test(Id int)
                           insert into #Test values (101)'
       Execute sp_executesql @sql
       Select * from #Test <= 에러
End
Execute spTempTableInDynamicSQL
Invalid object name '#Test'

Alter procedure spTempTableInDynamicSQL
as
Begin
       Create Table #Test(Id int)
       insert into #Test values (101)
       Declare @sql nvarchar(max)
       Set @sql = 'Select * from #Test'
       Execute sp_executesql @sql
End
Execute spTempTableInDynamicSQL <= 문제없다.

dynamic sql에의해 생성된 temp table들은 calling procedure에서 접근할 수 없다.
sp안에 있는 dynamic sql이 실행을 완료했을때 temp table들은 drop된다.
반면 dynamic sql은 calling procedure에의해 생성된 temp table들을 접근할수 있다.