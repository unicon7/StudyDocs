React Hooks Tutorial - 1 - Introduction
https://velog.io/@vies00/React-Hooks
Hooks란?
16.8에 추가된 class를 쓰지 않고 React 기능을 사용할수 있게 하는 새로운 feature이다.
예를 들면 state를 쓰려면 class component이어야만 했다.

Hooks는 class안에서 작동하지 않는다.

왜 Hooks인가?
첫번째 이유들 (react의 문제라기보다는 es6의 문제이다.)
javascript의 this를 이해하기 힘들다.
class component에서는 event handler들을 bind해야 하는 것을 기억하고 있어야 한다.
class들은 minify가 잘 되지 않으며 hot reloading을 불안정하게 만든다.

두번째 이유들 (react의 문제들)
stateful component logic을 재사용하기 위한 특별한 방법이 없다.
HOC와 render props 패턴이 이러한 문제를 해결하지만 어색하고 힘들다. 어떠한 component를 몇겹으로 둘러싸야 하며 이는 code를 따라가기 힘들게 한다.
stateful logic을 더 나은 방법으로 공유할 필요가 있다. hooks는 component 계층구조를 바꾸지 않고 stateful logic을 공유할수 있게 한다.

세번째 이유들 (복잡한 component가 이해하기 힘들어진다.)
data fetching, events subscribing같은 복잡한 시나리오를 위해 component를 생성한다. 이때 관련된 코드들이 한 곳에 조직화되어 있지 않음을 느낄것이다.
예) Data fetching - componentDidMount()에서 실행되지만 가끔은 componentDidUpdate()에서 할때도 있다.
예) Event listeners - componentDidMount()에서 subscribing하고 componentWillUnmount()에서 unsubscribing한다. 역시 event listener함수들도 다른 메서드이다.
또한 Data fetching, Event listeners들은 서로 전혀 관련 없는 코드인데도 componentDidMount()에 같이 있다!
예) stateful logic때문에 - component를 더 작게 components들로 나눌수 없다. 모든 관련된 코드들이 한 곳에 있는 것이 더 나을 것이다.
class component에서 life cycle method들에 기반해 관련된 코드를 나누는 것 보다는 Hooks는 function을 통해 관련된 코드를 나눌수 있게한다.

이 이유들로 인해 Hooks가 등장하였다.

주목할만한점
React 16.8이상
opt-in이다.
breaking change를 포함하지 않으며 100%하위 호환 가능하다.
class들은 react로부터 제거되지 않을 것이다.
class component안에서 쓸수없다.
react concept(props, state, context, refs, lifesycle)들을 대체하지 않는다. 대신 Hooks는 이미 알고 있는 react concept들에대한 보다 직접적인 API를 제공한다.

요약
class 안써도 react 기능을 쓸수있다.
this에 대한 헛갈림을 피할수있다.
stateful logic을 재사용 할수있게한다.
component안에서 재사용가능한 격리된 unit들로 조직화한다.


React Hooks Tutorial - 2 - useState Hook
첫번째 hook인 useState hook을 살펴보자
지금까지는 functional component를 사용하던중 state가 필요할경우 class component로 변환하는 방법 밖에 없었다.
class component만이 state를 사용할수 있었기때문이다. 그러나 이제는 state hook이 functional component에서도 state를 사용할수 있게한다.
Counter component를 여러개로 만들어보고 차이점을 알아보자.

ClassCounter.js
import React, { Component } from 'react'

export class ClassCounter extends Component {  <= 1
  constructor(props) {
    super(props)
  
    this.state = { <= 2
      count: 0       
    }
  }

  incrementCount = () =>{ <= 3
    this.setState({count: this.state.count + 1});
  }

  render() {
    return (
      <div>
        <button onClick={this.incrementCount}>Count {this.state.count}</button>
      </div>
    )
  }
}

export default ClassCounter
지금것 해왔던 방식이다. 하지만 다음과 같은 3단계로 제작한다는 것을 기억하자.
1.component 생성
2.state 생성 및 value 초기화
3.state의 값을 setting할수 있는 메서드 생성

위의 카운터를 이제 functional component와 state hook을 사용해서 다시 만들어보자

HookCounter.js
import React from 'react'

1번 스텝
function HookCounter() {
  return (
    <div>
      <button onClick={}>Count {}</button>
    </div>
  )
}

export default HookCounter
2,3번 과정을 통해 state를 만들어야 하나 class component가 아니기때문에 class component처럼 state를 만들수가 없다. 때문에 다른 방법이 필요하며
이 부분에서 hook이 등장한다. hook은 react feature에 hook 할수 있게 하는(hook into 할수있게 하는) 특별한 함수이다.
useState()는 functional component에 react state를 추가할수있게하는 hook이다.

2,3번 스텝
import React, {useState} from 'react'  <= useState import

function HookCounter() {
  //useState hook 혹은 function은 state property의 초기값을 인자로 받고 현재의 state property 값과 그 property를 업데이트 할수 있는 method를 리턴한다.
  //count, setCount는 임의로 원하는 대로 지을수 있다.
  const [count, setCount] = useState(0);  <= array destructuring!

  return (
    <div>
      <button onClick={() => setCount(count + 1)}>Count {count}</button>  <= count는 언제나 현재상태의 값을 가지고 있다.
    </div>
  )
}

export default HookCounter

Rules of Hooks
"Hook들은 Top level에서만 호출되어야한다."
loop, condition, nested function안에서 호출하면 안된다.
"React function에서만 Hook들을 호출해야만 한다."
React functional component안에서만 호출해야하며 일반 javascript함수에서 호출하면 안된다.

위의 규칙은 hooks가 동작하는 방법때문에 매우 중요하며 일단은 그냥 받아들이고 나중에 왜 그런지 살펴보자.

React Hooks Tutorial - 3 - useState with previous state

HookCounterTwo.js
import React, {useState} from 'react'  <= useState import

function HookCounterTwo() {
  const initialCount = 0
  const [count, setCount] = useState(initialCount);

  return (
    <div>
      Count: {count}
      <button onClick={() => setCount(initialCount)}>Reset</button>
      <button onClick={() => setCount(initialCount + 1)}>Increment</button>
      <button onClick={() => setCount(initialCount - 1)}>Decrement</button>
    </div>
  )
}
export default HookCounterTwo

위의 예제와 전 챕터에서 했던 예제는 unsafe하다. 동작되는 것처럼 보이지만 문제가 있다.
HookCounterTwo.js
import React, {useState} from 'react'  <= useState import

function HookCounterTwo() {
  const initialCount = 0
  const [count, setCount] = useState(initialCount);

  const incrementFive = () => {
    for(let i = 0; i < 5; ++i){
      setCount(count + 1);
    }
  }

  return (
    <div>
      Count: {count}
      <button onClick={() => setCount(initialCount)}>Reset</button>
      <button onClick={() => setCount(count + 1)}>Increment</button>
      <button onClick={() => setCount(count - 1)}>Decrement</button>
      <button onClick={incrementFive}>Increment 5</button>
    </div>
  )
}

Increment 5클릭시 count가 1을 출력한다. 1밖에 증가하지 않았다.

HookCounterTwo.js
import React, {useState} from 'react'  <= useState import

function HookCounterTwo() {
  const initialCount = 0
  const [count, setCount] = useState(initialCount);

  const incrementFive = () => {
    for(let i = 0; i < 5; ++i){
      setCount(prevCount => prevCount + 1);  <= setCount의 2번째 버전인 함수를 인자로 받는 버전을 넣는다.
    }
  }

  return (
    <div>
      Count: {count}
      <button onClick={() => setCount(initialCount)}>Reset</button>
      <button onClick={() => setCount(count + 1)}>Increment</button>
      <button onClick={() => setCount(count - 1)}>Decrement</button>
      <button onClick={incrementFive}>Increment 5</button>
    </div>
  )
}

Count: 5가 제대로 찍힌다. 이전 state값에 의존하는 Update는 new state를 set하는 함수를 인자로 받는 함수를 사용해야한다.
나머지도 수정해야한다.

function HookCounterTwo() {
  const initialCount = 0
  const [count, setCount] = useState(initialCount);

  const incrementFive = () => {
    for(let i = 0; i < 5; ++i){
      setCount(prevCount => prevCount + 1);  <= setCount의 2번째 버전인 함수를 인자로 받는 버전을 넣는다.
    }
  }

  return (
    <div>
      Count: {count}
      <button onClick={() => setCount(initialCount)}>Reset</button>
      <button onClick={() => setCount(prevCount => prevCount + 1)}>Increment</button>
      <button onClick={() => setCount(prevCount => prevCount - 1))}>Decrement</button>
      <button onClick={incrementFive}>Increment 5</button>
    </div>
  )
}

이전 state 값에 기초하여 update 하는 state의 값을 update하기위해서는 state setter에 함수를 전달해야한다.
class component도 setState()안에 함수를 넣는 것이 동일하다.

React Hooks Tutorial - 4 - useState with object
state로 object를 사용해보자.
HookCounterThree.js
import React, {useState} from 'react'

function HookCounterThree() {

  const [name, setName] = useState({firstName:'', lastName:''})  <= 필요에따라 어떤것이든 넣을수있다.

  return (
    <form>
      <input type="text value={name.firstName} onChange={e => setName({firstName: e.target.value})}
      <input type="text value={name.lastName} onChange={e => setName({lastName: e.target.value})}
      <h2>Your first name is - {name.firstName}</h2>
      <h2>Your last name is - {name.lastName}</h2>
    </form>
  )
}

export default HookCounterThree

다음과 같이 해보자
1번째 필드에 Vishwas를 넣으면 제대로 출력된다.
2번째 필드에 값을 넣으면 name.firstName이 사라진다.
다시 1번째 필드에 값을 넣으면 name.lastName이 사라진다.
state 변수에 뭔가 문제가 생긴것같다.

HookCounterThree.js
import React, {useState} from 'react'

function HookCounterThree() {

  const [name, setName] = useState({firstName:'', lastName:''})  <= 필요에따라 어떤것이든 넣을수있다.

  return (
    <form>
      <input type="text value={name.firstName} onChange={e => setName({firstName: e.target.value})}
      <input type="text value={name.lastName} onChange={e => setName({lastName: e.target.value})}
      <h2>Your first name is - {name.firstName}</h2>
      <h2>Your last name is - {name.lastName}</h2>
      <h2>{JSON.stringify(name)}</h2>
    </form>
  )
}

{"firstName":"", "lastName":""} <= 초기출력

firstName에 타이핑하면 
{"firstName":"Vish"} <= lastName property가 없어졌다.

이러한 현상은 새로운 state가 자동적으로 기존 state와 merge되어 update되지 않기 때문이다.
이는 class component의 setState()와 주요하게 다른 부분이다.
class component의 setState() merge를 하며 useState hook의 setter function은 state merge를 하지 않는다.
merge는 직접 해야한다. spread operator를 사용하자.

HookCounterThree.js
import React, {useState} from 'react'

function HookCounterThree() {

  const [name, setName] = useState({firstName:'', lastName:''})  <= 필요에따라 어떤것이든 넣을수있다.

  return (
    <form>
      <input type="text value={name.firstName} onChange={e => setName({...name, firstName: e.target.value})} <= name의 모든 property를 copy하고 firstName property만 새로운 값으로 update
      <input type="text value={name.lastName} onChange={e => setName({...name, lastName: e.target.value})}
      <h2>Your first name is - {name.firstName}</h2>
      <h2>Your last name is - {name.lastName}</h2>
      <h2>{JSON.stringify(name)}</h2>
    </form>
  )
}

useState hook 이 제공하는 sett function은 자동 merge를 제공하지 않는다. 직접 merge할것.


React Hooks Tutorial - 5 - useState with array
state가 array일경우를 알아보자

HookCountFour.js
import React, {useState} from 'react'

function HookCountFour() {
  const [items, setItems] = useState([]);
  const addItem = () => {
    setItems([...items, {id: items.length, value: Math.floor(Math.random() * 10) + 1}])  <= spread operator사용하여 전개하고 새로운 값 뒤에 추가!
  }

  return (
    <button onClick={addItem}>Add a number</button>
    <div>
      <ul>
      {
        items.map(item => 
        (<li key={item.id}>{item.value}</li>));
      }
      </ul>
    </div>
  )
}

export default HookCountFour

잘돌아간다.

useState hook 정리
functional componnts에 state를 사용할수있게한다.
class에서는 state는 항상 object이다.
useState hook에서 state는 항상 object일 필요가 없다.
useState hook은 2개의 요소를 가지는 array를 리턴한다.
첫번째 요소는 state의 현재 value, 두번째 요소는 setter function이다.
이전 state value에 새로운 state가 종속적이라면? setter function에 function을 pass한다.
object나 array를 다룰때 state 변수를 전개한뒤 setter function을 호출하도록하라!

React Hooks Tutorial - 6 - useEffect Hook
useEffect의 동기부터 살펴본다.
class component로 작업을 하다 보면 component안에서 side-effect를 수행할때가 있다.
예를 들면 dom update, fetching data, subscription 세팅, timer 세팅등..
render() method는 side-effect를 발생시키기엔 너무 빠르기때문에 lifecycle method를 사용해야한다.

다음을 예로 들어보자.
현재 counter value로 document title을 업데이트해보자.
componentDidMount(){  <= 최초 render()에서 document.title을 0으로 세팅할것이다. 단 한번만 호출될 것이다.
  document.title = `You clicked ${this.state.count} times`;
}

componentDidUpdate(){  <= button을 눌러 count를 업데이트 하면 document.title을 다시 업데이트 해야한다.
  document.title = `You clicked ${this.state.count} times`;
}

두 lifecycle method에서 완전히 같은 코드를 쓰고 있다.

다른 side effect 예를 보자
timer
componentDidMount(){  <= timer 생성
  this.interval = setInterval(this.tick, 1000)
}

componentWillUnmount(){  <= timer clear
  clearInterval(this.interval)
}

2가지 side effect를 합쳐보자.
componentDidMount(){
  document.title = `You clicked ${this.state.count} times`;
  this.interval = setInterval(this.tick, 1000)
}

componentDidUpdate(){
  document.title = `You clicked ${this.state.count} times`;
}

componentWillUnmount(){
  clearInterval(this.interval)
}

원하는대로 작동할것이다.
하지만 더 나아질수 없는지 궁금해진다.

첫번째로 살펴볼것은 document.title을 update하기 위해 같은 코드를 2번쓰고 있다.
두번째로 살펴볼것은 code가 어떻게 같이 또 따로 있는지이다.
timer에 관련된 다시말해 서로 관련있는 setInterval(), clearInterval()은 다른 code block에 있다. (다른 lifecycle method안에 있다)

componentDidMount(){
  document.title = `You clicked ${this.state.count} times`;
  this.interval = setInterval(this.tick, 1000)
}

위의 코드에서는 서로 전혀 관련이 없는 code가 같이 있다.
똑같은 코드를 반복하지 않으며 동시에 관련된 코드가 같이 그룹을 이루면 좋지 않을까?
이 부분에서 effect hook이 등장하게된다.

useEffect
지금까지 살펴봐왔던 문제를 수정하면서 side effect들을 functional component에서 수행할수 있게 한다.
componentDidMount(), componentDidUpdate(), componentWillUnmount()에 가까운 대체제이다.
3가지 lifecycle method들은 effect hook에의해 처리될수있다.

React Hooks Tutorial - 7 - useEffect after render
이전 강에서 side effect를 functional component안에서 발생시킬때 쓸수있다고 배웠다.
또한 class component의 componentDidMount(), componentDidUpdate(), componentWillUnmount() lifecycle method에서 하던 일을 처리할수 있다고 배웠다.

functional component에서 위의 lifecycle method의 기능을 어떻게 흉내내는지 예를 통해 알아보자.
일단 class component로 만들어본다.

ClassCounterOne.js
import React, { Component } from 'react'

export class ClassCounterOne extends Component {
  constructor(props) {
    super(props)
  
    this.state = {
       count: 0
    }
  }
  
  componentDidMount(){
    document.title = `You clicked ${this.state.count} times`; <= HTML이 아닌 것은 lifecycle method에서 처리했다는것을 주목!
  }

  componentDidUpdate(){
    document.title = `You clicked ${this.state.count} times`; <= HTML이 아닌 것은 lifecycle method에서 처리했다는것을 주목!
  }

  render() {
    return (
      <div>
        <button onClick={() => this.setState({ coiunt: this.state.count + 1})}>
          Click {this.state.count} times
        </button>
      </div>
    )
  }
}

export default App

위의 class를 functional component로 바꾸어보자. 좀더 정확하게 이야기하면 componentDidMount(), componentDidUpdate()를 effect hook으로 바꾸어보자.

일단 side effect를 고려하지 말고 counter를 만들어보자.
HookCounterOne.js 
import React, { useState } from 'react'

function HookCounterOne() {
  const [count, setCount] = useState(0);

  return (
    <div>
      <button onClick={()=>setCount(count+1)}>Click {count} times</button>
    </div>
  )
}

export default HookCounterOne

effect hook을 사용하여 document.title을 count로 업데이트해보자.
HookCounterOne.js 
import React, { useState, useEffect } from 'react'  <= useEffect import

function HookCounterOne() {
  const [count, setCount] = useState(0);

  //useEffect는 함수이며 인자로 함수를 받는다.
  //인자로 들어간 함수는 component의 모든 render뒤 실행된다.
  useEffect(() =>{
    document.title = `You clicked ${count} times`
  })

  return (
    <div>
      <button onClick={()=>setCount(count+1)}>Click {count} times</button>
    </div>
  )
}

export default HookCounterOne
useEffect()를 사용의 의미는 react에 인자의 함수를 component가 모든 render뒤 실행해달라고 요청하는 것이다.
중요한 것은 모든 render이다. 조금 이상하게 들릴지 모르지만 이는 class component가 하려고 하는 것이다.
componentDidMount() : initial render 뒤
componentDidUpdate() : initial 을 제외한 모든 render
effect hook은 initial 및 모든 render에 대해 호출된다.
물론 이는 커스터마이징 할수 있으며 나중에 살펴본다.

하나 더 주목할것은 useEffect()는 component안에 위치한다는 것이다. 이로인해 추가 코드 없이 component의 state와 props에 접근 할 수 있다.

React Hooks Tutorial - 8 - Conditionally run effects
이전 강에서 중요한 점 하나를 배웠다. useEffect hook은 모든 render뒤에 호출된다는 것이다.
어떤 경우에는 render뒤 effect를 무조건 적용하는 것은 퍼포먼스 문제를 야기할수있다.
그래서 functional component에서 effect를 조건에따라 실행할수있는 방법이 필요하다.

먼저 class component를 살펴보자. 이전에 했던 counter에 유저이름을 받을수있는 input을 추가해보자.
ClassCounterOne.js
import React, { Component } from 'react'

export class ClassCounterOne extends Component {
  constructor(props) {
    super(props)
  
    this.state = {
       count: 0,
       name: ''   <= 1. state 추가
    }
  }
  
  componentDidMount(){
    document.title = `You clicked ${this.state.count} times`;
  }

  componentDidUpdate(){
    console.log('Updating document title')
    document.title = `You clicked ${this.state.count} times`;
  }

  render() {
    return (
      <div>
        <input type="text" value={this.state.name} onChange= {e =>  <= 2. name state update
          this.setState({name: e.target.value})
        }/>
        <button onClick={() => this.setState({ coiunt: this.state.count + 1})}>
          Click {this.state.count} times
        </button>
      </div>
    )
  }
}

export default App

실행시켜보면 button 클릭시 document.title이 변경된다.
그런데 input에 타이핑을 할때마다 console.log('Updating document title)이 찍히게된다. 그러나 count값은 변하지 않았다.
document.title을 같은 string으로 계속 세팅하고 있는 것이다.
count가 변경되었을때만 document.title을 업데이트 하도록 수정하자.

componentDidUpdate(prevProps, prevState){  <= prevProps, prevState을 추가한다!
  if(prevState.count !== this.state.count){
    console.log('Updating document title)
    document.title = `You clicked ${this.state.count} times`;
  }
}

이로서 count가 변경될때만 document.title을 변경하게 된다.
이를 useEffect로 구현해보자.

HookCounterOne.js 
import React, { useState, useEffect } from 'react'  <= useEffect import

function HookCounterOne() {
  const [count, setCount] = useState(0);
  const [name, setName] = useState('');  <= 1. name state 추가

  //useEffect는 함수이며 인자로 함수를 받는다.
  //인자로 들어간 함수는 component의 모든 render뒤 실행된다.
  useEffect(() =>{
    console.log('Updating document title') <= 3. log 추가
    document.title = `You clicked ${count} times`
  })

  return (
    <div>
      <input type="text" value={name} onChange={e => setName(e.target.value)} />  <= 2. input 추가
      <button onClick={()=>setCount(count+1)}>Click {count} times</button>
    </div>
  )
}

input에 값이 변할때마다 'Updating document title'이 로그로 찍히고 있다. 이는 비효율적이다.
질문은 react에게 useeffect를 count value가 바뀔다만 실행하도록 어떻게 이야기 하는가?이다.
class component에서는 prevState와 현재 state를 비교했다. 이러한 패턴이 너무나 일반적이기때문에 react팀은 useEffect에 이 기능을 넣기로 결정했다.
Conditionally effect를 실행시키기위해 두번째 파라메터를 패스한다. 이 파라메터는 array이다.
이 array에는 감시할 props 또는 state를 명시할수있다. 이 array안에 명시된 props, state가 변경될때만 effect는 실행된다.

 useEffect(() =>{
    console.log('Updating document title')
    document.title = `You clicked ${count} times`
  }, [count])  <= count가 변경될때만 실행된다.

클릭시에는 effect가 실행되지만 input change에서는 effect가 실행되지 않는다.

조건부로 effect를 실행하려면 2번째 파라메터를 명시하라. 2번째 파라메터는 effect가 의존하는 값들의 array이다.
render간에 값들이 변경되지 않으면 effect는 단순히 실행되지 않는다. 기억해야할 최적화 기법이다.


React Hooks Tutorial - 9 - Run effects only once
effect를 사용하여 componentDidMount()를 흉내내는 법을 알아보자
우선 class component를 구현을 살펴보자.
ClassMouse.js
import React, { Component } from 'react'

export ClassMouse App extends Component {
  constructor(props) {
    super(props)
  
    this.state = {
      x: 0,
      y: 0
    }
  }

  logMousePosition = e => {
    this.setState({ x: e.clientX, y: e.clientY })
  }

  componentDidMount() {
    window.addEventListener('mousemove', this.logMousePosition)
  }
  

  render() {
    return (
      <div>
        X - {this.state.x} Y - {this.state.y}
      </div>
    )
  }
}

export default ClassMouse

실행시키고 마우스를 움직이면 화면에 좌표가 나온다. 중요한건 addEventListener를 단 한번만 호출하는 것이다.
useEffect()를 사용해보자
HookMouse.js
import React { useState, useEffect }from 'react'

function HookMouse() {
  const [x, setX] = useState(0);  <= 1.2개의 state를 따로 썼다.
  const [y, setY] = useState(0);

  const logMousePosition = e => {
    console.log('Mouse event')
    setX(e.clientX)
    setY(e.clientY)
  }

  useEffect(() => {
    console.log('useEffect called')
    window.addEventListener('mousemove', logMousePosition);
  })

  return (
    <div>
      Hooks X - {x} Y - {y}
    </div>
  )
}

export default HookMouse

실행시켜보면 최초 useEffect called가 로그에 찍힌다.
마우스를 움직일때마다도 useEffect called가 로그에 찍힌다. 이미 배운대로 동작하고 있다.
effect는 dependency array를 명시하지 않으면 render뒤 무조건 실행된다.
이 예제에서는 실제 effect가 어떠한 것에도 종속되지 않기를 바란다. 단지 initial render에서 한번만 실행되게 하고 싶다.
이는 useEffect의 두번째 파라메터로 empty array를 명시하는 것이다.

 useEffect(() => {
    console.log('useEffect called')
    window.addEventListener('mousemove', logMousePosition);
  }, [])
이는 기본적으로 react에게 "이 effect는 어떠한 props, state에도 의존하지 않는다. React가 rerender후 이 effect를 호출할 이유가 없다 "라고 이야기 하는 것이다.
React는 이 effect를 initial render에서만 호출하고 잊게 만들길 원하는 것으로 판단한다. 이는 componentDidMount()를 흉내낸 것이다.
위의 코드를 적용하면 최초 한번만 useEffect called가 출력되며 더이상 계속 출력되지 않는다.

기억해야할 점은 useEffect()의 두번째 파라메터로 []를 주면 componentDidMount()를 흉내낼수 있다는 것이다.


React Hooks Tutorial - 10 - useEffect with cleanup
componentWillUnmount()도 useEffect로 흉내 내는 것이 가능하다는 것을 알아보자.
componentWillUnmount()가 왜 필요한지 예를 통해 알아보자. 이를 위해 HookMouse의 container compoennt를 만든다.
여기에 component의 visibility를 toggle하는 button을 추가할것이다.
MouseContainer.js
import React, { useState, useEffect } from 'react'

function MouseContainer() {
  const [display, setDisplay] = useState(true);
  return (
    <div>
      <button onClick={() => setDisplay(!display)}>Toggle display</button>
      <display && <HookMouse />}  <= display가 true가 되면 HookMouse 출력!
    </div>
  )
}

export default MouseContainer

실행시켜 toggle버튼을 누르면 HookMouse component가 DOM으로부터 unmount된다.
이때 mouse를 움직이면 에러가 발생
Warning: Can't perform a React state update on a unmounted component. This is a no-op, but it indicates a memory leak in your application.
Tofix, cancel all subscriptions and asynchronous tasks in a useEffect cleanup function. in HookMouse
Mouse event <= 위 에러가 나고도 Mouse event가 찍히고 있다.
component가 제거된 뒤에도 component에 속한 EventListener가 동작하고 있다.
위의 Warning로그에서 말하는 것처럼 component를 cleanup해야한다.

cleanup code를 어떻게 처리할것인가?
class component에서는 직접적으로 알수있다.
ClassMouse.js
import React, { Component } from 'react'

export ClassMouse App extends Component {
  constructor(props) {
    super(props)
  
    this.state = {
      x: 0,
      y: 0
    }
  }

  logMousePosition = e => {
    this.setState({ x: e.clientX, y: e.clientY })
  }

  componentDidMount() {
    window.addEventListener('mousemove', this.logMousePosition)
  }
  
  componentWillUnmount(){  <= 추가
    window.removeEventListener('mousemove', this.logMousePosition)
  }

  render() {
    return (
      <div>
        X - {this.state.x} Y - {this.state.y}
      </div>
    )
  }
}

export default ClassMouse

componentWillUnmount()를 어떻게 흉내 낼것인가?
useEffect() 함수에 전달된 함수가 return한 함수는 component가 unmount될때 호출된다.
리턴한 함수가 기본적으로 cleanup function이된다.

HookMouse.js
import React { useState, useEffect }from 'react'

function HookMouse() {
  const [x, setX] = useState(0);
  const [y, setY] = useState(0);

  const logMousePosition = e => {
    console.log('Mouse event')
    setX(e.clientX)
    setY(e.clientY)
  }

  useEffect(() => {
    console.log('useEffect called')
    window.addEventListener('mousemove', logMousePosition);
    return ()=>{
      console.log('Component unmounting code')
      window.removeEventListener('mousemove', logMousePosition)
    }
  }, [])

  return (
    <div>
      Hooks X - {x} Y - {y}
    </div>
  )
}

export default HookMouse

toggle을 누르면 Component unmounting code가 로그 출력이 되는 것을 볼수있다. 이는 EventListener가 제거된것을 의미한다.

useEffect()함수에 패스된 함수가 함수를 리턴하면 그 함수는 cleanup function이 된다.


React Hooks Tutorial - 11 - useEffect with incorrect dependency
매초마다 자동 증가되면 Counter를 만들자
IntervalClassCounter.js
import React, { Component } from 'react'

export IntervalClassCounter App extends Component {
  constructor(props) {
    super(props)
  
    this.state = {
      count: 0
    }
  }
  
  componentDidMount() {
    this.interval = setInterval(this.tick, 1000);
  }

  componentWillUnmount() {
    clearInterval(this.interval);
  }

  tick = () => {
    this.setState({
      count: this.state.count + 1
    });
  }

  render() {
    return <h1>{this.state.count}</h1>
  }
}

export default IntervalClassCounter

Hooks를 사용해서 다시 작성해보자
IntervalHookCounter.js
import React, { useState, useEffect } from 'react'

function IntervalHookCounter() {
  const [count, setCount] = useState(0)
  const tick = () => {
    console.log('count in tick = ', count)  <= !!!!돌려보면 항상 0이 출력된다. 즉 최초 useState()로 가져온 count가 closure로 tick함수와 묶여버린다. setCount(count + 1)로 하므로 한번 돌면 항상 1이 찍힌다.
    setCount(count + 1)
  }

  useEffect(()=>{
    const interval = setInterval(tick, 1000);  <= !!!!closure가 형성된 tick함수를 주어버렸고 계속 setCount(count(0으로 묶여있다) + 1) 만 호출된다.
    return () => {
      clearInterval(interval);  <= 2. componentWillUnmount()를 흉내낸다.
    }
  }, []);  <= 1. componentDidMount()를 흉내낸다.

  return (
    <div>
      {count}
    </div>
  )
}

export default IntervalHookCounter

HookCounter는 예상대로 동작하지 않는다. 1로 계속 남아있다.
문제에 대해 알아보자. 마음속으로는 문제가 되는 문장이 단순하다. interval을 한번 생성하고 한번 파괴하는 것이다.
그래서 class component에서는 componentDidMount()에서 생성하고 componentWillUnmount()에서 파괴했다.
HookCounter에서 이를 그대로 번역해서 옮겼다.
empty dependency list를 넘겨서 단 한번만 timer를 세팅했고 timer를 파괴하기위해 cleanup function을 리턴했다.
왜 예상대로 동작하지 않을까?
여기서 문제는 mental model(인간심리)에 있으며 다음과 같은 글을 인용할것이다.

"만약 dependency array를 effect의 재실행을 명시하는 방법으로 생각한다면 문제에 봉착할것이다.
대신 dependency array는 react가 effect가 변화를 감시해야하는 모든 것을 알 수 있게하는 수단으로 생각되어져야한다."

우리의 사고방식은 단순히 componentDidMount()를 복제한것이다.
하지만 []를 명시함으로서 기본적으로 우리는 react에게 count변수의 변화를 무시하라고 말한 것이다. <= count 변수의 변화를 무시하는 것은 맞는데 useEffect()가 호출이 안되게 무시하는 것.

[count]를 넣으면 count가 변경될때마다 useEffect()안의 함수가 호출된다. 틀린방법인듯...아래 내가 돌려본 경험 참고...

const tick = () => {    
    setCount(prevCount => prevCount + 1)  <= 이 방법이 가장 좋은 방법이다!
  }

흠..설명이 너무 이상해서 돌려봤다....
react는 initial render에서 count 값을 0으로 출력 1초뒤 tick이 호출되며 1이된다.
다시 tick이 호출되지만 count변수가 closure를 형성하여 계속 0이 들어오게된다. 고로 1이 계속 호출된다. tick안의 count는 useState()로 업데이트 된 것을 가져온것이 아니다.
함수가 선언될때 closure가 형성되어 count = 0인 환경이 tick함수와 함께 묶여버렸다...
나중에 나오는 [count]를 더하는 것도 틀렸다. count가 변하면 useEffect()의 함수가 호출되어 업데이트 되는것처럼 보이지만 setInterval이 여러번 호출되어 버린다.
정답은 prevCount를 인자로 받는 함수를 쓰는 것이 정답이다.


한가지 팁을 더해보면 만약 useEffect안에서 어떤 함수를 호출할때 dependency를 깜빡하기 쉽다.
function doSomething() {
  console.log(someProp);
}

useEffect(()=>{
  doSomething();
}, []);

위와 같이 했을때 someProp을 dependency array에 넣는 것을 깜빡하면 doSomething()은 한번만 호출된다.

useEffect(()=>{
  doSomething();
}, [someProp]);

이런경우 알기가 쉽지 않으므로 다음과 같이 쓰는 것을 추천한다.

useEffect(()=>{
  function doSomething() {
    console.log(someProp);  <= 소스를 보고 쉽게 someProp에 종속성이 있은 것을 쉽게 알 수 있다.
  }
  doSomething();
}, [someProp]);

dependency array에 종속성을 넣는 것이 극히 주의하자.


추가적으로 multiple effect를 살펴보자.
hooks의 등장 동기를 기억한다면 lifecycle에 걸쳐 관련 코드가 흩어지며, 관련 없는 코드가 같이 있게 되는 것을 알것이다.
Hooks는 이를 해결한다..
다음과 같은 방법으로 useEffect를 여러개 쓸수있다.

function FriendStatusWithCount(props) {
  const [count, setCount] = useState(0);
  useEffect( () => {
    document.title = `You clicked ${count} times`;
  });

  const [isOnline, setIsOnline] = useState(null);
  useEffect( () =>{
    function handleStatusChange(status) {
      setIsOnline(status.isOnline);
    }

    ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);
    return () => {
      ChatAPI.unSubscribeToFriendStatus(props.friend.id, handleStatusChange);
    }
  })
}

state와 effect가 관련된 코드로 grouping되어 있는 것을 볼수있다.


React Hooks Tutorial - 12 - Fetching data with useEffect Part 1
지금까지 배운것을 활용해서 fetching data를 구현해보자. suspense라 불리는 것이 data fetching을 담당하겠지만 지금은 배운것을 통해 구현해본다.
import React, { useState, useEffect } from 'react'
import axios from 'axios'


function DataFetching() {
  const [posts, setPosts] = useState([])

  useEffect(() => {
    axios.get('https://jsonplaceholder.typicode.com/posts')
    .then(res => {
      console.log(res)
      setPosts(res.data);
    })
    .catch(error =>{
      console.log(error)
    })
  }, []);

  return (
    <div>
      <ul>
        {
          posts.map(post => <li key={post.id}>{post.title}</li>)  <= jsx 처리!
        }
      </ul>
    </div>
  )
}

export default DataFetching


React Hooks Tutorial - 12 - Fetching data with useEffect Part 1
id를 통해 특정 post만 가지고 오기, input에 타이핑할때마다 data를 가져온다!
import React, { useState, useEffect } from 'react'
import axios from 'axios'


function DataFetching() {
  const [post, setPost] = useState({})
  const [id, setId] = useState(1);

  useEffect(() => {
    axios.get(`https://jsonplaceholder.typicode.com/posts/${id}`)
    .then(res => {
      console.log(res)
      setPost(res.data);
    })
    .catch(error =>{
      console.log(error)
    })
  }, [id]);  <= id에 종속성!

  return (
    <div>
      <input type="text" value={} onChange={e => setId(e.target.value)} />
      <div>{post.title}</div>
    </div>
  )
}

export default DataFetching

React Hooks Tutorial - 14 - Fetching data with useEffect Part 3
button click으로 데이타를 가져오게 하자
import React, { useState, useEffect } from 'react'
import axios from 'axios'


function DataFetching() {
  const [post, setPost] = useState({})
  const [id, setId] = useState(1);
  const [idFromGButtonClick, setIdFromButtonClick] = useState(1)

  const handleClick = () => {
    setIdFromButtonClick(id)
  }

  useEffect(() => {
    axios.get(`https://jsonplaceholder.typicode.com/posts/${idFromGButtonClick}`)
    .then(res => {
      console.log(res)
      setPost(res.data);
    })
    .catch(error =>{
      console.log(error)
    })
  }, [idFromGButtonClick]);

  return (
    <div>
      <input type="text" value={} onChange={e => setId(e.target.value)} />
      <button type="button" onClick={handleClick}>Fetch Post</button>
      <div>{post.title}</div>
    </div>
  )
}

export default DataFetching


React Hooks Tutorial - 15 - useContext Hook Part 1
Context API에 관한 설명, 이전에 했던 설명과 같다. ReactJS Tutorial - 38 


React Hooks Tutorial - 16 - useContext Hook Part 2
Hooks가 도입되기전 어떻게 context API를 사용했는지 보자. 이전의 예외 바슷하다.
import React from 'react'
import ComponentC from './components/ComponentC'

export const UserContext = React.createContext()
export const ChannelContext = React.createContext()

function App() {
  return (
    <div className='App'>
      <UserContext.Provider value={'Vishwas'}>
        <ChannelContext.Provider value={'Codevolution'}>
          <ComponentC />
        </ChannelContext.Provider>      
      </UserContext.Provider>      
    </div>
  )
}

export default App



import React from 'react'
import {UserContext, ChannelContext} from '../App'

function App() {
  return (
    <div>
      <UserContext.Consumer>
        {
          user => {
            <ChannelContext.Consumer>
              {
                ChannelContext =>{
                  return (<div>User context value {user}, channel context value {channel}</div>)    <= render props 패턴을 써야한다.
                }
              }
            </ChannelContext.Consumer>
          }
        }
      </UserContext.Consumer>      
    </div>
  )
}

export default App

2개의 Consumer를 쓸때 장황하고 복잡하다. 이를 해결하기위해 useContext hook이 등장한다.

React Hooks Tutorial - 17 - useContext Hook Part 3
지금까지 context를 쓰기위해 다음과 같은 작업을했다.
1.React.createContext()를 사용하여 context 생성
2.Provider를 사용하여 tree의 높은 곳에서 component를 감싼다.
3.Consumer를 사용하여 value를 사용한다.

useContext hook은 3번의 사용하는 곳을 간단하게 만든다.

import React, {useContext} from 'react'
import ComponentF from './components/ComponentF'
import { UserContext, ChannelContext } from '../App'

function ComponentE() {
  const user = useContext(UserContext)
  const channel = useContext(ChannelContext)

  return (
    <div>
      {user} - {channel}
    </div>
  )
}

export default ComponentE

너무나 간단해 졌다. 아마도 가장 간단한 hook일것이다. 기회가 된다면 무조건 써볼것!

React Hooks Tutorial - 18 - useReducer Hook
useReducer가 무엇이고 왜 써야 하는지 살펴본다.
javascript의 reducer의 개념에 대해서도 살펴본다.

useReducer
useReducer는 state management를 위해 쓰는 hook이다.
useState의 대안이다.
차이점이 무엇인가?
useState는 useReducer를 사용하여 구현되었다.
useState와 useReducer중 언제 무엇을 사용해야 하나?

현재 위의 질문에 대답할순 없다. 지금 기억해야 할것은 "useReducer는 state management를 위해 쓰는 hook이다" 라는 것이다.

지금까지의 Hook들은 이름에 의미가 있었다.
useState = state
useEffect = side effects
useContext = context API
useReducer = reducers

그런데 reducer가 무엇인가? (useReducer hook을 이해하기위해 redux를 알아야 할 필요는 없다. 만약 redux를 안다면 앞으로의 syntax와 예제를 쉽게 이해할수 있을 것이다.)

vanilla javascript로 돌아가보자.
array의 내장함수들을 가지고 놀아봤을 것이다. foreach, map, reduce!
바로 reduce로 들어가자...
Array.prototype.reduce()
The reduce() method executes a reducer function (that you provide) on each element of the array, result in a single output value.

const array1 = [1, 2, 3, 4]
const reducer = (accumulator, currentValue) => accumulator + currentValue;  <= 이게 reducer

//1 + 2 + 3 + 4
console.log(array1.reduce(reducer));  => 10
//5 + 1 + 2 + 3 + 4
console.log(array1.reduce(reducer, 5)) => 15  두번째 param인 5는 초기값!

왜 이걸 봐야 하나?
방금 본것과 useReducer hook은 엄청나게 비슷하다.

reduce in javascript                                useReducer in React
array.reduce(reducer, initialValue)                 useReducer(reducer, initialState)
singleValue = reducer(accumulator, itemValue)       newState = reducer(currentState, action)     <= reducer 함수 정의, action에 대해선 나중에 설명
reduce method returns single value                  useReducer returns a pair of values.[newState, dispatch]

예제를 통해 하나씩 이해해 나가자.
지금은 syntax와 what, why를 기억하자

정리
useReducer는 React에서 state management를 위해 쓰여지는 hook이다.
useReducer는 reducer function과 관련되어 있다.
useReducer(reducer, initialState)  <= 이런 syntax를 갖는다.
reducer(currentState, action)  <= 이런 syntax를 갖는다. 파라메터에 의존해 reducer는 newState를 리턴한다.

useReducer는 기본적으로 react component의 state를 바꾼다.

React Hooks Tutorial - 19 - useReducer (simple state & action)
첫번째 예제를 보자.
간단히 보여주기위해 또 counter를 만든다. 비교를 위해 강의 초반에 사용한 useState hook을 사용한 counter도 다시 한번 보고 오자.
CounterOne.js

import React, { useReducer } from 'react'  <= count state를 저장하기 위해 useReducer import

const initialState = 0                  <= initialState와 reducer function을 선언한다.
const reducer = (state, action) => {  <= state의 transition이 일어날때 reducer에 주는 instruction이 action, action에 따라 필요한 state transition을 reducer function이한다.
  switch(action) {  <= reducer는 newState를 리턴하는 함수! action에 따라 newState를 return;
    case 'increment':
      return state + 1
    case 'decrement':
      return state - 1
    case 'reset':
      return initialState
    default:
      return state
  }
}

function CounterOne() {
  // state를 알수 있어야 하고 적당한 action을 통해 reducer function을 호출할수 있어야 한다!
  const [count, dispatch] = useReducer(reducer, initialState) <= [currentState, dispatch function]의 pair, dispatch를 통해 action을 넘겨 reducer를 호출할수있다.
  return (
    <div>
      <div>Count - {count}</div>
      <button onClick={() => dispatch('increment')}>Increment</button>  <= dispatch의 인자는 action이다!
      <button onClick={() => dispatch('decrement')}>>Decrement</button>
      <button onClick={() => dispatch('reset')}>>Reset</button>
    </div>
  )
}

export default CounterOne

1. useReducer를 import
2. useReducer()를 호출
3. initialState와 reducer함수를 정의
4. useReducer()를 호출하는 곳으로 가서 count, dispatch함수를 리턴받는다.
5. 버튼에따라 dispatch함수에 action을 넣어 state 변경
6. state가 변경되므로서 component가 rerender
7. 화면에 count가 올바로 찍힌다.

redux를 알고 있다면 reducer가 좀 이상해 보일지도 모른다.
state가 object가 아니라 숫자형이다. action도 type property를 가진 object가 아니라 직관적인 string이다.
강의 제목이 말하듯 이 예제는 simple state & action이다.
반드시 redux pattern을 따라야 할 필요는 없다. 또한 useReducer를 쓰는 이 패턴을 굳이 고집할 필요도 없다. 다음 강에서 object를 써보자.


React Hooks Tutorial - 20 - useReducer (complex state & action)
simple state와 action을 쓰는대신 object state와 object action을 써보자. 이는 redux유저들에게 친숙한 패턴이다.

CounterTwo.js
import React, { useReducer } from 'react'

const initialState = {   <= state를 object로 변경
  firstCounter: 0
}

const reducer = (state, action) => {
  switch(action.type) {  <= action이 type property를 가지고 오도록 수정했다.
    case 'increment':
      return {firstCounter: state.firstCounter + 1}  <= state object를 리턴하도록 수정
    case 'decrement':
      return {firstCounter: state.firstCounter - 1}
    case 'reset':
      return initialState
    default:
      return state
  }
}

function CounterTwo() {  
  const [count, dispatch] = useReducer(reducer, initialState)
  return (
    <div>
      <div>Count - {count.firstCounter}</div>
      <button onClick={() => dispatch({type: 'increment'})}>Increment</button>  <= object를 dispatch
      <button onClick={() => dispatch({type: 'decrement'})}>>Decrement</button>
      <button onClick={() => dispatch({type: 'reset'})}>>Reset</button>
    </div>
  )
}

export default CounterTwo

state와 action을 object로 하여 useReducer()사용하였다.
떠오르는 질문은 이 특별한 패턴이 무슨 장점이 있는가?일것이다.
도움 될만한 2가지 시나리오가 있다.
첫번째는 우리가 증가, 감소 시키고 있는 값에 관한 것이다. 헌재는 1씩이지마 파라메터로 넘길수 있게 하면 어떨까?
5씩 증가, 감소 시키는 버튼 2개를 추가해야 한다면..이제 action이 object이기때문에 쉽다.

CounterTwo.js
import React, { useReducer } from 'react'

const initialState = {
  firstCounter: 0
}

const reducer = (state, action) => {
  switch(action.type) {
    case 'increment':
      return {firstCounter: state.firstCounter + action.value} <= value 사용!
    case 'decrement':
      return {firstCounter: state.firstCounter - action.value}
    case 'reset':
      return initialState
    default:
      return state
  }
}

function CounterTwo() {  
  const [count, dispatch] = useReducer(reducer, initialState)
  return (
    <div>
      <div>Count - {count.firstCounter}</div>
      <button onClick={() => dispatch({type: 'increment', value: 1})}>Increment</button>
      <button onClick={() => dispatch({type: 'decrement', value: 1})}>>Decrement</button>
      <button onClick={() => dispatch({type: 'reset'})}>>Reset</button>
      <button onClick={() => dispatch({type: 'increment', value: 5})}>Increment 5</button>  <= value 추가!
      <button onClick={() => dispatch({type: 'decrement', value: 5})}>>Decrement 5</button>
    </div>
  )
}

export default CounterTwo

action을 object로 사용하여 추가 data를 reducer로 전달할수 있게 되었다.

두번째 시나리오는 state가 object이어서 도움이 되는 경우이다.
Component에 2개의 다른 counter를 써야 한다고 가정하자. 만약 state가 object라면 정말 쉽다.
CounterTwo.js
import React, { useReducer } from 'react'

const initialState = {
  firstCounter: 0,
  secondCounter: 10
}

const reducer = (state, action) => {
  switch(action.type) {
    case 'increment':
      return {...state, firstCounter: state.firstCounter + action.value}
    case 'decrement':
      return {...state, firstCounter: state.firstCounter - action.value}
    case 'increment2':                                       <= increment2 추가, spread operator 잊지 말것!
      return {...state, secondCount: state.secondCounter + action.value}
    case 'decrement2':
      return {...state, secondCount: state.secondCounter - action.value}
    case 'reset':
      return initialState
    default:
      return state
  }
}

function CounterTwo() {  
  const [count, dispatch] = useReducer(reducer, initialState)
  return (
    <div>
      <div>First Counter - {count.firstCounter}</div>
      <div>Second Counter - {count.secondCounter}</div>
      <button onClick={() => dispatch({type: 'increment', value: 1})}>Increment</button>
      <button onClick={() => dispatch({type: 'decrement', value: 1})}>>Decrement</button>
      <button onClick={() => dispatch({type: 'reset'})}>>Reset</button>
      <button onClick={() => dispatch({type: 'increment', value: 5})}>Increment 5</button>
      <button onClick={() => dispatch({type: 'decrement', value: 5})}>>Decrement 5</button>
      <button onClick={() => dispatch({type: 'increment2', value: 1})}>Increment Counter 2</button>  <= increment2 추가!
      <button onClick={() => dispatch({type: 'decrement2', value: 1})}>>Decrement Counter 2</button>
    </div>
  )
}

export default CounterTwo

state를 object로 사용함으로서 2개의 다른 counter를 유지 할수 있게 된다.

이번강에서 보여주고 싶은것은 state와 action 모두 object로 유지될수있다는것이다.
action을 object로 씀으로서 추가 data를 reducer로 보낼수 있게 되었다.
state를 object로 씀으로 여러개의 state 변수를 추적할수있게 되었다. 이런식의 하나의 object state에 여러가지 변수를 넣어 관리하는 것은 global state를 다룰때 적당하다.
하지만 지금은 local state를 다루고 있다. local state를 다룰때는 여러 변수를 추적하는 다른 방법이 있다.

React Hooks Tutorial - 21 - Multiple useReducers
2개의 다른 counter를 추적하기위해 1개의 state object를 썼었다. secondCounter를 update하기위해 reducer에 추가적인 case문을 작성했었다.
이것도 나쁘진 않지만 완전히 같은 transition을 쓰는 2개의 counter가 필요하다면 훨씬 간단한 대안이 있다.
여러개의 useReducer hook을 쓰는 것이다.

CounterThree.js

import React, { useReducer } from 'react'

const initialState = 0
const reducer = (state, action) => {  <= 2번째 counter도 같은 transition을 쓴다면?
  switch(action) {
    case 'increment':
      return state + 1
    case 'decrement':
      return state - 1
    case 'reset':
      return initialState
    default:
      return state
  }
}

function CounterThree() {  
  const [count, dispatch] = useReducer(reducer, initialState)
  const [countTwo, dispatchTwo] = useReducer(reducer, initialState) <= 똑같은 state와 reducer를 사용!
  return (
    <div>
      <div>Count - {count}</div>
      <button onClick={() => dispatch('increment')}>Increment</button>
      <button onClick={() => dispatch('decrement')}>>Decrement</button>
      <button onClick={() => dispatch('reset')}>>Reset</button>

      <div>countTwo - {countTwo}</div>
      <button onClick={() => dispatchTwo('increment')}>Increment</button>
      <button onClick={() => dispatchTwo('decrement')}>>Decrement</button>
      <button onClick={() => dispatchTwo('reset')}>>Reset</button>
    </div>
  )
}

export default CounterThree

같은 코드를 쓰더라도 독립적인 counter 2개가 생겼다!
같은 transition을 쓰는 state variable을 여러개 써야 할경우 같은 reducer를 쓰는 여러개의 useReducer()를 쓰는것이 좋은 아이디어 이다.
이는 state를 merge해야하는 복잡도를 피할수 있으며 reducer가 중복되는 것을 막아준다.

React Hooks Tutorial - 22 - useReducer with useContext
지금까지 useReducer를 component레벨인 Local state management에 사용해왔다.
하지만 components간에 state를 공유해야한다면 이를 Global state manangement라한다.
Global state를 처리하려면? 
useReducer + useContext
지금까지는 component가 counter value를 가지고 있었다. 각각의 component들이 useReducer를 사용했다.

상황을 조금 바꾸어 app이 counter를 갖게되고 다른 counter들이 출력을 해야 한다면?(counter값을 공유해야한다!)
app GlobalCounter를 props로 counter를 넘겨도 된다. 하지만 실제는 그리 간단하지 않다. nested단계가 아주 높을때 힘들어진다.
Context API 상황을 다시 살펴본다.

App.js에 Count = 0 state를 만들고 Count와 이를 update하는 method를 tree를 통해 공유한다.

App.js
import React, { useReducer } from 'react'  
...

const initialState = 0 <= 전역  state
const reducer = (state, action) => { 
  switch(action) {
    case 'increment':
      return state + 1
    case 'decrement':
      return state - 1
    case 'reset':
      return initialState
    default:
      return state
  }
}

function App() {
  const [count, dispatch] = useReducer(reducer, initialState)
  return (
    <div className='App'>
      Count - {count}
      <ComponentA />
      <ComponentB />
      <ComponentC />
    </div>
  )
}

export default App

dipatch action을 App.js가 아니라 nested component에서 하고 싶다!
context가 count와 dispatch method를 provide하게 하고 component에서 consume한다.

import React, { useReducer } from 'react'  
...

export const CountContext = React.createContext() <= context 생성!

const initialState = 0
const reducer = (state, action) => { 
  switch(action) {
    case 'increment':
      return state + 1
    case 'decrement':
      return state - 1
    case 'reset':
      return initialState
    default:
      return state
  }
}

function App() {
  const [count, dispatch] = useReducer(reducer, initialState)
  return (
    <CountContext.Provider value={{countState: count, countDispatch: dispatch}}>  <= context에 object로 넘긴다.
      <div className='App'>
        Count - {count}
        <ComponentA />
        <ComponentB />
        <ComponentC />
      </div>
    <CountContext.Provider>
  )
}

export default App


ComponentA.js
import React, {useContext} from 'react'
import { CountContext } from '../App'  <= CountContext 가져온다.

function ComponentA() {
  const countContext = useContext(CountContext)  <= useContext()사용
  return (
    <div>
      Component A {countContext.countState}
      <button onClick={() => countContext.countDispatch('increment')}>Increment</button>  <= contContext에서 주어진 dispatch호출!
      <button onClick={() => countContext.countDispatch('decrement')}>>Decrement</button>
      <button onClick={() => countContext.countDispatch('reset')}>>Reset</button>
    </div>
  )
}

export default ComponentA

1. app.js에서 reducer hook을 사용해 counter 생성.
2. count, dispatch를 Context.provider를 사용하여 제공
3. useContext() hook을 사용하여 conext를 가져와 state, dispatch사용


React Hooks Tutorial - 23 - Fetching data with useReducer Part 1
이미 useEffect hook으로 data fetching을 해봤었다. 하지만 useEffect 예제는 useState를 썼었다.
이번에는 useReducer hook으로 해본다. 비교를 위해 2개다 구현할것이다. 
useState, useReducer 둘 다 state Manangement에 쓰인다는 것을 기억하자.

시나리오는 다음과 같다. mount되자마자 API call을 한다. data가 fetch되는 동안 loading을 표시, fetch가 성공하면 lading숨기고 data표시,
에러시 loading 숨기고 error 표시.


DataFethcingOne.js

import React, { useState, useEffect } from 'react'  
import axios from 'axios'

function DataFetchingOne() {
  const [loading, setLoading] = useState(true)  <= 3개의 변수가 있고
  const [error, setError] = useState('')
  const [post, setPost] = useState({})

  useEffect(() => {
    axios.get('https://jsonplaceholder.typicode.com/posts')
    .then(response => {      
      setLoading(false);                              <= 3개의 변수 모두를 제대로 세팅한다.
      setPost(response.data)
      setError('')
    })
    .catch(error =>{
      setLoading(true);
      setPost({})
      setError('Something went wrong')
    })
  }, [])

  return (
    <div>
      { loading ? 'loading' : post.title }
      { error ? error : null }
    </div>
  )
}

export default DataFetchingOne


React Hooks Tutorial - 24 - Fetching data with useReducer Part 2

DataFethcingTwo.js

import React, { useState, useEffect } from 'react'  
import axios from 'axios'

function DataFetchingOne() {
  const [loading, setLoading] = useState(true)  <= 3개의 변수가 있고
  const [error, setError] = useState('')
  const [post, setPost] = useState({})

  useEffect(() => {
    axios.get('https://jsonplaceholder.typicode.com/posts')
    .then(response => {      
      setLoading(false);                              <= 3개의 변수 모두를 제대로 세팅한다.
      setPost(response.data)
      setError('')
    })
    .catch(error =>{
      setLoading(true);
      setPost({})
      setError('Something went wrong')
    })
  }, [])

  return (
    <div>
      { loading ? 'loading' : post.title }
      { error ? error : null }
    </div>
  )
}

export default DataFetchingTwo
import React, { useReducer, useEffect } from 'react'
import axios from 'axios'

const initialState = {  <= 1 
  loading: true,  <= 관련된 변수들이 그룹화되었다.
  error: '',
  post: {}
}

const reducer = (state, action) => { <= 2
  switch(action.type) { <= 관련된 transition들이 그룹화되었다.
    case 'FETCH_SUCCESS':
      return {
        loading: false,
        post: action.payload,
        error:''
      }
    
    case 'FETCH_ERROR':
      return {
        loading: false,
        post: {},
        error:'Something went wrong!'
      }

    default:
      return state
  }
}

function DataFetchingTwo() {
  const [state, dispatch] = useReducer(reducer, initialState) <= 3

  useEffect(() => {
    axios.get('https://jsonplaceholder.typicode.com/posts')
    .then(response => {
      dispatch({type:FETCH_SUCCESS, payload:response.data})    <= 4
    })
    .catch(error =>{
      dispatch({type:FETCH_ERROR})      
    })
  }, [])
  return (
    <div>
      { state.loading ? 'loading' : state.post.title }
      { state.error ? state.error : null }
    </div>
  )
}

export default DataFetchingTwo


React Hooks Tutorial - 25 - useState vs useReducer
언제 useState hook, useReducer hook을 써야 하나 아라보자.

시나리오
state의 타입
useState : Number,String, Boolean
useReducer : Object, Array

state transition의 갯수
useState : 한두개
useReducer : 너무 많을때  <= state transition을 예측가능하게 만든다. state변경이 한곳에서 일어나며, 다른 개발자가 추론하기도 쉽다.

state transition이 관련되어 있는가?
useState: no
useReducer: yes  <= 특정한 action에 관련이 있으면 좋다.

business logic
useState : no business logic
useReducer : complex business logic

local vs global
useState: local
useReducer : global


React Hooks Tutorial - 26 - useCallback Hook
useCallback을 다루기 전에 최적화에대해 좀 다루어야 할 필요가 있다. 다음과 같은 상황을 보자.
App.js
import React from 'react'
import './App.css'
import ParentComponent from './components/ParentComponent'

function App() {
  return (
    <div className="App">
      <ParentComponent />
    </div>
  )
}

export default App

단순한 container component인 ParentComponent이다. Tile, Count, Button을 포함한다.
ParentComponent.js

import React, { useState } from 'react'
import Count from './Count'
import Button from './Button'
import Title from './Title'

function ParentComponent()
{
  const [age, setAge] = useState(25)
  const [salary, setSalary] = useState(50000)

  const incrementAge = () => {
    setAge(age + 1)
  }

  const incrementSalary = () => {
    setSalary(salary + 1)
  }


  왜 5개의 component로 나눴나? 그냥 JSX에 전부 써서 간단히 하는게 낫지 않은가?
  맞다. 하지만 이건 최적화와 useCallback hook을 위해 일부러 이렇게 만든거다.
  return (
    <div>
      <Title />
      <Count text="Age" count={age} />
      <Button handleClick={incrementAge}>Increment Age</Button>
      <Count text="Salary" count={salary} />
      <Button handleClick={incrementSalary}>Increment Salary</Button>
    </div>
  )
}

export default ParentComponent

Title.js
import React from 'react'

function Title() {
  console.log('Rendering Title')
  return (
    <h2>
      useCallback Hook
    </h2>
  )
}

export default Title

Count.js
import React from 'react'

function Count({ text, count }) {
  console.log(`Rendering ${text}`)
  return (
    <div>
      {text} - {count}
    </div>
  )
}

export default Count

Button.js
import React from 'react'

function Button({ handleClick, children }) {
  console.log('Rendering button - ', children)
  return (  
    <button onClick={handleClick}>
      {children}
      </button>
  )
}

export default Button


이 예제에서 관심이 있는 것은 퍼포먼스이다. 각각의 component에 로그가 있다. 이는 render되는 것을 표시하고 있다.
로그를 확인하자.

최초 로그
Rendering Title
Rendering Age
Rendering button - Increment Age
Rendering Salary
Rendering button - Increment Salary

각각의 component가 render되었다.

이제 Increment Age를 눌러보자. component가 rerender될것이다.
Rendering Title
Rendering Age
Rendering button - Increment Age
Rendering Salary
Rendering button - Increment Salary

Increment Salary도 마찬가지로 모든 component를 rerender한다.
이는 적은 component일때는 큰문제가 안되지만 몇백개의 component를 가지게되면 퍼포먼스에 영향을 끼치게된다.
이를 해결하기위해 rerender가 필요한 component만 rerender해야한다.
Increment Age클릭시에는 Age, Button component만 rerender되어야한다. 다른 3개의 컴포넌트는 rerender될 필요가 없다.
어떻게 최적화 해야하는가?
답은 React.memo()이다. React.memo()는 higher order component이며 functional component가 props나 state가 바뀌지 않았을 경우 rerender되지 않게한다.
React.memo()는 hooks와 관계가 없다.

export default React.memo(Title)
export default React.memo(Count)
export default React.memo(Button)

전부 수정해 주자. 수정뒤 로그를 보자

최초 로그
Rendering Title
Rendering Age
Rendering button - Increment Age
Rendering Salary
Rendering button - Increment Salary

이제 Increment Age를 눌러보자. component가 rerender될것이다.
Rendering Age
Rendering button - Increment Age
Rendering button - Increment Salary

적어지긴했지만 Increment Salary가 rerender되었다.
왜 이런일이 일어 났는가?
<Title />  <= prop, state없음, rerender되지 않는다.
<Count text="Age" count={age} />  <= age를 prop으로 받는다.
<Button handleClick={incrementAge}>Increment Age</Button> <= incrementAge를 prop으로 받는다. incrementAge()는 age에 종속적이다.
<Count text="Salary" count={salary} />
<Button handleClick={incrementSalary}>Increment Salary</Button>  <= incrementSalary는 왜 찍히는 걸까?

Parent component가 rerender될때 incrementSalary가 계속 생성되기 때문이다.
function을 prop으로 넘겼을때 항상 reference equality를 고려해야만 한다.
초기 render에 쓰였던 incrementSalary와 rerender에 쓰이는 incrementSalary는 다른 함수이다.

React.memo()는 prop으로 들어온 function이 다른것을 발견하고 rerender를 막지 않는다.
어떻게 고쳐야 하는가?
답은 useCallback hook이다.

useCallback Hook이란?
useCallback은 memoized version의 callback function을 리턴하는 hook이며 callback이 의존하는 디펜던시가 바뀌게 될때만 memoized version되어 있는 callback을 바꾼다.
예제와 관련시켜보면 useCallback hook은 incrementSalary 함수를 cache하며 salary가 변하지 않는한 cache된 increment Salary함수를 리턴한다.
Salary가 변하게 되면 그때서야 새로운 함수를 리턴한다.

useCallback Hook을 왜쓰는가?
callback함수를 child로 전달할때 필요없는 rerender를 막기 위해 reference equality에 의존하는 optimized child component들을 최적화할때 쓸모있다.
위의 문장을 분해하면
1. callback을 전달할때 유용하다. (incrementAge, incrementSalary)
2. optimized child component. (3개의 child component는 React.memo()를 사용해서 optimized되어 있다. 필요없는 rerender를 막는다.)
3. reference equality는 함수들이 같은가의 비교

위의 모든 조건이 만족할때 useCallback을 써서 최적화 해야한다.

useCallback hook은 어떻게 쓰는가?
ParentComponent.js
import React, { useState, useCallback } from 'react'  <= impot!
...

function ParentComponent() {
  ...
  const incrementAge = useCallback( () => { setAge( age + 1 ) }, [age] ) <= 함수, 함수가 의존하는 dependency list
  const incrementSalary = useCallback( () => { setSalary( salary + 1000 ) }, [salary] )
  ...
}

useCallback을 통해 castFunction을 child prop으로 전달한다.


이제 Increment Age를 눌러보자. component가 rerender될것이다.
Rendering Age
Rendering button - Increment Age

의문은 왜 모든 경우 useCallback hook을 쓰지 않는가? 다음 링크에 왜 항상 useCallback을 쓰는 것이 좋은 생각이 아니라는 것을 설명하고 있다.
https://kentcdodds.com/blog/usememo-and-usecallback


React Hooks Tutorial - 27 - useMemo Hook
최적화에 관련된 다른 훅이 있다. useMemo Hook
문제를 인지하기 위해 다음과 같은 예를 만든다.

Counter.js
import React, { useState } from 'react'

function Counter() {
  const [counterOne, setCounterOne] = useState(0)
  const [counterTwo, setCounterTwo] = useState(0)

  const incrementOne = () => {
    setCounterOne(counterOne + 1)
  }

  const incrementTwo = () => {
    setCounterTwo(counterTwo + 1)
  }

  const isEven = () => {
    let i = 0 <= 만약 even이라는 함수가 굉장히 시간이 오래 걸리는 함수라고 해보자!
    while( i < 200000000000) i++
    return counterOne % 2 === 0
  }

  return (
    <div>
      <div>
        <button onClick={incrementOne}>Count One - {counterOne}</button>
        <span>isEven() ? ' Even': ' Odd'</span>
      </div>
      <div>
        <button onClick={incrementTwo}>Count One - {counterTwo}</button>
      </div>
    </div>
  )
}

export default Counter

isEven()처럼 시간이 오래 걸리는 경우가 있다. 예로서 fetching, array mapping, filtering, sorting등을 할때이다.
Count One 버튼을 누를때 딜레이가 발생하는 것을 알수있다. 이는 isEven()함수때문이다.
Count Two 버튼을 누를때도 딜레이가 발생한다! 이상하지 않은가? 이는 state가 업데이트 될때마다 component가 rerender되기때문이다.
rerender될때마다 isEven()이 호출되고 이는 속도에 영향을 미친다.
counterTwo 값만 변경되었을때는 isEven()을 호출하지 않도록 하는 방법이 필요하다.
이 경우가 useMemo()가 등장할때이다.
useMeme hook은 dependency들이 바뀔때만 cache된 value를 재계산 하는 hook이다. 이는 비싼 계산을 모든 render마다 피할수있게 하는 최적화이다.
useCallback과 매우 사용법이 비슷하다.

import React, { useState, useMemo } from 'react'
...
 const isEven = useMemo(() => {
    let i = 0 <= 만약 even이라는 함수가 굉장히 시간이 오래 걸리는 함수라고 해보자!
    while( i < 200000000000) i++
    return counterOne % 2 === 0
  }, [counterOne]) <= 첫번째는 함수, 두번째는 dependency array

...
 return (
    <div>
      <div>
        <button onClick={incrementOne}>Count One - {counterOne}</button>
        <span>isEven ? ' Even': ' Odd'</span>  <= 함수가 아니다!
      </div>
      <div>
        <button onClick={incrementTwo}>Count One - {counterTwo}</button>
      </div>
    </div>
  )

  vue의 computed와 비슷한 기능을 하는듯...

이제 Count One을 누를때만 딜레이가 생기며 Count Two에는 영향을 미치지 않는다.

useCallback과 useMemo는 아주비슷하게 느껴질것이다.
다른점은 무엇인가?
useCallback은 제공된 함수 자체를 cache하지만 useMemo는 주어진 함수의 결과를 cache한다.
함수 자체를 cache하려면 useCallback을 사용하고 함수의 결과를 cache하려면 useMemo를 사용한다.


React Hooks Tutorial - 28 - useRef Hook Part 1
useRef hook은 functional component에서 직접적으로 DOM node를 접근할수 있게한다.

예로서 Mount시 text input을 focus해보자.

FocusInput.js
import React, { useEffect, useRef} from 'react'  <= 1. useRef import

function FocusInput() {
  const inputRef = useRef(null)  <= 2. 초기값을 null로 지정하여 ref생성

  useEffect(() => {
    // focus the input element
    inputRef.current.focus();  <= 4. current property가 어디서 왔는가? React가 실제 DOM node를 넣어준다.
  }, [])
  return (
    <div>
      <input ref={inputRef} type="text" /> 3. JSX 예약된 ref attribute에 ref를 넣어준다.
    </div>
  )
}

export default FocusInput

imperatively access DOM node를 useRef hook을 써서 어떻게 하는지 보여준다.
하지만 이것이 useRef가 필요한 유일한 이유는 아니다.

React Hooks Tutorial - 29 - useRef Hook Part 2
useRef가 쓸모있는 다른 시나리오를 예를 통해 살펴보자.
관련된 경우를 보기위해 class component를 먼저 보자
ClassTimer.js
import React, { Component } from 'react'

export class ClassTimer extends Component {
  interval  <= timer id 저장!

  constructor(props) {
    super(props)
  
    this.state = {
       timer: 0
    }
  }

  componentDidMount(){
    this.interval = setInterval(() => {
      this.setState(prevState => ({timer: prevState.timer + 1}))
    }, 1000)
  }
  
  componentWillUnmount() {
    clearInterval(this.interval)
  }

  render() {
    return (
      <div>
        Class Timer - {this.state.timer}
        <button onClick={() => clearInterval(this.interval)}>Clear Timer</button>  <= Clear Timer button을 누르면 Timer가 clear된다.
      </div>
    )
  }
}

export default ClassTimer

위의 예제를 Hook을 사용해 다시 만들어보자
import React, {useState, useEffect} from 'react'

function HookTimer() {
  const [timer, setTimer] = useState(0)

  useEffect(()=>{
    const interval = setInterval((
      setTimer(prevTimer => prevTimer + 1)
    ), 1000)

    return () => {
      clearInterval(interval)
    }

  },[])

  return (
    <div>
      Hook Timer - {timer}
      <button onClick={() => clearInterval(interval)}>Clear Hook Timer</button>
    </div>
  )
}

export default HookTimer
 
Clear Hook Timer button을 클릭하면 익셉션이 발생 interval이 undefined이다. 당연한 결과이다.
interval은 useEffect안에서 선언되었기 때문이다.
useEffect안에서는 clearInterval을 할수 있지만 button의 event handler에서는 clearInterval을 할수 없다.
이 상황을 구원하기위해 useRef가 필요하다.
ref attribute를 사용하여 DOM node를 레퍼런스 할수있지만 사실 ref는 어떠한 mutable value를 저장할수도있다.
useRef의 굉장한 점은 rerender사이에도 존재하며 추가적으로 value가 바뀌더라도 추가적인 rerender도 발생시키지 않는다.


import React, {useState, useEffect, useRef} from 'react'  <= 1. import useRef

function HookTimer() {
  const [timer, setTimer] = useState(0)
  const intervalRef = useRef();  <= 2. create ref

  useEffect(()=>{
    const intervalRef.current = setInterval(( <= 3. ref.current에 Interval 저장! 및 사용!
      setTimer(prevTimer => prevTimer + 1)
    ), 1000)

    return () => {
      clearInterval(intervalRef.current) <= 3. 사용!
    }

  },[])

  return (
    <div>
      Hook Timer - {timer}
      <button onClick={() => clearInterval(intervalRef.interval)}>Clear Hook Timer</button> <= 3. 사용!
    </div>
  )
}

export default HookTimer

이것이 useRef의 두번째 용도이다.

useRef hook은 class component의 intance property와 비슷한 mutable value를 가질 수 있는 generic container를 생성하는 데 사용될수있다.
이 generic container는 저장하고 있던 data가 바뀌어도 rerender를 발생시키지 않는다. 또한 다른 state 변수에 의해 rerender가 되더라도 저장된 data를
가지고 있다.


main hook들은 전부 살펴 보았다.
3개의 거의 잘 쓰이지 않는 hook들이 있다.
useImperativeHandle, useLayoutEffect, useDebugValue이다. 설명하지 않겠다.
대신 할것은 Custom Hook이다. 자신의 hook을 생성하는 것을 이해하면 실제 hook의 힘을 알수 있을 것이다.


React Hooks Tutorial - 30 - Custom Hooks
지금까지의 hook들은 React가 제공하는 hook이었다.
사실 custom hook을 만드는데는 제약이 없으며 권장하는 사항이다.
component logic을 추출하여 resuable function에 집어넣어 hook을 만드는 것을 추천한다.

custom hook은 이름이 "use"로 시작하는 javascript function이다.
만약 필요하다면 custom hook은 다른 hook들을 호출할수있다.

왜 custom hook이 필요한가?
logic 공유 - HOC와 Render Props의 더 간단한 대안이다!

가능성은 무한하며 기본만 강의하고 나머진 상상력에 맡기겠다.

React Hooks Tutorial - 31 - useDocumentTitle Custom Hook
간단한 예제를 위해 document.title을 바꾸는 예제를 만들어보자.
처음에는 custom hook없이 만들어보고 logic을 custom hook 으로 추출하는 방법을 보자

DocTitleOne.js
import React, { useState, useEffect } from 'react'

function DocTitleOne() {
  const [count, setCount] = useState(0)

  useEffect(()=>{
    document.title = `Count ${count}` 
  }, [count])

  return (
    <div>
    <button onClick={() => setCount(count + 1)}>Count - {count}</button>
    </div>
  )
}

export default DocTitleOne

DocTitleTwo.js를 복사해서 만들어보자...
import React, { useState, useEffect } from 'react'

function DocTitleTwo() {
  const [count, setCount] = useState(0)

  useEffect(()=>{
    document.title = `Count ${count}` 
  }, [count])

  return (
    <div>
    <button onClick={() => setCount(count + 1)}>Count - {count}</button>
    </div>
  )
}

export default DocTitleTwo


자..같은 기능을 가진 2개의 component가 생겼다.
당연히 다른 component간에 같은 logic을 갖게되었다. document.title을 update하는 100개의 다른 component가 있다고 해보자..
계속 같은 코드를 반복하고 싶지 않을 것이다. CustomHook이 필요한 상황이다.

hooks라는 폴더를 만든다.
useDocumentTitle.js를 만든다.
import React from 'react'

function useDocumentTitle() {  <= hook은 use로 시작해야 한다. 이는 convention이며 아 convention을 linter등이 사용하기 때문에 반드시 지켜라.
  return (
    <div>
      
    </div>
  )
}

export default useDocumentTitle

우리가 여기에 있길 원하는 재사용 가능한 코드는 무엇인가? useEffect()부분이다.
import {useEffect} from 'react'  <= JSX를 사용하지 않으므로 React 불필요

function useDocumentTitle(count) {  <= parameter로 count를 받지 않는다.
   useEffect(()=>{
    document.title = `Count ${count}` 
  }, [count])
}

export default useDocumentTitle

useDocumentTitle hook을 사용해보자.
DocTitleTwo.js
import React, { useState, useEffect } from 'react'

function DocTitleTwo() {
  const [count, setCount] = useState(0)

  useEffect(()=>{
    document.title = `Count ${count}` 
  }, [count])

  return (
    <div>
    <button onClick={() => setCount(count + 1)}>Count - {count}</button>
    </div>
  )
}

export default DocTitleTwo